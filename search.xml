<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux文件与目录操作]]></title>
    <url>%2F2019%2F09%2F09%2FLinux%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[目录处理cd change directory 切换目录1# cd - 返回之前的目录pwd print working directory 显示当前目录1# pwd -p 获得实际路径而非连接路径mkdir 新建目录123# mkdir [-mp] dirname-m ：新建自定义权限的目录 如 mkdir -m xyz test-p ：递归创建 如 mkdir -p test1/test2/test3 rmdir 删除空目录 1# rmdir [-p] dirname 同上 文件处理 cp copy 123456789# cp [-adfilprsu] source destination-a ：同-pdr-d ：若源文件是连接文件则复制连接文件而非本身-i ：若目标文件存在，询问是否覆盖-l ：创建硬连接的连接文件-p ：连同文件属性复制，常用于备份-r ：递归复制，用于目录的复制行为-s ：创建符号连接文件，即快捷方式-u ：源文件新才 update 默认情况下目的文件的所有者是命令操作者 没有参数时 cp 复制的是源文件而非连接文件 rm remove 1234# rm [-fir] dirname/filename-f : force 强制，忽略不存在的文件且不警告-i ：删除前进行询问-r ：递归删除 目录名以 - 开头会造成误判，可以用 ./ 避免 mv move 1234# mv [-fiu] source destination-f ：force 若目标文件已存在则直接覆盖不询问-i ：若目标文件存在，询问是否覆盖-u ：源文件新才 update 多个源文件或目录要移动时，最后一个（即目标文件）一定是目录 废话 文件内容查阅 cat concatenate 从第一行开始显示文件内容 1234# cat [-AbEnTv]-A ：相当 -vET 整合，特殊字符 断行字符$ Tab键＾I-b ：列出行号，空白行不标号-n ：列出行号，包括空白行 tac cat 反写，功能也是 nl 添加行号显示 123456789# nl [-bnw]-b ：行号的指定方式 a 空行也显示，类似 cat -n t 空行不显示行号，默认值-n ：行号的表示方法 ln 行号字段最左显示 rn 行号字段的最右显示，不加 0 rz 行号字段的最右显示，加 0-w ：行号字段的位数，默认六位 more ： less ： head ： tail ： od ：]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件与目录概念]]></title>
    <url>%2F2019%2F09%2F08%2FLinux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[文件属性示例1-rw-r--r-- 1 root root 63428 Sep 8 19:24 xxxxx.md 第一列 第一位 [d] 目录 [-] 文件 [l] 连接文件 linkfile [b] 可供存储的设备 是设备文件 [c] 串行端口设备 是设备文件 第一列 第二~九位三个一组，分别为 文件所有者权限 同用户组权限 其他用户权限 每组三个参数依次为 r读-4 w写-2 x执行-1Linux 中文件的可执行性与文件名无绝对关系文件与目录的权限意义不同 第二列链接到此节点 i-node 的不同文件名数&ensp;&ensp;文件名集合权限与属性记录到文件系统的 i-node 中 第六列创建日期或最近修改日期显示完整时间格式： 1# ls -l --full-time &ensp;&ensp;中文无法在终端显示所以： 1# LANG= en_US 改变文件属性 复制行为 cp 不会更改源文件的属性 chgrp 改变所属用户组change group 1# chgrp [-R] groupname dirname/filename 组名在 /etc/group 中，否则报错 chown 改变所有者change owner 12# chown [-R] ownername dirname/filename# chown [-R] ownername:groupname dirname/filename 组名在 /etc/passwd 中，否则报错ownername:groupname 同时更改 owner 和 group，不要用 . 防止误判 chmod 改变权限change modify 12# chmod [-R] xyz dirname/filename# chmod u/g/o/a +/-/= r/w/x dirname/filename 目录树状，记录文件名列表 FHS/根目录，开机相关FHS建议 / 所在分区应越小越好，但以下不应该与根目录分开： /etc 配置文件 /bin 执行文件，可被 root 和一般用户共用 /dev 设备文件 /lib 函数库和内核所需模块 /sbin 执行文件，多用于设定系统文件，root 限定因为与开机过程有关，开机仅挂载根目录，其他分区在开机完成后进行根目录也有 . 和 ..，但两者都是根目录本身 /usrUNIX software resourse 软件资源数据，可分享 shareable 不可变动 static /varvariable 常态性变动文件，缓存，登陆文件，软件运行产生的文件等 权限之于目录 r read contents in directory读取目录结构列表的权限，即 文件名数据，可利用 ls 查询内容列表 w modify contents in directory读取目录结构列表的权限，即 新建新的文件和目录 删除已存在的文件与目录（无视其它权限） 重命名已存在的文件与目录 转移目录内的文件与目录位置 x access directory用户进入该目录成为工作目录的权限 目前所在的目录 例：r–（目录） 用户访问 root 的目录仅可查询目录下的文件名列表但不能切换到此目录，无法执行任何该目录下的命令例：rwx（目录） 用户访问 root 的 — 文件不可读 编辑 执行 但可以删除 路径 PATH相对路径相对于当前工作目录，shell scrits 下执行环境不同可能导致问题 绝对路径一定由根目录 / 写起，正确度更好 系统依照 PATH 的设置去 PATH 定义的目录下查询对应文件名的可执行文件不同用户默认 PATH 不同，故默认可直接执行指令也不同但 PATH 可以修改，一般用户可通过修改 PATH 执行 /sbin 或 /usr/sbin 的命令来查询 12# echo $PATH 查询# PATH=&quot;$PATH&quot;:/dirname 添加目录进 PATH 相同命令在不同目录，先被查询到的目录先执行 12# basename 取文件名# dirname 取目录名]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19-09碎碎念]]></title>
    <url>%2F2019%2F09%2F08%2F19-09%E7%A2%8E%E7%A2%8E%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[开学了嗯 争取每天做总结吧（接下来的计划 抓紧把 Linux 基础速读掉，补笔记 属性与权限概念 目录概念与文件系统 磁盘相关 抽空整fu理xi HTML5 CSS JavaScript 笔记，主要把书看掉 抽空整fu理xi JAVA 笔记 这些定在十月前吧，到时候看下摸鱼程度x]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
      <tags>
        <tag>小目标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于静态成员]]></title>
    <url>%2F2019%2F09%2F06%2F%E5%85%B3%E4%BA%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%2F</url>
    <content type="text"><![CDATA[静态成员：属于类本身，不属于类的实例，在程序加载时至程序结束时一直存在，用类名直接调用（不需要实例对象） 非静态成员：属于类的实例的，不属于类本身 因此，静态的成员，不能访问非静态成员（毕竟两者无关系）。但是实例方法在类中可以访问静态字段 静态成员函数与普通成员函数的差别在于缺少this，静态成员在类加载时就存在于内存（堆）中共享，与全局函数相比，这样可以减少内存开销]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>静态</tag>
        <tag>思路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种类型的比较方法]]></title>
    <url>%2F2019%2F09%2F06%2F%E5%90%84%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[内存地址比较用 equalsstring 类型与 null 比较用 ==string 类型与空字符串 “” 比较用 equals乱入12String str1 = null; //str引用为空 String str2 = ""; //str引用为空串相关如果 str1=null; 这个的写法错误⬇： 123if(str1.equals("")||str1==null)&#123; //如果str1没有值，则返回false &#125; 正确的写法是： 123if(str1==null||str1.equals(""))&#123; //先判断是不是对象，如果是，再判断是不是空字符串 &#125;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>思路</tag>
        <tag>比较</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量赋值与构造函数的执行顺序]]></title>
    <url>%2F2019%2F09%2F06%2F%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E4%B8%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[子类给成员变量分配空间，在栈中默认初始化成0 调用子类构造函数，因为继承，调用 super(); 调用父类构造函数，因为覆盖，执行子类方法 执行父类构造函数其他语句 父类构造函数结束弹栈 子类对成员变量显示初始化(赋值) 调用子类构造函数其他语句 检验 123456789101112131415161718192021222324252627282930class Fu&#123; Fu() &#123; this.getNum(); &#125; public void getNum() &#123; System.out.println("父类"); &#125;&#125; class Zi extends Fu&#123; int num=4; public Zi() &#123; super(); System.out.println("子类构造函数中"+this.num); &#125; public void getNum() &#123; System.out.println("getNum方法"+this.num); &#125;&#125; public class learn&#123; public static void main(String[] args) &#123; new Zi(); &#125;&#125;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>思路</tag>
        <tag>构造函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象实例化过程]]></title>
    <url>%2F2019%2F09%2F06%2F%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1Test t = new Test; JVM 读取 Test.class 文件并加载进内存，加载 Test 的父类(如果有) 堆内存中开辟空间，分配地址 在对象空间中，对对象中的属性进行默认初始化 调用对应的构造函数进行初始化 在构造函数中，先调用父类的构造函数进行初始化 父类初始化完毕后，对子类的属性进行显示初始化（ super(); 和第二句之间的动作） 进行子类构造函数的特定初始化 初始化完毕，将地址值赋值给引用变量]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>思路</tag>
        <tag>构造函数</tag>
        <tag>实例化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[九月四日，YUYU向宇宙发出的第一声啼鸣，以太阳为中心，以光速向宇宙深处飞驰......(x]]></content>
  </entry>
</search>
