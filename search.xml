<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux bash]]></title>
    <url>%2F2019%2F11%2F06%2FLinux-bash%2F</url>
    <content type="text"><![CDATA[shell用户默认取得的 shell 记录于 /etc/passwd，默认是 bash上一次登录的历史命令记录在 ~/.bash_histroy，本次登录的会在注销后记录进去内置命令和外部命令123# type [-ta] name-t 仅显示执行时的依据-a 显示所有含 name 的命令内置命令是 shell 解释程序内建的，由 shell 直接执行，不需要派生新的进程；外部命令 shel会创建一个新的进程，新的进程在 PATH 变量内所列出的目录中寻找特定命令执行，默认 shell 将等待直到该进程结束 变量env 查看当前 shell 环境下的环境变量和内容set 查看所有变量，包含环境变量和自定义变量 设置规则不能以数字开头，连接的 = 两边不能直接接空格，变量内容若有空格使用 “ 或 ‘，必须成对 “ 可以保持特殊字符的特性，如 var=lang is $LANG 相当于 lang is en_US ‘ 仅为纯文本 `命令` 和 $(命令) 用于在命令中使用其他命令的值，如 echo $version $变量名称 ${变量名称} 用于显示变量或增加变量内容，如 PATH=”$PATH”:/home/bin 转义字符 / 将特殊符号变成一般符号，命令过长可以 /[enter] 换行 若变量需要在子进程进行需要用 export 变成环境变量 unset 取消变量]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[汇编课程记录4]]></title>
    <url>%2F2019%2F11%2F04%2F%E6%B1%87%E7%BC%96%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%954%2F</url>
    <content type="text"><![CDATA[嗯这周也继续昏迷x通用数据传送指令1MOV DST,SRC ;传送指令操作数与目的长度必须为 8/16 位目不能为 CS IP 或立即数存储单元和段寄存器之间不能直接传送数据，要用通用寄存器为桥梁立即数不能直接送到段寄存器123456PUSH SRC ;进栈指令;(SP) ⬅ (SP) -2;((SP+1), (SP)) ⬅ (SRC)POP DST ;出栈指令;(DST) ⬅ ((SP+1), (SP));(SP) ⬅ (SP) +2 PUSH 操作数为 16 位的寄存器，存储器，不允许立即数，避免 PUSH SP，因为 8086/8088 和 80286 对此的处理方式不同POP 目为 16 位的寄存器（不允许 CS 段寄存器），存储器堆栈的存取必须以字为单位，PUSH 和 POP 只能做字操作 1XCHG DST, SCR ;交换指令 两个操作数必须有一个在寄存器中，且不允许段寄存器，允许字或字节操作（长度 8/16 位），不允许立即数寻址 累加器专用传送指令1234IN AL, PORT ;长格式-字节IN AX, PORT ;长格式-字IN AL, DX ;短格式-字节IN AX, DX ;短格式-字 将外部设备的信息输入到 CPU 的累加器 AL/AX 中，源操作数是外部设备端口地址，通过 DX 寄存器指明的地址可以间接寻址 65536 个端口，而用立即数直接指明的地址只能寻址 256 个 1234OUT PORT, AL ;长格式-字节OUT PORT, AX ;长格式-字OUT DX, AL ;短格式-字节OUT DX, AX ;短格式-字 将 CPU 累加器中的信息输出到外部设备，基本和 IN 反过来 地址传送指令123456LEA REG, SRC ;有效地址送寄存器指令LEA BX, TABLEMOV BX, OFFSET TABLE;两个功能相同，MOV 执行速度比 LEA 快，但 OFFSET 只能用简单符号地址;与 MOV DST,SRC 区别，此处得到的是有效地址而非存储单元的内容 REG 寄存器，将源操作数的有效地址送到指定寄存器，且必须为 16 位通用寄存器 1234567LDS REG, SRC ;送寄存器和 DS 指令LES REG, SRC ;送寄存器和 ES 指令;(REG) ⬅ (SRC);(SREG) ⬅ (SRC+2);将存储单元中存放的 16 位偏移地址（即 SRC 的内容）装入;指定寄存器，然后将（SRC+2）中的 16 位段地址装入指定的;段寄存器 SREG DS 或 ES，源操作数只能用存储器寻址，目不允许段寄存器 类型转换指令123456CBW ;字节转字;将 AL 中的内容扩展到 AH，若 (AL) 最高有效位为 0，;则 (AH) 为 0，为 1，则 (AH) =0FFHCWD ;字转双字;将 AX 中的内容扩展到 DX，形成 DX:AX 双字，;若 (AX) 最高有效位为 0，则 (DX) 为 0，为 1，则 (DX) =0FFFFH]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim的乱七八糟]]></title>
    <url>%2F2019%2F10%2F27%2Fvim%E7%9A%84%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F%2F</url>
    <content type="text"><![CDATA[文件vim 编辑文件时会新建 .filename.swp 文件，记录所作操作，当 vim 被不正常中断（或他人正在编辑）时暂存文件不会消失，继续编辑时允许如下操作： R 加载暂存文件的内容，恢复未保存的工作，记得离开 vim 后手动删掉暂存文件 D 确定暂存文件无用，删除并新建本次使用的 .swp O 以只读打开，不进行编辑行为，用于他人正在编辑 环境记录文件~/.viminfo 环境配置文件/etc/vimrc，建议创建 ~/.vimrc - - :setnu :set nonu 行号 :set all 当前环境参数 :set 与默认不同的参数 操作1.块选择 一般模式下 [ctrl]-v 选择，y 复制，p 粘贴 2.多窗口 新窗口 光标向下 光标向上 :sp / :sp{filename} [ctrl]-w+j [ctrl]-w+k 3.多文件| 当前打开的文件 | 下一个 | 上一个 ||—————|:————–|:————–:|| :files | :n | :N | 注意中文编码 1234567# LANG=zh_CN.xxx# iconv --list# iconv -f 原编码 -t 新编码 filename [-o newfile]-f from-t to-o newfile 保留原本文件 断行符DOS ：^M$，即 CR 和 LFLinux ：$，仅 LF 1234# dos2UNIX [-kn] file [newfile]# UNIX2dos [-kn] file [newfile]-k 不修改 mtime-n 输出到新文件]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>编码乱码</tag>
        <tag>断行符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19-10碎碎念]]></title>
    <url>%2F2019%2F10%2F27%2F19-10%E7%A2%8E%E7%A2%8E%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[十月底… :drooling_face: 这个月也摸鱼了（也？） 接下来三天的计划 JAVA 抽空看会卷一 前端 暂时放一边… Linux 尽快补掉 bash 笔记，速读磁盘和压缩 课程 复习汇编和离散数学]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
      <tags>
        <tag>小目标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编课程记录3]]></title>
    <url>%2F2019%2F10%2F27%2F%E6%B1%87%E7%BC%96%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%953%2F</url>
    <content type="text"><![CDATA[这节也昏迷了…（艹，原来这边还没上数据寻址方式立即数寻址操作数直接存放于指令1MOV AX,1234H ;即1234H寄存器寻址操作数存放于 CPU 的某个寄存器中，不需访问存储器速度快8 位操作数寄存器可以是 AH AL BH BL CH CL DH DL16 位操作数寄存器可以是 AX BX CX DX SP BP SI DI 1MOV AX,BX 存储器直接寻址数据在存储器中，存储单元的有效地址（偏移地址 EA）由指令直接给出，计算机通过段基址和有效地址获得物理地址（左移四位 + 偏移量balabala），段基址默认为 DS 数据段 1234MOV AX,[100H]MOV AX,A1MOV AX,[A1] ;和上面那条等效MOV AX,ES:[100H] ;取 ES 段段基址，加偏移量 100H 寄存器间接寻址操作数在存储器中，操作数的有效地址在某个寄存器中 仅可使用这些寄存器 BX BP SI DI，其中 BP 默认段是 SS 段 1MOV AX,[SI] 寄存器相对寻址操作数的有效地址是一个基址寄存器（BX/BP）或变址寄存器（SI/DI）内容与指定 8/16 位偏移量之和 允许的寄存器同间接寻址方式 12345MOV AX,100H[SI]MOV AX,[SI+100H] ;和上面那条等效MOV AX,COUNT[SI];COUNT 为 16 位位移量的符号地址，设 (DS)=3000H (SI)=2000H COUNT=3000H (35000H)=5678H;物理地址 = 30000H + 2000H + 3000H = 35000H 即(AX)=5678H 基址变址寻址操作数的有效地址由一个基址寄存器和一个变址寄存器的内容相加组成，BX 默认段为 DS，BP 默认段是 SS，适用于数组或表格处理，首地址存放在基址寄存器中，用变址寄存器访问数组的元素 1MOV AX,[BX][DI] 相对基址变址寻址基址变址寻址的基础上再加一个 8/16 位位移量，适用于二维数组，偏移量指向文件首，基址寄存器指向某记录，变址寄存器指向记录中的元素 1MOV AX,MASK[BX][SI] 程序转移寻址方式程序的执行由指令的地址指针（CS 和 IP）决定，IP 的内容会自动改变指向下一条指令的地址； 段内转移仅改变 IP 地址，段间转移因为不在同一个代码段同时要改变 CS 的值 段内直接寻址转向的有效地址是相对于当前 IP 值的 8/16 位位移量，即 IP 寄存器内容与指定位移量之和，唯一支持条件转移指令，位移量仅允许 8 位，用于无条件转移指令时，8 位称短跳转，16 位称近跳转 1234JMP SHORT ADDR2 ;无条件转移 JMPADDR2:...JMP NEAR PTR ADDR1 段内间接寻址转向的有效地址是一个寄存器或一个存储单元的内容，通过除立即数寻址以外的任何寻址方式获得，然后取代 IP 寄存器的内容 12JMP BXJMP WORD PTR [BX+ADDR] ;WORD PTR 指出其后的地址长度为一个字 段间直接寻址在指令中直接提供转向地址和偏移地址，分别取代 CS 和 IP 寄存器的内容 1JMP FAR PTR ADDR 段间间接寻址用存储器中两个相继字的内容取代 IP 和 CS 的内容，通过除立即数寻址和寄存器寻址以外的任何寻址方式获得，有效地址的第一个字作为转移偏移地址送 IP 寄存器，第二个字节作为转移段地址送 CS 寄存器 1JMP DWORD PTR [ADDR+BX]]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[temp]]></title>
    <url>%2F2019%2F10%2F21%2Ftemp%2F</url>
    <content type="text"><![CDATA[19-11-04123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;void sum(int);int main() &#123; sum(5); return 0;&#125;int factorial(int num) &#123; if (num == 1) return 1; else return num * factorial(num - 1);&#125;void sum(int num) &#123; int sum = 0; for (int i = 1; i &lt;= num; i++) &#123; factorial(i); sum += factorial(i); cout &lt;&lt;i&lt;&lt; &quot;!=&quot;&lt;&lt;factorial(i) &lt;&lt; endl; &#125; cout&lt;&lt;&quot;阶乘的和为：&quot;&lt;&lt;sum&lt;&lt;endl;&#125; 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;void godbah();bool prime(int);int main()&#123; godbah(); return 0;&#125;void godbah() &#123; int n; cout &lt;&lt; &quot;输入不小于 6 的偶数：&quot; &lt;&lt; endl; cin &gt;&gt; n; for (int i = 3; i &lt;= n; i++) &#123; if (prime(i) &amp;&amp; prime(n - i)) &#123; cout &lt;&lt; n &lt;&lt; &quot;=&quot; &lt;&lt; i &lt;&lt; &quot;+&quot; &lt;&lt; n - i &lt;&lt; endl; break; &#125; &#125;&#125;bool prime(int num) &#123; int i; for (i = 2; i &lt; num; i += 2) &#123; if (num % i == 0) return false; &#125; if (i == num) return true;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux磁盘管理]]></title>
    <url>%2F2019%2F10%2F10%2FLinux%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[磁盘分区程序1234567# fdisk [-l] 设备名称-l ：输出对应设备的所有的分区，未指定设备则显示系统内能找到的所有分区相关命令 m 查看cylinder 可以通过 +sizeM 让系统自动分配# partprobe &lt;==强制内核重新读取分区表（不重启更新分区表信息）无法处理 2TB 以上的磁盘分区，使用 parted 命令设备名称不应该加上数字如 /dev/hdc1 因为分区针对的是整个硬盘设备 磁盘格式化1# mkfs [-t 文件系统格式] 设备文件名 磁盘检验12# fsck [-t 文件系统] [-ACay] 设备名称-t ：Linux 会通过 super block 分辨文件系统，可省略 检查文件系统是否出错，可能会造成部分损坏，故执行 fsck 时被检查分区需要在卸载状态 1# badblocks [-svw] 设备名称 检查扇区是否有坏轨 磁盘挂载与卸载被挂载的目录理论上应该是空目录，否则原有内容会隐藏到新分区卸载 放弃磁盘，这部分还是面向谷歌吧x]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>操作</tag>
        <tag>硬盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编课程记录2]]></title>
    <url>%2F2019%2F10%2F06%2F%E6%B1%87%E7%BC%96%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%952%2F</url>
    <content type="text"><![CDATA[太困了没听… 实际上不算课程记录…寄存器CPU 优先读写寄存器，依靠名称而非地址区分数据。80386 以上的 CPU 有 8 个 32 位通用寄存器： EAX EBX ECX EDX ESP 堆栈指针寄存器，栈顶的偏移量 EBP ESI EDI 6 个 16 位段寄存器 CS 当前正在运行的程序段 SS 当前堆栈段，配合 ESP 食用 DS 主数据段 ES 附加数据段 FS GS 2 个 32 位控制寄存器 EIP 指令指针寄存器，存放偏移量部分，配合 CS 指出下一条指令的地址 FLAGS 标志寄存器 细节翻书 内存堆 Heap 来自用户主动请求，从起始地址开始向高位增长，不会自动消失 栈 Stack 函数运行而临时占用的内存区域，为每个函数建立一个桢，运行结束则回收桢释放内部变量不再占用内存，由内存区域的结束地址开始向低位，后进先出； 生成新的帧即入栈 push；栈的回收即出栈 pop 段寄存器装入ASSUME 仅指出段和段寄存器之间的关系，并未真正装入 DS ES 12MOV AX,DATAMOV DS,AX CS IP系统自动将 START 所在段段地址送 CS 段内偏移地址送 IP 12345START: . . . END START SS SP自动装入]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>汇编语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件系统操作]]></title>
    <url>%2F2019%2F09%2F28%2FLinux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[df du根据 super block 中的信息12345678# df [-ahikHTm] [filenamedirname]-a : 列出所有文件系统，比默认多显示如内存中的 文件系统-k : 以 KB 显示各文件系统-m : 同上-h : 自行以易阅读的单位显示-H : 以 1M=1000K 计算-T : 增加显示文件系统名称 type-i : 以 inode 数量显示 /proc 这个挂载点在内存中，没有占用任何硬盘空间故大小为 0/dev/shm 是利用内存虚拟的磁盘空间 通过搜索文件计算每个的大小然后累加 12345# du [-ahskm] filenamedirname-a : 列出所有文件和目录容量，默认仅统计目录-hkm : 同 df-s : 仅显示最后加总的值-S : 类似 -s 不包括子目录的大小 12# du –hs xxx 显示目录总大小，不会列出目录中的每一个文件# du –hs xxx/* 列出 xxx 下每个目录和文件所占容量 du 能看到的文件是当前存在没有被删除的，删除一个文件的时候，这个文件不是马上就在文件系统当中消失了，而是暂时消失了，当所有程序都不用时，才会根据OS的规则释放掉已经删除的文件不要直接执行 du 命令，它会遍历并列出目录下的所有文件 连接文件hard link 硬连接/实际连接新建一个文件名连接到 inode 上 文件内容和 inode 有关 通过文件名指向到对应 inode 读取文件 所以 hard link 和源文件除了文件名，相关信息完全一样，若将其中一个文件删除，因为 inode 还有连接故实际还存在不能跨文件系统，不能连接到目录（因为会产生大量连接造成开销） symbolic link 符号连接/快捷方式创建一个独立文件让数据读取指向连接的文件名所以源文件删除后 symbolic link 将无法打开，两个文件指向不同的 indoe目录快捷方式时将同步删除等，新建目录连接至少产生三个：本身 . .. 而上层目录连接数会加一，新目录连接数为二 123# ln [-sf] 源文件 目标文件-s ：symbolic link，不加参数为 hard link-f ：目标文件若存在则先删除再创建]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>概念</tag>
        <tag>查</tag>
        <tag>文件系统</tag>
        <tag>连接文件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编课程记录]]></title>
    <url>%2F2019%2F09%2F23%2F%E6%B1%87%E7%BC%96%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[存储器为了区分不同的内存单元（一字节），每个单元会分配一个存储器地址；地址在计算机中用无符号二进制数表示，可简写成十六进制而字，双字，四字数据类型占用多个单元，在低地址中存放低位字节数据，高地址存放高位字节数据，访问时根据最低单元的地址依此存取后续字节 MSB (Most Significant Byte)，最高有效字节，是一个数据中权值最大的那一个字节LSB (Least Significant Byte)，最低有效字节，是一个数据中权值最小的那一个字节Little-Endian，是指数据的高字节(MSB)保存在内存的高地址中，而数据的低字节(LSB)保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低例如：整型数 0x1A2B3C4D 在内存中存储的方式如下: 实模式本身意义是代表真实的物理地址8086CPU 的数据总线为 16 位，一次最多读取 2^16=64KB 数据（故实模式每个段最大64KB），但地址总线为 20 位，最大寻址能力是 2^20=1MB将若干个地址连续的内存单元看做是一个段，通过将一个段地址左移 4 位形成基地址，再通过这个基地址来定位这个段的起始地址，然后，再通过偏移地址便可以精确定位到段中的内存单元了10H × 段基址 + 偏移量 = 物理地址]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>Little-Endian</tag>
        <tag>实模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件系统概念]]></title>
    <url>%2F2019%2F09%2F18%2FLinux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[回顾硬盘分区磁盘分区指定分区的起始与结束柱面，分区的柱面范围记录在第一个扇区的分区表里面硬盘的第一个扇区中有主引导记录 MBR 446bytes 和分区表 partition table 64bytes，由于大小限制最多只能记录四条分区的记录，即主分区或扩展分区 GPT + UEFI 则扫描整块磁盘上的分区，读取 EFI 分区里的引导文件，所以不再限制在扇区开头的 512bytes 中 硬盘限制主分区和扩展分区最多可以有四个，操作系统限制扩展分区只能有一个，无法被格式化即无法作为数据访问，但扩展分区可以再分出逻辑分区 格式化文件系统通过格式化将 inode 和 block 规划好，并不再变动；不同文件系统格式化方法不同，所以不能相互识别利用 inode 记录文件属性和此文件的数据所在的 block，一个文件占用一个 inode block 实际记录文件内容，可占用多个 super block 记录此文件系统的整体信息，如 inode/block 总量使用量剩余量，文件系统的格式等 碎片整理即因为文件写入的 block 过于离散，影响文件读取性能，需要将它们汇合到一起；这针对没有 inode 的 FAT 系统，Linux 的索引式文件系统基本不需要 文件系统当 inode 和 block 数量极大时不容易管理，Ext2 在格式化时区分为多个块组 block group，每个块组有独立的 inode/block/superblock 系统boot sector 启动扇区在文件系统最前面，用于安装引导装载程序，这样不用覆盖整块硬盘唯一的 MBR，制作多重引导环境 data block 数据块放置文件内容，每个 block 最多放置一个文件的数据，若有剩余空间则浪费；Ext2 支持 1KB 2KB 4KB 三种 block 大小，其决定最大总容量和最大单一文件容量 inodetable至少记录访问模式 所有者和组 大小 ctime atime mtime 内容指向 文件特性，系统读取文件时会先分析 inode 所记录的权限与用户是否符合；每个文件占用一个inode，所以文件系统能创建的文件数量与 inode 数量有关inode 大小固定为 128bytes，当文件较大则不足以记录下所有的 block 编号，故定义了 12 个直接，一个间接，一个双间接，一个三间接记录区 用一个 block 来记录额外的编号，若依然不够则用一个 block 指出下一个记录编号的 block，依此最多三层；以 1KB 大小的 block 计算，12*1K + 256*1K + 256*256*1K + 256*256*256*1K = 16GB，即该文件系统最大容量 superblock一般为 1024bytes，除了第一个 blockgroup 中含有 superblock 外，后面的不一定含有，若有则为备份 文件系统描述 File system Dscription描述每个 blockgroup 的开始与结束编号，说明每个区段介于哪个 block 之间 区段指 superblock bitmap inodemap datablock block bitmap 标记/修改某个 block 是否被使用 inode bitmap同上 查询文件系统 1234# df &lt;== 查询目前挂载的设备# dumpe2fs [-bh] devname-b ：列出坏道部分-h ：仅列出 superblock 数据 新增文件的过程 检查目录是否有 w 和 x 权限 根据 inode bitmap 查找没有使用的 inode 编号并写入新文件的权限属性 根据 block bitmap 查找没有使用的 block 编号并写入实际数据，更新 inode 的指向 将 inode 和 block 信息更新到 inode bitmap 与 block bitmap，并更新 superblock 由于 superblock inodebitmap blockbitmap 的数据经常变动，被称为 metadata 中间数据，而 inode table 和 data block 称为数据存放区域 异步处理 asynchronoly提高效率：系统加载一个文件到内存后，若文件没有被改动，则被设置成 clean，更改过则为 dirty，系统不定时将 dirty 数据写回硬盘 可以 sync 命令手动写回 正常关机会主动调用 sync 命令 与目录树的关系ext2 中的目录新建目录时，会分配一个 inode 和至少一块 block，inode 记录目录的相关权限，属性，和分配到的 block 编号；block 记录此目录下的文件名与文件名的 inode 编号数据 ext2 中的文件新建一般文件时，会分配一个 inode 和对应大小的 block 数量，由于只有 12 个直接指向，可能分配额外的 block 用来记录块编号 inode 本身不记录文件名，而是在目录的 block 中，所以增删改文件名与目录的 w 权限有关。当读取某个文件时务必会经过目录的 inode 和 block，然后找到文件的 inode 最终获得 block 中的数据系统通过挂载信息获得根目录的 inode 号码，并据此获得根目录 block 内的文件名数据，再一层层向下 日志文件系统inconsistent 状态文件在写入文件系统时发生中断，未同步更新 metadata 导致 metadata 的内容和实际数据存放区不一致 避免 inconsistent 发生 写入文件前先在日志记录块记录准备要写入的信息 实际写入，包括更新 metadata 的数据 在日志记录块中完成该文件的记录 发生问题时通过检查日志记录块定位到文件，不必检查整个文件系统，Ext2 中没有文件日志系统，需要对比 metadata 区域和数据存放区]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>概念</tag>
        <tag>目录树</tag>
        <tag>格式化</tag>
        <tag>日志</tag>
        <tag>硬盘</tag>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件目录的权限和命令补充]]></title>
    <url>%2F2019%2F09%2F11%2FLinux%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%9A%84%E6%9D%83%E9%99%90%E5%92%8C%E5%91%BD%E4%BB%A4%E8%A1%A5%E5%85%85%2F</url>
    <content type="text"><![CDATA[默认权限 文件默认没有可执行权限，即最大为 666 目录默认有所有权限，即 777 umask 指定目前用户新建文件或目录时的权限默认值 查看 12# umask [-S]-S ：以字母显示默认权限，否则是数字 其数字结果是该默认值要被拿掉的权限 设置 1# umask xyz root 默认是 022，一般用户是 002用字母进行计算更准确，如 (-rw-rw-rw-) - (——–wx) = -rw-rw-r–,而非 666 - 003 = 663 隐藏属性chattr设置文件的隐藏属性仅在 Ext2/Ext3 的文件系统生效 1234567891011# chattr [+-=][ASacdistu] dirname/filname+ ：仅增加某一个参数- ：仅减少某一个参数= ：仅有后面指定的参数A ：访问此文件/目录时，访问时间 atime 将不会被修改S ：对文件的修改将 同步 写入磁盘a ：root 限定，只能增加数据不能删改c ：文件将被自动压缩，读取时自动解压，存储时先压缩再存储d ：dump 程序被执行时，该文件/目录不会被 dump 备份i ：root 限定，该文件无法被增删改和设置连接 lsattr显示文件的隐藏属性 1234# lsattr [-adR] filname/dirname-a 包括隐藏文件-d 目录属性而非内容-R 递归，子目录数据也显示 特殊权限SUID 4 u+sSetUID 只对文件有效，文件所有者的 x 权限为 s 仅对二进制程序有效，对于 shell script 无效，靠看其根本的二进制文件设置 执行者对改程序有 x 权限 废话 仅在执行过程 run-time 中有效 执行者将拥有 owner 的权限 例：/etc/shadow 记录了所有账号的密码，-rwsr-xr-x root root 仅有 root 可读可强制写入，但用户也能修改自己的密码 SGID 2 g+sSetGID 用户组的 x 权限为 s文件同 SUID目录 用户对此目录有 r 与 x 权限时可进入 用户在此目录下的有效用户组将变成该目录的用户组 若在此目录下有 w 权限，则新文件的用户组和此目录的用户组相同 SBIT 1 o+tStickyBit 只对目录有效，other 的 x 的权限为 x，仅用户自己和 root 有权利删除该目录下的文件/目录 查询文件脚本文件名12# which [-a] command-a 列出所有 PATH 目录中可以找到的同名命令，否者显示找到的第一个 根据 PATH 环境变量规范的路径查找，查不到 bash 内置的命令 文件名 whereis寻找特定文件 数据库 12345# whereis [-bmsu] filname/filname-b 仅找二进制文件-m 仅找说明文件 manual 路径下的文件-s 仅找 source 源文件-u 其它特殊文件 查找文件，故不在 PATH 中也能找到；利用数据库，速度快但结果有延迟 locate 数据库 123# locate [-ir] keyword-i 忽略大小写-r 允许接正则表达式 可以只输入文件的部分名称(包括路径中)，根据 /var/lib/mlocate/ 中的数据，默认每天更新一次可能有延迟，可手动 updatedb 更新 find 硬盘 12345678910111213141516171819202122232425262728293031# find [PATH] [option] [action]与时间有关的参数-mtime n 在 n 天前的 一天之内 被更改过的文件，前24小时即 0 -mtime +n 在 n 天之前被更改过的文件，不含本身 -mtime -n 在 n 天之内被更改过的文件，含本身 -newer file 列出比 file 更新的文件与用户或用户组名有关的参数-uid n 即 UID，记录在 /etc/passwd-gid n 即 GID，记录在 /etc/group-user name 用户账号名称-group name 用户组名-nouser 所有者不在 /etc/passwd 的文件-nogroup 所有用户组不在 /etc/passwd 的文件与文件权限及名称有关的参数-name filename 根据文件名查询-size [+-]SIZE 查找比 SIZE 大或小的文件 k代表1024bytes-type TYPE 查找文件类型为 TYPE 的；一般文件 f，设备文件 b c，目录 d，连接文件 1，socket s，FIFO p-perm mode 文件权限刚好是 mode 的文件，类似 chmod 的属性值-perm +-mode 文件权限全部包含/包含任意 mode 的文件 例 #find /bin /sbin -perm +6000 查找/bin /sbin 两个目录下具有 SUID SGID 的文件 其他操作-exec command 后面可以接其他命令处理查到的结果 #find / -perm +7000 -exec ls -l &#123;&#125;\; &#123;&#125; 代表 find 查找到的内容，\; 转义 本身代表额外命令结束利用通配符查找 #find /etc -name &apos;*httpd*&apos;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>操作</tag>
        <tag>文件</tag>
        <tag>目录</tag>
        <tag>概念</tag>
        <tag>属性权限</tag>
        <tag>查</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件与目录操作]]></title>
    <url>%2F2019%2F09%2F09%2FLinux%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[目录处理cd change directory 切换目录 1# cd - 返回之前的目录 pwd print working directory 显示当前目录 1# pwd -p 获得实际路径而非连接路径 mkdir 新建目录 123# mkdir [-mp] dirname-m ：新建自定义权限的目录 如 mkdir -m xyz test-p ：递归创建 如 mkdir -p test1/test2/test3 rmdir 删除空目录 1# rmdir [-p] dirname 同上 文件处理 cp copy 123456789# cp [-adfilprsu] source destination-a ：同-pdr-d ：若源文件是连接文件则复制连接文件而非本身-i ：若目标文件存在，询问是否覆盖-l ：创建硬连接的连接文件-p ：连同文件属性复制，常用于备份-r ：递归复制，用于目录的复制行为-s ：创建符号连接文件，即快捷方式-u ：源文件新才 update 默认情况下目的文件的所有者是命令操作者 没有参数时 cp 复制的是源文件而非连接文件 rm remove 1234# rm [-fir] dirname/filename-f : force 强制，忽略不存在的文件且不警告-i ：删除前进行询问-r ：递归删除 目录名以 - 开头会造成误判，可以用 ./ 避免 mv move 1234# mv [-fiu] source destination-f ：force 若目标文件已存在则直接覆盖不询问-i ：若目标文件存在，询问是否覆盖-u ：源文件新才 update 多个源文件或目录要移动时，最后一个（即目标文件）一定是目录 废话 文件内容查阅直接查看 cat concatenate 从第一行开始显示文件内容 1234# cat [-AbEnTv]-A ：相当 -vET 整合，特殊字符 断行字符$ Tab键＾I-b ：列出行号，空白行不标号-n ：列出行号，包括空白行 tac cat 反写，功能也是 nl 添加行号显示 123456789# nl [-bnw]-b ：行号的指定方式 a 空行也显示，类似 cat -n t 空行不显示行号，默认值-n ：行号的表示方法 ln 行号字段最左显示 rn 行号字段的最右显示，不加 0 rz 行号字段的最右显示，加 0-w ：行号字段的位数，默认六位 翻页查看 more Space ：向后翻一页 Enter ：向下滚动一行 /字符串 ：当前页向下查询，n 继续查询 :f ：显示出文件名以及目前显示的行数 b/ctrl+b ：回翻，仅限文件，FIFO无效 less Space/PageDown ：向后翻一页 PageUp ：向前翻一页 ?字符串 ：当前页向上查询，n 继续查询 N ：反向继续查询 数据选取head 取出前几行，默认显示十行 12# head [-n num] file 取前 num 行# head [-n -num] file 取 num 行之前，第二个是减号ao（x tail 取后面几行 123# tail [-n num] file 取后 num 行# tail [-n +num] file 取 num 行之后-f 持续监测，应对数据随时写入 od 非纯文本文件 1234# od [-t TYPE] 文件TYPE a ：默认字符输出 c ：ASCII 字符输出 dfox ：十进制 浮点数 八进制 十六进制 文件时间处理1# ls -l --time=?time filname mtime modification time内容数据更改时更新，ls 默认值 ctime status time状态改变时更新，如权限与属性 atime access time内容被取用访问时更新 123456# touch [-acdmt] file-a ：修改 atime-c ：修改文件时间，文件不存不创建新文件-d ：修改 atime mtime，ctime 不变-m ：修改 mtime-t ：修改 atime mtime，ctime 记录当前时间，格式 YYMMDDhhmm 默认将三个时间更新为当前，若文件不存在创建新文件 文件类型查看1# file filename]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>操作</tag>
        <tag>增删查</tag>
        <tag>文件</tag>
        <tag>目录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件与目录概念]]></title>
    <url>%2F2019%2F09%2F08%2FLinux%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[文件属性示例1-rw-r--r-- 1 root root 63428 Sep 8 19:24 xxxxx.md 第一列 第一位 [d] 目录 [-] 文件 [l] 连接文件 linkfile [b] 可供存储的设备 是设备文件 [c] 串行端口设备 是设备文件 第一列 第二~九位三个一组，分别为 文件所有者权限 同用户组权限 其他用户权限 每组三个参数依次为 r读-4 w写-2 x执行-1Linux 中文件的可执行性与文件名无绝对关系文件与目录的权限意义不同 第二列链接到此节点 i-node 的不同文件名数&ensp;&ensp;文件名集合权限与属性记录到文件系统的 i-node 中 第六列创建日期或最近修改日期显示完整时间格式： 1# ls -l --full-time &ensp;&ensp;中文无法在终端显示所以： 1# LANG= en_US 改变文件属性 复制行为 cp 不会更改源文件的属性 chgrp 改变所属用户组change group 1# chgrp [-R] groupname dirname/filename 组名在 /etc/group 中，否则报错 chown 改变所有者change owner 12# chown [-R] ownername dirname/filename# chown [-R] ownername:groupname dirname/filename 组名在 /etc/passwd 中，否则报错ownername:groupname 同时更改 owner 和 group，不要用 . 防止误判 chmod 改变权限change modify 12# chmod [-R] xyz dirname/filename# chmod u/g/o/a +/-/= r/w/x dirname/filename 目录树状，记录文件名列表 FHS/根目录，开机相关FHS建议 / 所在分区应越小越好，但以下不应该与根目录分开： /etc 配置文件 /bin 执行文件，可被 root 和一般用户共用 /dev 设备文件 /lib 函数库和内核所需模块 /sbin 执行文件，多用于设定系统文件，root 限定因为与开机过程有关，开机仅挂载根目录，其他分区在开机完成后进行根目录也有 . 和 ..，但两者都是根目录本身 /usrUNIX software resourse 软件资源数据，可分享 shareable 不可变动 static /varvariable 常态性变动文件，缓存，登陆文件，软件运行产生的文件等 权限之于目录 r read contents in directory读取目录结构列表的权限，即 文件名数据，可利用 ls 查询内容列表 w modify contents in directory读取目录结构列表的权限，即 新建新的文件和目录 删除已存在的文件与目录（无视其它权限） 重命名已存在的文件与目录 转移目录内的文件与目录位置 x access directory用户进入该目录成为工作目录的权限 目前所在的目录 例：r–（目录） 用户访问 root 的目录仅可查询目录下的文件名列表但不能切换到此目录，无法执行任何该目录下的命令例：rwx（目录） 用户访问 root 的 — 文件不可读 编辑 执行 但可以删除 路径 PATH相对路径相对于当前工作目录，shell scrits 下执行环境不同可能导致问题 绝对路径一定由根目录 / 写起，正确度更好 系统依照 PATH 的设置去 PATH 定义的目录下查询对应文件名的可执行文件不同用户默认 PATH 不同，故默认可直接执行指令也不同但 PATH 可以修改，一般用户可通过修改 PATH 执行 /sbin 或 /usr/sbin 的命令来查询 12# echo $PATH 查询# PATH=&quot;$PATH&quot;:/dirname 添加目录进 PATH 相同命令在不同目录，先被查询到的目录先执行 12# basename 取文件名# dirname 取目录名]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>文件</tag>
        <tag>目录</tag>
        <tag>概念</tag>
        <tag>属性权限</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19-09碎碎念]]></title>
    <url>%2F2019%2F09%2F08%2F19-09%E7%A2%8E%E7%A2%8E%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[开学了嗯 争取每天做总结吧（接下来的计划 抓紧把 Linux 基础速读掉，补笔记 属性与权限概念 目录概念与文件系统 磁盘相关 抽空整fu理xi HTML5 CSS JavaScript 笔记，主要把书看掉 抽空整fu理xi JAVA 笔记 这些定在十月前吧，到时候看下摸鱼程度x]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
      <tags>
        <tag>小目标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于静态成员]]></title>
    <url>%2F2019%2F09%2F06%2F%E5%85%B3%E4%BA%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%2F</url>
    <content type="text"><![CDATA[静态成员：属于类本身，不属于类的实例，在程序加载时至程序结束时一直存在，用类名直接调用（不需要实例对象） 非静态成员：属于类的实例的，不属于类本身 因此，静态的成员，不能访问非静态成员（毕竟两者无关系）。但是实例方法在类中可以访问静态字段 静态成员函数与普通成员函数的差别在于缺少this，静态成员在类加载时就存在于内存（堆）中共享，与全局函数相比，这样可以减少内存开销]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>静态</tag>
        <tag>思路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种类型的比较方法]]></title>
    <url>%2F2019%2F09%2F06%2F%E5%90%84%E7%A7%8D%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[内存地址比较用 equalsstring 类型与 null 比较用 ==string 类型与空字符串 “” 比较用 equals乱入12String str1 = null; //str引用为空 String str2 = ""; //str引用为空串相关如果 str1=null; 这个的写法错误⬇： 123if(str1.equals("")||str1==null)&#123; //如果str1没有值，则返回false &#125; 正确的写法是： 123if(str1==null||str1.equals(""))&#123; //先判断是不是对象，如果是，再判断是不是空字符串 &#125;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>思路</tag>
        <tag>基础</tag>
        <tag>比较</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[变量赋值与构造函数的执行顺序]]></title>
    <url>%2F2019%2F09%2F06%2F%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E4%B8%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[子类给成员变量分配空间，在栈中默认初始化成0 调用子类构造函数，因为继承，调用 super(); 调用父类构造函数，因为覆盖，执行子类方法 执行父类构造函数其他语句 父类构造函数结束弹栈 子类对成员变量显示初始化(赋值) 调用子类构造函数其他语句 检验 123456789101112131415161718192021222324252627282930class Fu&#123; Fu() &#123; this.getNum(); &#125; public void getNum() &#123; System.out.println("父类"); &#125;&#125; class Zi extends Fu&#123; int num=4; public Zi() &#123; super(); System.out.println("子类构造函数中"+this.num); &#125; public void getNum() &#123; System.out.println("getNum方法"+this.num); &#125;&#125; public class learn&#123; public static void main(String[] args) &#123; new Zi(); &#125;&#125;]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>思路</tag>
        <tag>构造函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象实例化过程]]></title>
    <url>%2F2019%2F09%2F06%2F%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1Test t = new Test; JVM 读取 Test.class 文件并加载进内存，加载 Test 的父类(如果有) 堆内存中开辟空间，分配地址 在对象空间中，对对象中的属性进行默认初始化 调用对应的构造函数进行初始化 在构造函数中，先调用父类的构造函数进行初始化 父类初始化完毕后，对子类的属性进行显示初始化（ super(); 和第二句之间的动作） 进行子类构造函数的特定初始化 初始化完毕，将地址值赋值给引用变量]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>思路</tag>
        <tag>构造函数</tag>
        <tag>基础</tag>
        <tag>实例化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[九月四日，YUYU向宇宙发出的第一声啼鸣，以太阳为中心，以光速向宇宙深处飞驰......(x]]></content>
  </entry>
</search>
