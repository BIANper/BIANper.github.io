<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git 命令思维导图</title>
    <url>/2020/02/02/Git-%E5%91%BD%E4%BB%A4%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
    <content><![CDATA[<p>没钱开 XMind… 理直气壮不去水印</p>
<p><img src="https://i.loli.net/2020/03/06/UE3BOSHfsbQDtGd.png" alt="git.png"></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>思维导图</tag>
      </tags>
  </entry>
  <entry>
    <title>Git-分支乱七八糟版</title>
    <url>/2019/12/07/Git-%E5%88%86%E6%94%AF%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F%E7%89%88/</url>
    <content><![CDATA[<p>使用 git branch <name> 命令创建分支。git branch -d <name> 删除分支。git branch -v 命令查看每个分支的最后一次提交。git branch –no-merged 查看未合并的分支，未合并的分支 -D 才能删除。<br>切换到一个已存在的分支，使用 git checkout 命令。</name></name></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b name</span><br><span class="line">等同于</span><br><span class="line">git branch name</span><br><span class="line">git checkout name</span><br></pre></td></tr></table></figure><a id="more"></a>


<p>运行 git log –oneline –decorate –graph–all ，会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。<br>使用 git log –decorate命令查看各个分支当前所指的对象。</p>
<p>当合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进，因为这种情况下的合并操作没有需要解决的分歧：即“快进（fast-forward）”。</p>
<p>使用 git merge 命令将指定分支合并到当前分支。<br>在合并冲突后的任意时刻使用 git status 命令查看因包含合并冲突而处于未合并（unmerged）状态的文件。解决了文件里的冲突后，使用 git add 命令来将其标记为冲突已解决。 一旦暂存原本有冲突的文件，Git 就会将它们标记为冲突已解决。</p>
<p>git push (remote) (branch):(newname) 通过这种格式来推送本地分支到一个命名不相同的远程分支。</p>
<p>git fetch 抓取到新的远程跟踪分支时，本地不会自动生成可编辑的拷贝。即不会有一个新的 serverfix 分支，只有一个不可以修改的 origin/serverfix 指针。可以运行 git merge 将这些工作合并到当前所在的分支。若要在自己的分支上工作，可以 git checkout -b 将其建立在远程跟踪分支之上，这会给你一个用于工作的本地分支，并且起点位于远程分支。<br>当 git fetch 命令从服务器上抓取本地没有的数据时，并不会修改工作目录中的内容，它获取数据后让你自己合并。而 git pull 在大多数情况下是一个 git fetch 紧接着一个git merge 命令。</p>
<p>从一个远程跟踪分支检出一个本地分支会自动创建“跟踪分支”（它跟踪的分支叫做“上游分支”）。跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 git pull，Git 会自动识别去哪个服务器上抓取、合并到哪个分支。<br>当克隆一个仓库时，Git 会自动地创建一个跟踪 origin/master 的 master 分支，通过 git checkout -b [branch] [remotename]/[branch] 跟踪其他分支（ Git 提供了 –track 快捷方式）。将本地分支与远程分支设置为不同名字 git checkout -b branchname origin/branch。</p>
<p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，可以使用 -u 或 –set-upstream-to 选项运行 git branch 来显式地设置。<br>查看设置的所有跟踪分支，可以使用 git branch 的 -vv 选项。 这会将所有的本地分支列出来并且包含如每一个分支正在跟踪哪个远程分支，本地分支是否是领先、落后等。</p>
<p>删除服务器上的分支 git push origin –delete branch。</p>
<hr>
<p>变基合并 git rebase。<br><code>git rebase --onto master server client</code> ：取出 client 分支，找出处于 client 分支和 server 分支的共同祖先之后的修改，然后在 master 分支上重放一遍</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>版本控制系统</tag>
        <tag>分支</tag>
        <tag>变基</tag>
      </tags>
  </entry>
  <entry>
    <title>Git-基础乱七八糟版</title>
    <url>/2019/12/04/Git-%E5%9F%BA%E7%A1%80%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F%E7%89%88/</url>
    <content><![CDATA[<p>Git 有三种状态：已提交（committed）、已修改（modified）和已暂存（staged）。</p><ul>
<li>已提交表示数据已保存在本地数据库中。 </li>
<li>已修改表示修改了文件，但还没保存到数据库中。</li>
<li>已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li>
</ul><p>Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 从其它计算机克隆仓库时，拷贝的就是这里的数据。<br>工作目录是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。<br>暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作“索引”。</p><a id="more"></a>


<p>基本的 Git 工作流程如下：</p>
<ol>
<li>在工作目录中修改文件。</li>
<li>暂存文件，将文件的快照放入暂存区域。</li>
<li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</li>
</ol>
<p>工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。<br>已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。<br>工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。</p>
<p>进入该项目目录并输入： git init 该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件。</p>
<p>使用命令 git add 开始跟踪一个文件，如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。<br>若已跟踪文件的内容发生了变化，但还没有放到暂存区。 要暂存这次更新，需要运行 git add 命令。 这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。<br>将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。</p>
<p>要查看哪些文件处于什么状态，可以用 git status 命令。<br>使用 git status -s 命令或 git status–short 命令，你将得到一种更为紧凑的格式输出：<br>新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。 出现在右边的 M 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 M 表示该文件被修改了并放入了暂存区。</p>
<p>想知道具体修改了什么地方，可以用 git diff 命令。<br>此命令比较的是工作目录中当前文件和暂存区域快照之间的差异， 也就是修改之后还没有暂存起来的变化内容。<br>查看尚未暂存的文件更新了哪些部分，不加参数直接输入 git diff。<br>要查看已暂存的将要添加到下次提交里的内容，可以用 git diff –cached 命令。</p>
<p>提交命令 git commit ，在 commit 命令后添加 -m 选项，将提交信息与命令放在同一行<br>给 git commit 加上 -a 选项，Git 会把所有已经跟踪过的文件暂存起来一并提交，跳过 git add 步骤。<br>提交完发现漏掉了几个文件没有添加，或者提交信息写错了。 此时可以运行带有 –amend 选项的提交命令尝试重新提交，如果自上次提交以来你还未做任何修改，那么快照会保持不变，修改的只是提交信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit -m &apos;initial commit&apos;</span><br><span class="line">$ git add forgotten_file</span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure>

<p>从 Git 中移除某个文件，必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。<br>可以用 git rm 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。如果只是简单地从工作目录中手工删除文件，运行 git status 时就会在 “Changes not staged forcommit” 部分（也就是 未暂存清单）看到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git rm PROJECTS.md</span><br></pre></td></tr></table></figure>

<p>把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。 即让文件保留在磁盘，但是并不想让 Git 继续跟踪，使用 –cached 选项。rm 命令后面可以列出文件或者目录的名字，也可以使用 glob 模式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git rm log/\*.log</span><br></pre></td></tr></table></figure>

<p>使用 git reset HEAD <file>… 来取消暂存（修改了两个文件并且想作为两次独立的修改提交，却意外地输入 git add * ，取消暂存两个中的一个）。</file></p>
<p>git checkout – <file>… 撤消修改，</file></p>
<p>运行 git mv 就相当于运行了下面三条命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mv README.md README</span><br><span class="line">$ git rm README.md</span><br><span class="line">$ git add README</span><br></pre></td></tr></table></figure>

<p>git log 会按提交时间列出所有的更新，包括每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。<br>-p 用来显示每次提交的内容差异。–stat 选项列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加。</p>
<p>查看已经配置的远程仓库服务器，运行 git remote 命令。<br>运行 git remote add <shortname> <url> 添加一个新的远程 Git 仓库。<br>从远程仓库中获得数据，可以执行 git fetch [remote-name]，这个命令会访问远程仓库拉取你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用。注意其并不会自动合并。</url></shortname></p>
<p>如果有一个分支设置为跟踪一个远程分支，可以使用 git pull 命令来自动的抓取然后合并远程分支到当前分支。<br>默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支。<br>运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p>
<p>推送到远程仓库：git push [remote-name] [branchname]。只有当你有服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。</p>
<p>运行 git remote rename 去修改一个远程仓库的简写名。移除一个仓库使用 git remote rm。</p>
<p>使用 git show tagname 命令可以看到标签信息与对应的提交信息。</p>
<p>附注标签是存储在 Git 数据库中的一个完整对象。 它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。<br>创建附注标签：git tag -a，使用 -m 选项指定一条存储在标签中的信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag -a v1.4 -m &quot;my version 1.4&quot;</span><br></pre></td></tr></table></figure>

<p>轻量标签本质上是将提交校验和存储到一个文件中，创建时不需要任何选项。<br>后期打标签要在命令的末尾指定提交的校验和（或部分校验和）。</p>
<p>默认情况下 git push 不会传送标签到远程仓库服务器上，运行 git push origin [tagname]，使用 –tags 选项传送所有不在服务器上的标签。</p>
<p>删除本地仓库上的标签，使用命令 git tag -d <tagname>，但并不会从任何远程仓库中移除这个标签，必须使用 git push <remote>:refs/tags/<tagname> 来更新远程仓库。</tagname></remote></tagname></p>
<p>想查看某个标签所指向的文件版本，可以使用 git checkout 命令。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>版本控制系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 常用命令思维导图</title>
    <url>/2020/02/10/Git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
    <content><![CDATA[<p>没钱开 XMind… 理直气壮不去水印</p>
<p><img src="https://i.loli.net/2020/03/06/mxNXZKJ8WRUeojn.png" alt="gitu.png"></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>思维导图</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 补丁-集合</title>
    <url>/2019/12/25/Java%20%E8%A1%A5%E4%B8%81-%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="具体集合部分"><a href="#具体集合部分" class="headerlink" title="具体集合部分"></a>具体集合部分</h1><p><strong>链表 LinkedList</strong><br>List 接口描述有序集合，有两种访问元素的协议，迭代器或 get set 方法，后者更适合数组。链表对于删除插入元素很有效，允许对象有重复的值。<br>Java 中链表都是双向链接的，即每个结点存放前驱结点和下一个结点的引用。如果链表有 n 个元素则有 n+1 个位置可以插入新元素。<br>链表只跟踪结构性修改，set 方法不被视为结构性修改。<br>避免使用整数索引表示链表中位置的方法，如果需要对集合进行指定访问，就使用数组或 ArrayList 而非链表。</p><a id="more"></a>
<p><strong>数组链表 ArrayList</strong><br>也实现了 List 接口，封装了动态再分配的对象数组。不需要同步时使用，若有多个线程访问，应使用 Vector类。</p>
<p><strong>散列集 HashSet</strong><br>Set 的集合里不允许对象有重复的值。HashSet 仅仅存储对象（HashMap 储存键值对），基于 HashMap 实现。<br>散列表为每一个对象计算一个整数（hash code），Java 中用链表数组实现，每个表称为桶。<br>HashSet 类实现了基于散列表的集，散列集迭代器将依次访问所有桶，由于元素分散在表的各个位置上（散列码与桶的总数取余），所以访问的顺序是随机的。<br>对与集中的元素，如果元素的散列码发生了改变，在数据结构中的位置也会发生变化。</p>
<p><strong>树集 TreeSet</strong><br>TreeSet 是一个有序集合，用红黑树实现，任意顺序将元素插入集合遍历时自动排序输出。树的排序必须是全序即任意两个元素是可比的，并且元素必须实现 Comparable 接口，或构造集时提供一个 Comparator 。<br> 添加元素比散列表慢但是检查重复元素快很多。</p>
<p> <strong>双端队列</strong><br> 可以在头部和尾部同时添加或删除元素，不支持在队列中间添加元素。Deque 接口由 ArrayDeque 和 LinkedList 类实现，必要时可增加队列长度。</p>
<p> <strong>优先级队列</strong><br> 使用堆。可以保存实现了 Comparable 接口的类对象，或在构造器中提供的 Comparator 对象。</p>
<h1 id="映射部分"><a href="#映射部分" class="headerlink" title="映射部分"></a>映射部分</h1><p><strong>基本</strong><br>HashMap 和 TreeMap 类都实现了 Map 接口。散列映射对键进行散列，树映射用键的整体顺序对元素进行排序并组织成搜索树。<br>不能对同一个键存放两个值，若调用两次 put 方法，第二个值会取代第一个值并返回存储的上一个值。若要迭代处理映射的键值，可以使用 forEach 方法配合 lambda 表达式。<br>TreeMap保存了对象的排列次序。HashMap允许键和值为null。</p>
<p><strong>更新映射项</strong><br>获得键关联的原值，更新后再放回如：<code>counts.put(word, counts.get(word) + 1)</code> 。当 word 没有预先存在的话，get 将返回 null 而 put 的值不能为 null 。可以使用：</p>
<ul>
<li>counts.put(word, counts.getOrDefault(word, 0) + 1);</li>
<li>counts.putIfAbsent(word, 0); counts.put(word, counts.get(word) + 1);</li>
<li>counts.merge(word, 1, Integer::sum);</li>
</ul>
<p><strong>映射视图</strong></p>
<p>一共分为三种：</p>
<ul>
<li>键集 Set&lt;K&gt;  keySet()</li>
<li>值集合 Collection&lt;V&gt;  values()</li>
<li>键值对集 Set&lt;Map.Entry&lt;K,V&gt;&gt;  entrySet()</li>
</ul>
<p><strong>弱散列映射</strong></p>
<p>WeakHashMap 类，当对键的唯一引用来自散列条目，将删除键值对。使用弱引用保存键，将引用保存到散列键对象中，垃圾回收会用特有方式处理此类对象。</p>
<blockquote>
<p>  新建WeakHashMap，将“键值对”添加到WeakHashMap中。 实际上，WeakHashMap是通过数组table保存Entry(键值对)；每一个Entry实际上是一个单向链表，即Entry是键值对链表。</p>
<p>  当某“弱键”不再被其它对象引用，并被GC回收时。在GC回收该“弱键”时，这个“弱键”也同时会被添加到ReferenceQueue(queue)队列中。</p>
<p>  当下一次需要操作WeakHashMap时，会先同步table和queue。table中保存了全部的键值对，而queue中保存被GC回收的键值对；同步它们，就是删除table中被GC回收的键值对。</p>
</blockquote>
<p><strong>链接散列集和映射</strong></p>
<p>LinkedHashSet 和 LinkedHashMap 类会保留插入元素项的顺序。LinkedHashSet 是对 LinkedHashMap 的简单包装。LinkedHashMap 是 HashMap 的直接子类，二者唯一的区别是 LinkedHashMap 在 HashMap 的基础上，采用双向链表的形式将所有 entry 连接起来，保证元素的迭代顺序跟插入顺序相同。<br>会将 get 或 put 影响的条目移至链表尾部。</p>
<p><strong>枚举集与映射</strong><br>EnumSet 内部用位序列实现，对应值在集中则相应位被置 1。使用静态方法构造这个集：<code>enum Weekday { ... };</code>，使用 Set 接口的方法修改 EnumSet。<br>EnumMap 是以键类型为枚举类型的映射，需要在构造时指定：<code>EunmMap&lt;Weekday, Employee&gt; test = new EnumMap&lt;&gt;{Weekday.class}</code>。</p>
<p><strong>标识散列映射</strong><br>IdentityHsahMap 中键的散列值用 System.identityHashCode 方法计算，即根据内存地址计算。比较两对象时，IdentityHashMap 类使用 == 。<br>故不同的键对象即使内容相同，也视为不同对象。</p>
<h1 id="视图与包装器"><a href="#视图与包装器" class="headerlink" title="视图与包装器"></a>视图与包装器</h1><p>视图可以获得其他实现了 Collection 接口和 Map 接口的对象，如 keySet 方法并没有创建新集，而是返回了一个实现 Set 接口的类对象，其方法对原映射进行操作。</p>
<p><strong>轻量集合包装器</strong><br>Arrrays 类的静态方法 asList 返回一个包装了普通 Java 数组的 List 包装器而非 ArrayList 对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Card[] cardDeck = <span class="keyword">new</span> Card[<span class="number">52</span>];</span><br><span class="line">...</span><br><span class="line">List&lt;Card&gt; cardList = Arrays.asList(cardDeck);</span><br></pre></td></tr></table></figure>

<p>改变数组大小的方法将抛出异常。</p>
<p><strong>子范围视图</strong><br>如从列表 staff 中取出第 10-19 个元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List group = staff.subList(<span class="number">10</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<p>对于有序集和映射，可以使用排序顺序而非元素位置建立子范围。如 <code>SortedSet</code> <code>SortMap</code></p>
<p><strong>不可修改的视图</strong><br>Collection 中一些方法用于产生不可修改视图，运行时检查到修改则抛出一个异常。</p>
<p><strong>同步视图</strong><br>类库设计者使用视图确保集合的线程安全，而非实现线程安全的集合类。如将任何一个映射表转换成具有同步访问方法的 Map 视图：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,, Employee&gt; map = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;String, Employee&gt;());</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>队列</tag>
        <tag>散列</tag>
        <tag>映射</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 补丁-XML</title>
    <url>/2020/02/10/Java-%E8%A1%A5%E4%B8%81-XML/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>相对 HTML 的区别：</p><ul>
<li>大小写敏感，故 &lt;h1&gt; 和 &lt;H1&gt; 为不同 XML 标签</li>
<li>不可省略结束标签</li>
<li>没有结束标签的元素必须以 / 结尾</li>
<li>属性值必须用引号包围，包括数值</li>
<li>所有属性必须有属性值</li>
</ul><h2 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h2><p>字符引用：</p><ul>
<li><em>&amp;#十进制</em>  <em>&amp;#x十六进制</em></li>
</ul><p>实体引用：</p><ul>
<li><em>&amp;name</em></li>
<li>&amp;lt 小于；&amp;gt 大于；&amp;amp &amp;；&amp;quot 引号；可在 DTD 中定义其他实体引用。</li>
</ul><a id="more"></a>





<p>CDATA Section：</p>
<ul>
<li>*<!--[CDATA[* ... *]]-->*</li>
<li>特殊的字符数据形式，囊括含有 &lt; &gt; &amp; 等字符的字符串，而不必解释为标记。</li>
<li>&lt;![CDATA[ &amp; &gt; are delimiters ]]&gt;</li>
</ul>
<p>处理指令：</p>
<ul>
<li>*<?* ... *?>*</li>
<li>在处理 XML 的应用程序中使用。</li>
</ul>
<p>注释：</p>
<ul>
<li>*<!--* ... *-->*</li>
<li>注释不应该含有 – 字符串。</li>
</ul>
<h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><p>避免混合式内容，即元素包含子元素和文本。</p>
<p>属性只用于修改值的解释，而不是指定值。优先使用元素。例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span> <span class="attr">name</span>=<span class="string">"Helvetica"</span> <span class="attr">size</span>=<span class="string">"18 pt"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">font</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Helvetica<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">size</span> <span class="attr">unit</span>=<span class="string">"pt"</span>&gt;</span>36<span class="tag">&lt;/<span class="name">size</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="解析文档"><a href="#解析文档" class="headerlink" title="解析文档"></a>解析文档</h1><p>首先从 DocumentBuilderFactory 得到 DocumentBuilder 对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DocumentBuilderFactory = DocumentBuilderFactory.newInstance();</span><br><span class="line">DocumentBuilder builder = factory.newDocumentBuilder();</span><br></pre></td></tr></table></figure>

<p>通过 builder 从文件，URL，输入流读入文档：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File f = ...;</span><br><span class="line">URL u = ...;</span><br><span class="line">InputStream in = ...;</span><br><span class="line"></span><br><span class="line">Document doc = builder.parse(f);</span><br></pre></td></tr></table></figure>

<p>若使用输入流读取，解析器无法定位以该文档为相对路径而被引用的文档。</p>
<p>调用 <code>getDocumentElement</code> 方法对文档内容分析，并返回根元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Element root = doc.getDocumentElement();</span><br></pre></td></tr></table></figure>

<p><code>getTagName</code> 方法可以返回元素的标签名。获得元素的子元素（元素，文本，注释，节点）使用 <code>getChildNodes</code> 方法，将返回一个 NodeList 类型的集合。item 方法得到指定索引值的项，<code>getLength</code> 方法获得项的总数。故枚举子元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NodeList children = root.getChildNodes();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.getLength(); i++) &#123;</span><br><span class="line">    Node child = children.item(i);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>元素与元素之间的空白字符也算作子元素，忽略空白字符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.getLength(); i++) &#123;</span><br><span class="line">    Node child = children.item(i);</span><br><span class="line">    <span class="keyword">if</span> (child <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">        Element childElement = (Element) child;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获得元素后，从 Text 类型的子节点中获取文本字符串，若节点可定位（如 Text 节点是唯一的子元素），可使用 <code>getFirstChild</code>  <code>getLastChild</code> 而不必遍历新的 NodeList ，然后用 <code>getData</code> 方法获取节点中的字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.getLength(); i++) &#123;</span><br><span class="line">    Node child = children.item(i);</span><br><span class="line">    <span class="keyword">if</span> (child <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">        Element childElement = (Element) child;</span><br><span class="line">        Text textNode = (Text) childElement.getFirstChild();</span><br><span class="line">        String text = textNode.getData().trim();</span><br><span class="line">        <span class="comment">// trim 删除数据前后的空白字符</span></span><br><span class="line">        <span class="keyword">if</span> (childElement.getTagName().equals(<span class="string">"name"</span>))</span><br><span class="line">            name = text;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (childElement.getTagName().equals(<span class="string">"size"</span>))</span><br><span class="line">            size = Interger.parseInt(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若要遍历子节点集（不是 getChildNodes 来的 NodeList），结合 <code>getNextSibling</code> 方法（获取下一个兄弟节点）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Node childNode = element.getFirstChild();</span><br><span class="line">    childNode != <span class="keyword">null</span>;</span><br><span class="line">    childNode = childNode.getNextSibling()) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>若要枚举节点的属性，调用 <code>getAttributes</code> 方法，其返回一个 NamedNodeMap 对象，包含了描述属性的 Node 对象。与遍历 NodeList 的方式相同，用 <code>getNodeName</code>  <code>getNodeValue</code> 方法获取属性名和属性值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NamedNodeMap attributes = element.getAttributes();</span><br><span class="line">String value = element.getAttribute(<span class="string">"unit"</span>);</span><br><span class="line"><span class="comment">// 知道属性名可以直接获取对应值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; attributes.getLength(); i++) &#123;</span><br><span class="line">    Node attribute = attributes.item(i);</span><br><span class="line">    String name = attribute.getNodeName();</span><br><span class="line">    String value = attribute.getNodeValue;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="验证-XML-文档"><a href="#验证-XML-文档" class="headerlink" title="验证 XML 文档"></a>验证 XML 文档</h1><h2 id="DTD"><a href="#DTD" class="headerlink" title="DTD"></a>DTD</h2><p>若在 XML 文档内部提供 DTD，规则应当纳入到 DOCTYPE 声明的 [] 中，且 DOCTYPE 必须匹配根元素的名字，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE configuration [</span><br><span class="line">    &lt;!ELEMENT configuration ...&gt;</span><br><span class="line">    ... ]&gt;</span><br><span class="line">&lt;configuration&gt;&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p>更多是存储在外部，使用 SYSTEM 声明指定一个 DTD 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE configuration SYSTEM &quot;path&quot;&gt;</span><br><span class="line">&lt;!DOCTYPE configuration SYSTEM &quot;URL&quot;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="各种规则"><a href="#各种规则" class="headerlink" title="各种规则"></a>各种规则</h3><p><strong>ELEMENT 规则</strong>指定某个元素可以拥有的子元素，允许正则表达式。</p>
<table>
<thead>
<tr>
<th align="center">规则</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">E*</td>
<td align="center">0 或多个 E</td>
</tr>
<tr>
<td align="center">E+</td>
<td align="center">1 或多个 E</td>
</tr>
<tr>
<td align="center">E?</td>
<td align="center">0 或 1 个 E</td>
</tr>
<tr>
<td align="center">E1|E2|…|En</td>
<td align="center">E1,E2… 中的一个</td>
</tr>
<tr>
<td align="center">E1,E2,…,En</td>
<td align="center">E 按序排列</td>
</tr>
<tr>
<td align="center">#PCDATA</td>
<td align="center">文本</td>
</tr>
<tr>
<td align="center">(#PCDATA|E1…|En)*</td>
<td align="center">0 或多个文本且 E 以任意顺序排列</td>
</tr>
<tr>
<td align="center">ANY</td>
<td align="center">允许任何子元素</td>
</tr>
<tr>
<td align="center">EMPTY</td>
<td align="center">不允许有子元素</td>
</tr>
</tbody></table>
<p>当元素需要包含文本时，只有两种合法情况：</p>
<ul>
<li>只包含文本 #PCDATA</li>
<li>包含任意顺序的文本和标签 (#PCDATA|E1…|En)*</li>
</ul>
<p><strong>ATTLIST 规则</strong>指定元素属性，语法 <code>&lt;!ATTLIST element attribute type default&gt;</code></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CDATA</td>
<td align="center">任意字符串</td>
</tr>
<tr>
<td align="center">(A1|A2|…|An)</td>
<td align="center">字符串属性为其中之一</td>
</tr>
<tr>
<td align="center">NMTOKEN NMTOKENS</td>
<td align="center">1 或多个名字标记</td>
</tr>
<tr>
<td align="center">ID</td>
<td align="center">1 个唯一的 ID</td>
</tr>
<tr>
<td align="center">IDREF IDREFS</td>
<td align="center">1 或多个对唯一 ID 的引用</td>
</tr>
<tr>
<td align="center">ENTITY ENTITIES</td>
<td align="center">1 或多个未解析的实体</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">默认值</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">#REQUIRED</td>
<td align="center">属性必需</td>
</tr>
<tr>
<td align="center">#IMPLIED</td>
<td align="center">属性可选</td>
</tr>
<tr>
<td align="center">A</td>
<td align="center">属性可选，若未指定则为 A</td>
</tr>
<tr>
<td align="center">#FIXED A</td>
<td align="center">属性必须为未指定或 A，解析器都报 A</td>
</tr>
</tbody></table>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!ATTLIST font style (plain|bold|italic) &quot;plain&quot;&gt;</span><br><span class="line">&lt;!ATTLIST size unit CDATA #IMPLIED&gt;</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>通知工厂启用验证，此工厂生成的所有文档生成器都将根据 DTD 验证输入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">factory.setValidating(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>忽略元素节点之间的空白字符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">factory.setIgnoringElementContentWhitespace(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>这样就不用再通过循环剔除空白字符了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT font (name,size)&gt;</span><br><span class="line">&lt;!ELEMENT name (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT size (#PCDATA)&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Element name = (Element) children.item(<span class="number">0</span>);</span><br><span class="line">Element size = (Element) children.item(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h2 id="XML-Schema"><a href="#XML-Schema" class="headerlink" title="XML Schema"></a>XML Schema</h2><p>占坑</p>
<h1 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>相比遍历 DOM 树，XPath 访问节点更加简单，通过对 /configration/database/username 求值获取 username 的值。</p>
<p>也可以描述节点集，如 /gridbag/row 描述根元素 gridbag 下的所有子元素 row，通过 [] 操作符选择元素：/gridbag/row[1] 表示第一行。</p>
<p>@ 操作符获取属性值：/gridbag/row[1]/cell[1]/@anchor 。</p>
<p>配合 XPath 的函数进行精细要求。</p>
<h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>首先从 XPathFactory 创建 XPath 对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XPathFactory xpfactory = XPathFactory.newInstance();</span><br><span class="line">path = xpfactory.nextXPath();</span><br></pre></td></tr></table></figure>

<p>然后用 evaluate 方法计算 XPath 表达式（用于获取文本）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name = path.evaluate(<span class="string">"/configuration/database/username"</span>, doc);</span><br></pre></td></tr></table></figure>

<p>若 XPath 表达式产生了一组节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NodeList nodes = (NodeList) path.evaluate(<span class="string">"/gridbag/row"</span>, doc, XPathConstants.NODESET);</span><br></pre></td></tr></table></figure>

<p>若仅一个节点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Node node = (Node) path.evaluate(<span class="string">"/gridbag/row[1]"</span>, doc, XPathContants.NODE);</span><br></pre></td></tr></table></figure>

<p>若是数字：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = ((Number) path.evaluate(<span class="string">"count(/...)"</span>, doc, XPathConstants.NUMBER)).intValue();</span><br></pre></td></tr></table></figure>

<p>从以前获得的节点开始：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">result = path.evaluate(expression, node);</span><br></pre></td></tr></table></figure>

<h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>XML 使用 URL 标识命名空间，避免名字冲突。此处 URL 只用作标示字符串，而非某个文件定位符。</p>
<p>子元素也可以提供其命名空间：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">element</span> <span class="attr">xmlns</span>=<span class="string">"namespaceURL1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">chilren</span></span></span><br><span class="line">    &lt;children xmlns="namespaceURL2"&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">children</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">element</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>设置前缀表示命名空间（xsd 为例）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xsd:schema</span> <span class="attr">xmlns:xsd</span>=<span class="string">"URL"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsd:schema</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h2><p>默认 Java XML 库的 DOM 解析器关闭命名空间处理，使用 <code>DocumentBuilderFactory</code> 类的 <code>setNamespaceAware</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">factory.setNamespaceAware(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>该工厂产生的所有生成器都将支持命名空间：</p>
<ul>
<li><p>带前缀限定名 (例 xsd:schema) <code>getNodeName</code> <code>getTagName</code></p>
</li>
<li><p>命名空间 URI <code>getNamespaceURI</code></p>
</li>
<li><p>无命名空间或前缀的本地名 (例 schema)  <code>getLocalName</code></p>
</li>
</ul>
<h1 id="流机制解析器"><a href="#流机制解析器" class="headerlink" title="流机制解析器"></a>流机制解析器</h1><blockquote>
<p>DOM 解析器完整读入 XML 文档将其转换为树型的数据结构。若文档很大，或不需要看到完整结构，则相对低效。</p>
</blockquote>
<h2 id="SAX-解析器"><a href="#SAX-解析器" class="headerlink" title="SAX 解析器"></a>SAX 解析器</h2><p>DOM 解析器在 SAX 解析器的基础上构建，其在接收到解析器事件（SAX 解析输入数据时报告）时构建 DOM 树。而 SAX 由事件处理器建立数据结构，并且不在意元素的上下文环境。</p>
<p><code>ContentHandler</code> 接口定义了部分解析器会调用的方法，如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">font</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">size</span> <span class="attr">units</span>=<span class="string">"pt"</span>&gt;</span>36<span class="tag">&lt;/<span class="name">size</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>startElement - font</li>
<li>startElement - name</li>
<li>characters - xxx</li>
<li>endElement - name</li>
<li>……</li>
</ul>
<p>在处理器中覆盖这些方法以执行我们所希望的动作。</p>
<p>首先获得 SAX 解析器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SAXParserFactory factory = SAXParserFactory.newInstance();</span><br><span class="line"><span class="comment">// factory.setNamespaceAware(true); 打开命名空间处理</span></span><br><span class="line">SAXParser parser = factory.newSAXParser();</span><br></pre></td></tr></table></figure>

<p>然后获得处理器，覆盖 startElement 方法为例，namespaceURI 和 lname 提供命名空间和本地非限定名，qname 以 prefix:localname 提供限定名：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultHandler handler = <span class="keyword">new</span></span><br><span class="line">    DefaultHandler() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startElement</span><span class="params">(String namespaceURI, String lname, String qname, Attributes attrs)</span></span></span><br><span class="line"><span class="function">        throw SAXException </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后处理文档：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">parser.parse(文件/字符串/输入流, handler);</span><br></pre></td></tr></table></figure>

<h2 id="StAX-解析器"><a href="#StAX-解析器" class="headerlink" title="StAX 解析器"></a>StAX 解析器</h2><p>不用管事件处理部分，用循环迭代所有事件。命名空间处理默认启用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XMLInputFactory factory = XMLInputFactory.newInstance();</span><br><span class="line"><span class="comment">// factory.setProperty(XMLInputFactory.IS_NAMESPACE_AWARE, false);</span></span><br><span class="line">XMLStreamReader parser = factory.createXMLStreamReader(输入流);</span><br><span class="line"><span class="keyword">while</span> (parser.hasNext()) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>XMLStreamReader</code> 中的方法分析当前（parser.next）元素属性值，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String units = parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">"units"</span>);</span><br><span class="line"><span class="comment">// 获取当前元素 units 属性</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>XML</tag>
        <tag>DTD</tag>
        <tag>StAX</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 补丁-对象和类</title>
    <url>/2019/12/08/Java-%E8%A1%A5%E4%B8%81-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="预定义类部分"><a href="#预定义类部分" class="headerlink" title="预定义类部分"></a>预定义类部分</h1><p><strong>更改器和访问器</strong><br>更改器方法：调用方法后，会改变对象的状态。<br>访问器方法：只访问对象而不修改对象，通过生成新对象的方式应用改动。</p><h1 id="自定义类部分"><a href="#自定义类部分" class="headerlink" title="自定义类部分"></a>自定义类部分</h1><p><strong>封装</strong><br>注意是否返回了引用可变对象，即访问器方法返回了一个有更改器方法的对象；返回可变对象的引用时，应该先进行 clone。<br>Date 类有更改器方法 setTime，破坏了封装性：</p><a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Date hireDay;</span><br><span class="line">public Date getHireDay()&#123;</span><br><span class="line">	return hireDay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>final</strong><br>将实例域定义为 final，则构建对象时必须初始化这样的域（在构造器之后），并且之后不能再修改。大多应用于不可变类的域，对于可变的类只表示变量中的对象引用不会再指向其他对象，但当前这个对象可以修改。</p>
<ul>
<li>不可变类：类中的的每个方法都不会改变其对象，如 String 类。<br>System.out 被声明为 final，但 System 类有 setOut 方法：本地方法不是用 Java 语言实现，可以绕过 Java 的存取控制机制。</li>
</ul>
<h1 id="静态部份"><a href="#静态部份" class="headerlink" title="静态部份"></a>静态部份</h1><p><strong>静态方法</strong><br>不能对对象实施操作，不使用其对象，即没有 this 参数的方法。使用：</p>
<ul>
<li>一个方法不需要访问对象状态，所需参数都通过显式参数提供。</li>
<li>一个方法只需要访问类的静态域。</li>
</ul>
<h1 id="参数传递部分"><a href="#参数传递部分" class="headerlink" title="参数传递部分"></a>参数传递部分</h1><p>Java 总是采用按值调用。即方法得到的是参数值的一个拷贝。注意，Java 对对象采用的也是值调用，对象引用是按值传递的。</p>
<ul>
<li>一个方法不能修改一个基本数据类型的参数（数字型或布尔型）。</li>
<li>一个方法可以改变一个对象参数的状态。</li>
<li>一个方法不能让对象参数引用一个新的对象，因为方法结束后就被丢弃。</li>
</ul>
<h1 id="对象构造部分"><a href="#对象构造部分" class="headerlink" title="对象构造部分"></a>对象构造部分</h1><p><strong>重载</strong><br>方法的签名包含方法名和参数类型， 不包括返回类型和参数名。</p>
<p><strong>无参数构造器</strong><br>当类没有提供任何构造器时，系统会提供一个无参数构造器，数值型设置为 0，布尔型设置为 false，对象变量设置为 null。</p>
<p><strong>显式域初始化</strong><br>在类定义中直接将值赋给任何域，赋值操作会在 super(); 与构造器之间执行。可以调用方法进行初始化。</p>
<p><strong>构造器执行步骤</strong><br>未包含继承部分。</p>
<ol>
<li>所有数据域初始化为默认值。</li>
<li>按照在类声明中的出现次序，依次执行所有域初始化语句和初始化块。</li>
<li>如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。</li>
<li>执行此构造器。</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>对象构造</tag>
        <tag>静态</tag>
        <tag>封装</tag>
        <tag>call by</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 补丁-基本程序设计结构</title>
    <url>/2019/12/01/Java-%E8%A1%A5%E4%B8%81-%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="数据类型部分"><a href="#数据类型部分" class="headerlink" title="数据类型部分"></a>数据类型部分</h1><p><strong>整型</strong><br>Java7 开始：允许通过加前缀 0b 写二进制数；允许为数字字面量加下划线：</p><ul>
<li>1_000_000</li>
<li>0b1111_0000_0100</li>
</ul><p><strong>浮点型</strong><br>由于二进制系统无法精确表示分数 1/10，故浮点数值不适用金融计算，此时应使用 BigDecimal 类。</p><table>
<thead>
<tr>
<th align="center">常量</th>
<th align="center">数值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Double.POSITIVE_INFINITY</td>
<td align="center">正无穷</td>
</tr>
<tr>
<td align="center">Double.NEGATIVE_INFINITY</td>
<td align="center">负无穷</td>
</tr>
<tr>
<td align="center">Double.NaN</td>
<td align="center">非数字</td>
</tr>
</tbody></table><a id="more"></a>



<p>判断一个特定值是否为 Double.NaN ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(x == Double.NaN) <span class="comment">// never true</span></span><br><span class="line"><span class="keyword">if</span>(Double.isNaN(x)) <span class="comment">// √</span></span><br></pre></td></tr></table></figure>

<p><strong>char 类型</strong><br>char 数据类型是一个采用 UTF-16 编码表示 Unicode 码点的代码单元。<br>Unicode 转义序列会在解析代码前处理：</p>
<ul>
<li>“\u0022+\u0022” 会得到 “”+”” 即空串</li>
<li>// \u00A0 is a newline 会替换成换行符</li>
<li>// c:\users 会产生语法错误</li>
</ul>
<p><strong>枚举类型</strong><br>枚举类型的变量只能储存这个类型声明中给定的某个枚举值，或没有设置值 null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Size &#123; SAMLL, MEDIUM, LARGE &#125;;</span><br><span class="line">Size s = Size.SMALL;</span><br></pre></td></tr></table></figure>

<p>所有枚举类型都是 Enum 的子类，继承其方法。因为实际上是一个类，故比较时直接用 == 就好，也可以在枚举类型中添加构造器方法域。</p>
<p><strong>相关：大数值</strong><br>java.math 包的 BigInteger 和 BigDecimal 类可以处理任意长度数字序列的数值，分别对应整数和浮点数运算。</p>
<hr>
<h1 id="运算符部分"><a href="#运算符部分" class="headerlink" title="运算符部分"></a>运算符部分</h1><p><strong>数学函数</strong><br>StrictMath 类使用 fdlibm 库实现算法，确保在所有平台上得到相同结果。</p>
<p><strong>数值类型转换</strong><br>二元操作中的类型转换，以 double float long 的顺序进行判断，若都不是则两个操作数都转换成 int 型。<br>强制类型转换通过截断小数部分将浮点值转换为整型，若要得到最接近整型的数，使用 Math.round 对浮点数进行舍入：</p>
<ul>
<li><code>int newx = (int) Math.round(x);</code> // 返回的是 long 类型</li>
</ul>
<p>强制转换中若超出目标类型的表示范围，结果会截断成完全不同的值。<br>不要在 boolean 与任何数值类型间强制类型转换，转换为数值时可以使用条件表达式 boolean ? 1:0</p>
<p><strong>自增自减和运算符级别</strong><br>自增自减中，用于表达式时前缀形式会先完成加减一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> m = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">2</span> * ++m; <span class="comment">// a is 16, m is 8</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span> * n++; <span class="comment">// b is 14, n is 8</span></span><br></pre></td></tr></table></figure>

<p>+= 是右结合运算符，所以 <code>a += b += c</code> 等价于 <code>a += (b += c)</code></p>
<p><strong>位运算符</strong></p>
<table>
<thead>
<tr>
<th align="center">位运算符</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;</td>
<td align="center">and</td>
</tr>
<tr>
<td align="center">&#124;</td>
<td align="center">or</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">xor</td>
</tr>
<tr>
<td align="center">~</td>
<td align="center">not</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> fourthBit = (n &amp; <span class="number">0b1000</span>) / <span class="number">0b1000</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="字符串部分"><a href="#字符串部分" class="headerlink" title="字符串部分"></a>字符串部分</h1><p><strong>String API</strong><br>提取子串： substring 方法。<br>多个字符串放在一起用一个定界符分隔： String.join 方法。</p>
<p><strong>不可变字符串</strong><br>String 类没有修改字符串的方法，可以先提取再拼接；编译器可以让字符串共享，即复制一个字符串变量，原始字符串与复制的字符串共享相同的字符。<br>但不要使用 == （此运算符确定是否在同一位置上）检测两个字符串是否相等，虚拟机实际上只有字符串常量是共享的，而 + 或 substring 等操作产生的结果并不共享。使用 equals equalsIgnoreCase 方法。</p>
<p><strong>构建字符串</strong><br>用许多小段字符串构建时，字符串连接的方式效率较低，每次连接字符串都会构建一个新的 String 对象，应该 new 个空的字符串构造器：StringBuilder 类，相对 StringBuffer 类效率更高，但后者允许多线程方式执行操作。</p>
<p><strong>Null 串</strong><br>null 上调用方法会出现错误，故检查字符串 null 和空 <code>if (str != null &amp;&amp; str.length() != 0)</code> ，空用 equals 也行。</p>
<p><strong>码点和代码单元</strong><br>length 方法返回采用 UTF-16 编码表示的给定字符串所需要的代码单元数量（配合 char 数据类型食用）。大多数常用字符使用一个代码单元表示，辅助字符需要一对代码单元表示。故实际长度应该是码点数量：使用 codePointCount 方法获取。<br>如字符 𝕆 U+1D546 需要两个代码单元，若使用 <code>char ch = sentence.charAt(1)</code> 会返回第二个代码单元而非空格，所以此类不要用 char 类型。charAt 方法返回位置 n 的代码单元。</p>
<blockquote>
<p>一个 code point 可能由一个或多个 code unit(s) 表示。在 U+10000 之前的 code point 可以由一个 UTF-16 code unit 表示，U+10000 及之后的 code point 要由两个 UTF-16 code units 表示。</p>
</blockquote>
<hr>
<h1 id="输入输出部分"><a href="#输入输出部分" class="headerlink" title="输入输出部分"></a>输入输出部分</h1><p><strong>格式化输出</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.printf(<span class="string">"%,.2f"</span>, <span class="number">10000.0</span> / <span class="number">3.0</span>);</span><br><span class="line"><span class="comment">// 3,333.33</span></span><br></pre></td></tr></table></figure>

<p>用于 printf 的转换符：</p>
<table>
<thead>
<tr>
<th align="center">转换符</th>
<th align="center">类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">d</td>
<td align="center">十进制整数</td>
</tr>
<tr>
<td align="center">x</td>
<td align="center">十六进制整数</td>
</tr>
<tr>
<td align="center">o</td>
<td align="center">八进制整数</td>
</tr>
<tr>
<td align="center">f</td>
<td align="center">定点浮点数</td>
</tr>
<tr>
<td align="center">e</td>
<td align="center">指数浮点值</td>
</tr>
<tr>
<td align="center">g</td>
<td align="center">通用浮点数</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">十六进制浮点数</td>
</tr>
<tr>
<td align="center">s</td>
<td align="center">字符串</td>
</tr>
<tr>
<td align="center">c</td>
<td align="center">字符</td>
</tr>
<tr>
<td align="center">b</td>
<td align="center">布尔</td>
</tr>
<tr>
<td align="center">h</td>
<td align="center">散列码</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">百分号</td>
</tr>
<tr>
<td align="center">n</td>
<td align="center">平台有关的行分隔符</td>
</tr>
</tbody></table>
<p>用于 printf 的标志：</p>
<table>
<thead>
<tr>
<th align="center">标志</th>
<th align="center">目的</th>
<th align="center">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">打印正负数符号</td>
<td align="center">+333</td>
</tr>
<tr>
<td align="center">空格</td>
<td align="center">在正数前加空格</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">数字前面补 0</td>
<td align="center">00333.3</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">左对齐</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">(</td>
<td align="center">将负数括在括号内</td>
<td align="center">(3.3)</td>
</tr>
<tr>
<td align="center">,</td>
<td align="center">添加分组分隔符</td>
<td align="center">3,333</td>
</tr>
<tr>
<td align="center">#（f）</td>
<td align="center">包含小数点</td>
<td align="center">333.</td>
</tr>
<tr>
<td align="center">#</td>
<td align="center">添加前缀 0x 或 0</td>
<td align="center">0xcafe</td>
</tr>
</tbody></table>
<p><strong>文件输入和输出</strong><br>通过相对位置指定文件时，是 Java 虚拟机启动路径的相对位置。<br>记得捕获输入输出异常，以免文件不存在或不能被创建。</p>
<p>读取通过构造 Scanner 对象，路径中要转义反斜杠；写入则构造 PrintWriter 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(Paths.get(<span class="string">"c:\\my\\file"</span>), <span class="string">"UTF-8"</span>);</span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(<span class="string">"c:\\my\\file"</span>); <span class="comment">// 允许但会变成字符数据</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="控制流程部分"><a href="#控制流程部分" class="headerlink" title="控制流程部分"></a>控制流程部分</h1><p><strong>switch 语句</strong><br>Java7 开始，case 标签可以是字符串字面量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String input = ...;</span><br><span class="line"><span class="keyword">switch</span> (input.toLowerCase())&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"yes"</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>中断语句</strong><br>带标签 break 语句用于跳出多重循环。标签放在最外层循环之前，并紧跟冒号，break 将跳转到带标签的语句块结尾。只能跳出，不能跳入。<br>带标签 break 甚至可以用于 if 语句或语句块中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">label:</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) <span class="keyword">break</span> label;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>continue 语句将控制转移到最内层循环的首部，带标签 continue 语句将跳到与标签匹配的循环首部。</p>
<hr>
<h1 id="数组部分"><a href="#数组部分" class="headerlink" title="数组部分"></a>数组部分</h1><p>数字数组初始化为 0，boolean 数组初始化为 false，对象数组则为 null。数组创建后不能改变大小，需要扩展应选择数组列表 array list。<br>Java 允许数组长度为 0，与 null 不同。</p>
<p><strong>for each 循环</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (variable : collection) statement &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>collection 可以是数组或实现了 Iterable 接口的类对象。<br>打印数组所有值可以用 Arrays.toString 方法，元素被放在 [] 内，用逗号分隔。</p>
<p><strong>初始化和匿名</strong><br>不创建变量初始化一个数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">// 即下列语句简写</span></span><br><span class="line"><span class="keyword">int</span>[] temp = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">arr = temp;</span><br></pre></td></tr></table></figure>

<p><strong>拷贝</strong><br>将一个数组变量拷贝给另一个数组变量后，两个变量引用的是同一个数组，即更改在两者生效。若要拷贝到新数组，使用 Arrays.copyOf 方法，这个方法也用于增加数组大小：<code>arr = Arrays.copyOf(arr, 2 * arr.length)</code> 。</p>
<p><strong>命令行参数</strong><br>main 的 String[] args 用于存储命令行参数，不包含程序名。</p>
<p><strong>不规则数组</strong><br>Java 实际上只有一维数组，多维数组定义为“数组的数组”。所以可以让两行交换，或是每一行有不同的长度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] odds = <span class="keyword">new</span> <span class="keyword">int</span>[NMAX +<span class="number">1</span>][];</span><br><span class="line"><span class="comment">//new 一个具有行数的数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt;= NMAX; n++)</span><br><span class="line">    odds[n] = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//然后为每行添加元素</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
        <tag>控制流程</tag>
        <tag>数组</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 补丁-并发</title>
    <url>/2020/01/18/Java-%E8%A1%A5%E4%B8%81-%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<p>并发得专门开个分类 x</p><p>到时候把这篇删掉 x</p><h1 id="零碎"><a href="#零碎" class="headerlink" title="零碎"></a>零碎</h1><p>所有实例域、静态域和数组元素都储存在堆内存中，堆内存在线程之前共享。<br>JMM 定义了：线程之间的共享变量储存在主内存中，每个线程都有一个私有的本地内存，本地内存储存了该线程已读写共享变量的副本。</p><ul>
<li>线程 A 把本地内存 A 中的共享变量副本刷新到主内存中。</li>
<li>线程 B 去读取主内存中线程 A 刷新过的共享变量。</li>
<li>从整体来看，这两个步骤实质上是线程A向线程B发送消息，而通信必须经过主内存。JMM 通过控制主内存与每个线程的本地内存之间的交互，来提供内存可见性的保证。</li>
</ul><a id="more"></a>



<h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><p><strong>新创建线程 New</strong></p>
<p>如 <code>new Thread(r)</code> ，该线程还没有开始运行。</p>
<p><strong>可运行线程 Runnable</strong></p>
<p>调用 start 方法便处于 runnable 状态，可能正在运行也可能没有运行。</p>
<p><strong>被阻塞线程和等待线程 Blocked Waiting</strong></p>
<p>线程处于被阻塞或等待状态时，会暂时不活动，直到被线程调度器重新激活。</p>
<p>当一个线程试图获取一个内部的对象锁，而该锁被其他进程持有则进入阻塞状态。直到所有其他线程释放该锁且被线程调度器允许持有。</p>
<p><strong>被终止线程 Terminated</strong></p>
<p>因为 run 方法正常退出而自然死亡。或一个没有捕获的异常终止了 run 方法而意外死亡。（过时方法 stop 通过抛出 ThreadDeath 错误对象杀死线程）</p>
<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>线程随着 thread.start() 开始启动 到 run() 方法执行完毕 结束。通过 Thread.interrupted() 方法中断线程。<br>中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行了中断操作。<br>线程通过检查自身是否被中断来进行响应，线程通过方法 isInterrupted() 来进行判断是否被中断，也可以调用静态方法 Thread.interrupted() 对当前线程的中断标识位进行复位。如果该线程已经处于终结状态，即使该线程被中断过，在调用该线程对象的 isInterrupted() 时依旧会返回 false。<br>许多声明抛出 InterruptedException 的方法（例如 Thread.sleep(long millis) 方法）这些方法在抛出 InterruptedException 之前，Java 虚拟机会先将该线程的中断标识位清除，然后抛出 InterruptedException，此时调用isInterrupted() 方法将会返回 false。<br>在线程 sleep 的时候，调用 isInterrupted() 会导致 sleep interrupted 异常，并且中断标记也被清除了。</p>
<h1 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h1><p><strong>线程优先级</strong></p>
<p>默认继承父线程的优先级。使用 setPriority 方法修改为 1 <code>MIN_PRIORITY</code> 到 10 <code>MAX_PRIORITY</code> 之间的任何值。</p>
<p>线程优先级高度依赖于系统，即会映射到宿主机平台的优先级上。</p>
<p><strong>守护线程</strong></p>
<p>在线程启动前 <code>t.setDaemon(true)</code> 将线程转换为守护线程，为其他线程提供服务，如计时。当只剩下守护线程时虚拟机就退出了。守护线程不应该访问固有资源如文件，数据库，要考虑 shutdown 动作。</p>
<p><strong>未捕获异常处理器</strong></p>
<p>线程的 run 方法不能抛出任何受查异常，但非受查异常会导致线程终止。实际不需要 catch 子句来处理，在线程死亡之前异常被传播到一个用于未捕获异常的处理器。</p>
<p>该处理器必须属于一个实现 Thread.UncaughtExceptionHandler 接口的类，只有一个 <code>void uncaughtException(Thread t, Throwable e)</code> 。用 <code>setUncaughtExceptionHandler</code> 为任何线程安装一个处理器，或者用 <code>Thread.setDefaultUncaughtExceptionHandler</code>为所有线程安装默认的处理器。</p>
<p>若不安装处理器则使用该线程的 ThreadGroup 对象，其 uncaughtException 方法如下：</p>
<ol>
<li>if 有父线程组，调用父线程组的 uncaughtException 方法</li>
<li>else 若 <code>Thread.setDefaultUncaughtExceptionHandler</code> 返回非空的处理器（即有默认的处理器），则使用</li>
<li>else 若 Throwable 是 ThreadDeath 的一个实例，则什么也不做</li>
<li>else 线程名及 Throwable 的栈轨迹被输出到 System.err </li>
</ol>
<h1 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h1><p><strong>ReentrantLock</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Lock myLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// implements the Lock interface</span></span><br><span class="line">myLock.lock(); <span class="comment">// a ReentrantLock object</span></span><br><span class="line"><span class="keyword">try</span>&#123; critical section &#125;</span><br><span class="line"><span class="keyword">finally</span> &#123; myLock.unLock(); &#125;</span><br></pre></td></tr></table></figure>

<p>确保任何时刻只有一个线程进入临界区。一旦线程封锁了锁对象，任何线程都无法通过 lock 语句，将被阻塞至锁对象释放。</p>
<p>不要将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放。为确保临界区代码抛出异常后会将锁释放，必须将解锁置于 finally 子句。 </p>
<p>可重入：锁保持一个持有计数跟踪对 lock 方法的嵌套调用。被锁保护的代码可以调用另一个使用相同的锁的方法。</p>
<ul>
<li>transfer 方法中调用 getTotal 方法，此时 Lock 对象持有计数 2，当 getToal 方法退出时，计数变为 1；当 transfer 方法退出计数变为 0，线程释放锁。</li>
</ul>
<p><code>ReentrantLock(boolean fair)</code> 是一个公平锁，偏向等待时间最长的线程。会极大降低性能。</p>
<p>Lock 接口提供的 synchronized 关键字所不具备的主要特性：</p>
<ul>
<li>尝试非阻塞性获取锁：当前线程尝试获取锁，如果此时没有其他线程占用此锁，则成功获取到锁。</li>
<li>能被中断的获取锁： 当获取到锁的线程被中断时，中断异常会抛出并且会释放锁。</li>
<li>超时获取锁： 在指定时间内获取锁，如果超过时间还没获取，则返回。</li>
</ul>
<p>Lock api<br>void lockInterruptibly() throws InterruptedException ：可中断的获取锁<br>boolean tryLock() ：尝试非阻塞的获取锁<br>boolean tryLock(long time, TimeUnit unit) throws InterruptedException ： 超时获取锁。 超时时间结束，未获得锁，返回 false。</p>
<p><strong>条件对象</strong></p>
<p>用于管理已经获得一个锁但在满足某一条件后才执行的线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>await 与 waiting 不同在于进入的是对应条件的等待集，当锁可用时仍处于阻塞状态，直到另一个线程调用同一条件上的 signalAll 方法。</p>
<p>signalAll 激活由对应条件而等待的所有线程（或者说接触线程的阻塞，通过竞争实现访问），线程应该再次测试该条件以确保被满足。</p>
<p><strong>synchronized</strong><br>使用 synchronized 关键字声明方法，对象的内部锁将保护整个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.intrinsicLock.lock();</span><br><span class="line">		<span class="keyword">try</span> &#123; ... &#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">this</span>.intrinsicLock.unnlock();</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部对象锁只有一个条件，wait 方法添加线程到等待集中（<code>void wait(long millis)</code> <code>void wait(long millis, int nanos)</code>）， notifyAll/notify 方法解除等待线程的阻塞状态。</p>
<p>对于普通同步方法，锁是当前实例对象。<br>对于静态同步方法，锁是当前类的Class对象。<br>对于同步方法块，锁是 Synchonized 括号里配置的对象。</p>
<p>等待方原则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (对象) &#123;</span><br><span class="line">    <span class="keyword">while</span> (条件不满足) &#123;</span><br><span class="line">        对象.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    对应的处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通知方原则：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (对象) &#123;</span><br><span class="line">    改变条件</span><br><span class="line">    对象.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>同步阻塞</strong><br>就是同步方法块。</p>
<p><strong>volatile</strong><br>为实力的同步访问提供免锁方案。不提供原子性。</p>
<blockquote>
<p>如果向一个变量写入值，而将会被另一个线程读取。或者从一个变量读取值，而之前可能被另一个线程写入，必须使用同步。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> bo = <span class="keyword">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flipBoolean</span><span class="params">()</span> </span>&#123; bo = !bo; &#125;</span><br><span class="line"><span class="comment">// 不保证读取，写入 ，反转不被中断</span></span><br></pre></td></tr></table></figure>

<p><strong>final</strong><br>将一个域声明为 final 时，其他线程在其完成构造后才能看到对应变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Map&lt;String, Double&gt; acounts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 其他线程不会获得 acounts = null</span></span><br><span class="line"><span class="comment">// 本身并不线程安全，读写仍需同步</span></span><br></pre></td></tr></table></figure>

<p><strong>Thread.join()</strong><br>主线程生成并起动了子线程，如果子线程里要进行大量的耗时的运算，主线程往往将于子线程之前结束，但是如果主线程处理完其他的事务后，需要用到子线程的处理结果，即主线程需要等待子线程执行完成之后再结束。<br>join()的作用是：主线程等待该子线程的终止。即在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。</p>
<p><strong>ThreadLocal</strong><br>线程局部变量，以 ThreadLocal 对象为键 、任意对象为值的存储结构。<br>这个结构被附带在线程上，所以一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。set(T t) 设置，get() 获取。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>同步</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 补丁-异常、断言和日志</title>
    <url>/2019/12/23/Java-%E8%A1%A5%E4%B8%81-%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h1 id="异常部分"><a href="#异常部分" class="headerlink" title="异常部分"></a>异常部分</h1><p><strong>概念</strong><br>非受查 unchecked 异常：派生于 Error 类或 RuntimeException 类的所有异常，其它的异常称为受查 checked 异常。</p><p><strong>创建异常类</strong><br>派生于 Exception 或其子类。应该包含两个构造器：默认构造器和带描述信息的构造器（超类 Throwable 的 toString 方法会打印出详细信息）。</p><a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class FileFormatException extends IOException &#123;</span><br><span class="line">public FileFormatException() &#123;&#125;</span><br><span class="line">public FileFormatException(String gripe) &#123; super(gripe) &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>finally 子句</strong><br>建议解耦合 try/catch 和 try/finally 语句块，以提高清晰度（且会报告 finaly 子句的错误）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	finally &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">catch (Exception e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>finally 子句中的 return 语句将会覆盖 try 中 return 的值。</p>
<p><strong>带资源的 try 语句</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try (Resource res = ...; ...) &#123;</span><br><span class="line">	work with res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以指定多个资源，try 块正常退出或存在异常时会自动调用 res.close()。catch 子句和 finally 子句将会在关闭资源后执行。</p>
<p><strong>堆栈轨迹元素</strong><br>堆栈轨迹 stack trace：方法调用过程的列表。</p>
<h1 id="断言部分"><a href="#断言部分" class="headerlink" title="断言部分"></a>断言部分</h1><p><strong>概念</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assert 条件 ;</span><br><span class="line">assert 条件 : 表达式 ;</span><br><span class="line"></span><br><span class="line">assert x&gt;=0 : x;</span><br></pre></td></tr></table></figure>

<p>assert 关键词，测试期间向代码插入一些检查语句，发布时会自动移走。<br>对条件进行检测，如果结果是 false 则抛出 AssertionError 异常。第二种还会将表达式传到 AssertionError 转换成消息字符串输出。</p>
<p><strong>启用和禁用</strong><br>运行程序时用 -ea -da 选项，可以指定某个类或某个包。没有类加载器的系统类需要用 -esa 启用。例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -ea:MyClass -ea:com.mycom... -da:YmClass MyApp</span><br></pre></td></tr></table></figure>

<p>程序中使用 <code>setDefaultAssertionSatus (boolean b)</code> 等完成。</p>
<h1 id="日志部分"><a href="#日志部分" class="headerlink" title="日志部分"></a>日志部分</h1><p><strong>基本日志</strong><br>即全局日志记录器的 info 方法：<code>Logger.getGlobal().info(&quot; ... &quot;)</code> 。</p>
<p><strong>高级日志</strong><br>即自定义日志记录器，调用 getLogger 方法创建或获取，具有类似包名的层次结构，因为未被任何变量引用的日志记录器可能会被垃圾回收，要用一个静态变量存储引用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static final Logger myLogger = Logger.getLogger(&apos;&apos;com.mycom...&apos;&apos;);</span><br></pre></td></tr></table></figure>

<p>日志记录器的父子间共享某些属性如日志级别：</p>
<ul>
<li>SEVERE</li>
<li>WARNING</li>
<li>INFO</li>
<li>CONFIG</li>
<li>FINE</li>
<li>FINER</li>
<li>FINEST</li>
</ul>
<p>默认只记录前三个级别，通过 <code>logger.setLevel(Level.FINE);</code> 设置其他级别。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>异常</tag>
        <tag>断言</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 补丁-接口、lambda 和内部类</title>
    <url>/2019/12/23/Java-%E8%A1%A5%E4%B8%81-%E6%8E%A5%E5%8F%A3%E3%80%81lambda-%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="接口部分"><a href="#接口部分" class="headerlink" title="接口部分"></a>接口部分</h1><p><strong>特性</strong><br>可以使用 instanceof 检查一个对象是否实现某个接口：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (anObject instanceof Comparable) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>接口中不能包含实例域或静态方法（ Java 8 支持静态方法），允许常量。接口中的方法默认为 public，域默认为 public static final。</p><a id="more"></a>



<p> <strong>default 默认方法</strong><br>与超类冲突：超类的方法和接口的默认方法冲突时，超类优先。<br>与接口冲突：只要有一个接口有默认方法，就需要提供一个实现覆盖掉。若接口们都没有提供默认方法，则不存在冲突 - 全部实现或不实现（使自身抽象）。</p>
<blockquote>
<p>所以不要用接口的默认方法重新定义 Object 类中的方法如 equals 等，因为超类优先规则默认方法会永远被忽略。</p>
</blockquote>
<p><strong>clone 方法</strong><br>copy 一个新对象而不是引用。clone 方法是 Objects 的一个 protected 方法，子类只能克隆它自己的对象，会产生问题：若拷贝的是相同子对象的引用，原对象和克隆对象仍会共享一些信息。默认的拷贝是浅拷贝，若共享的子对象不可变（如 String 类），在生命周期里没有更改器改变它，也没有方法生成它的引用，则是安全的。</p>
<p>若默认 clone 方法满足需求，需要实现 Cloneable 接口（标记接口），调用 <code>super.clone()</code>；若要在可变的子对象上调用 clone 进行修补，则还重新定义一个 public 的 clone 方法。</p>
<h1 id="lambda-表达式部分"><a href="#lambda-表达式部分" class="headerlink" title="lambda 表达式部分 *"></a>lambda 表达式部分 *</h1><p><strong>规范</strong><br>一个可传递的代码块，以及其变量规范。即使 lambda 表达式没有参数仍然要提供空括号：<code>() -&gt; { ... }</code> ；如果可以推导出参数类型则可以忽略其类型：<code>Comparator&lt;S
tring&gt; comp = (first, second) -&gt; ... ;</code> ；如果方法只有一个参数，且可以推导出类型，可以省略小括号：<code>ActionListener listener = event -&gt; ... ;</code> 。<br>lambda 表达式的返回类型会由上下文推导得出；只在某些分支返回一个值是不合法的。</p>
<p><strong>函数式接口</strong><br>对于只有一个抽象方法的接口，需要其对象时，可以提供一个 lambda 表达式。Java 中对 lambda 表达式所能做的只是转换为函数式接口。</p>
<p><strong>引用方法</strong><br>使用现有方法代替要传递的内容，用 :: 分隔方法名和对象名，允许使用 this 和 super。</p>
<ul>
<li>object::instanceMethod</li>
<li>Class::staticMethod</li>
<li>Class::instanceMethod</li>
</ul>
<p>前两种情况中方法引用等价于提供方法参数的 lambda 表达式，如 <code>System.out::println</code> 等价于 <code>x -&gt; System.out.println(x)</code> 。第三种情况第一个参数会成为方法的目标，如 <code>String::compareToIgnoreCase</code> 等价于 <code>(x,y) -&gt; x.compareToIgnoreCase(y)</code> 。</p>
<p><strong>构造器引用</strong><br>构造器引用类似于方法引用，不过方法名为 new。编译器通过上下文选择构造器。<br>可以用数组类型建立构造器引用，如 <code>int[]::new</code> 有一个数组长度参数，等价于 <code>x -&gt; new int[x]</code>。但无法构造泛型类型 T 的数组，通过 Stream 接口的 toArray 方法调用构造器获得某类型的数组。</p>
<p><strong>变量作用域</strong><br>lambda 表达式可以捕获外围方法或类中变量的值，即可以存储自由变量（非参数且不在表达式中定义）的值。<br>不能改变引用值，或在外部改变引用变量。即捕获的变量必须实际上是最终变量，初始化后就不会再为它赋新值。<br>this 关键字是指创建这个 lambda 表达式的方法的 this 参数。</p>
<h1 id="内部类部分"><a href="#内部类部分" class="headerlink" title="内部类部分"></a>内部类部分</h1><p><strong>规则</strong><br>内部类的对象总有一个隐式引用（OuterClass.this）指向外部类对象，故可以访问创建它的外围类对象的实例域。<br>每个外部对象会分别有一个内部类实例，故内部类的静态域要加 final 确保唯一。而其方法不允许 static，可能因为弊大于利。</p>
<p><strong>局部内部类</strong><br>定义在方法中，不能用 public 和 private 声明。对外部世界完全隐藏，外部类也不能访问它。</p>
<p><strong>匿名内部类</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new SuperType(construction parameters)</span><br><span class="line">	&#123;</span><br><span class="line">		inner class methods and data</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>若构造一个数组列表并将其传递到方法后就不再需要，可以作为匿名列表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">invite(new ArrayList&lt;String&gt;() &#123;&#123; add(&quot;A&quot;; add(&quot;B&quot;); )&#125;&#125;);</span><br></pre></td></tr></table></figure>

<p>外层括号建立了 ArrayList 的一个匿名子类，内层括号为子类添加元素。</p>
<p>调用 getClass() 是实际是 this.getClass() 而静态方法没有 this，所以应该：<code>new Object(){}.getClass().getEnclosingClass()</code> 。<code>new Object(){}</code> 会建立 Object 的一个匿名子类的匿名对象，<code>getEnclosingClass()</code> 则得到其外围类即包含对应静态方法的类。</p>
<p><strong>静态内部类</strong><br>当使用内部类只是为了隐藏在另一个类内部，不引用外围类对象，可以声明成 static 以便取消产生的引用。（有时内部类对象在静态方法中构造）<br>可以有静态域和方法。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>接口</tag>
        <tag>内部类</tag>
        <tag>lambda</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 补丁-泛型程序设计</title>
    <url>/2019/12/24/Java-%E8%A1%A5%E4%B8%81-%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p><strong>类型变量限定</strong><br>对类型变量 T 设置限定 <code>&lt;T extends BoundingType&gt;</code>。T 的绑定类型可以是类也可以是接口，只是 extends 关键词更接近子类概念，并非表达继承的意思。<br>一个类型变量或通配符可以有多个限定，限定类型用 &amp; 分隔，类型变量用逗号分隔。但限定中至多有一个类，并是限定列表的第一个。</p><a id="more"></a>
<p><strong>继承规则</strong><br>Pair<manager> 不是 Pair<employee> 的子类，继承不延续进泛型类。<br>泛型类可以扩展或实现其他的泛型类。</employee></manager></p>
<h1 id="虚拟机部分"><a href="#虚拟机部分" class="headerlink" title="虚拟机部分"></a>虚拟机部分</h1><p><strong>类型擦除</strong><br>虚拟机没有泛型类型对象，无论何时定义泛型类型都会自动提供相应的原始类型，即擦除类型变量并替换成限定类型（用第一个限定的类型变量替换，无限定的用 Object）。</p>
<p><strong>翻译泛型表达式</strong><br>程序调用泛型方法时，擦除返回类型插入强制类型转换。存取泛型域时也会插入强制类型转换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pair&lt;Employee&gt; buddies = ... ;</span><br><span class="line">Employeee buddy = buddies.gettFirst();</span><br></pre></td></tr></table></figure>

<p>编译器将方法调用翻译成两条虚拟机指令：</p>
<ul>
<li>对原始方法 Pair.getFirst 的调用。</li>
<li>将返回的 Object 类型强制转换为 Employee 类型。</li>
</ul>
<p><strong>翻译泛型方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Father&lt;T&gt; &#123;</span><br><span class="line">	public void fun(T x) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Son extends Father&lt;String&gt; &#123;</span><br><span class="line">	public void fun(String x) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Father 类和 Son 类经过类型擦除后变成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Father&lt;Object&gt; &#123;</span><br><span class="line">	public void fun(Object x) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class Son extends Father &#123;</span><br><span class="line">	public void fun(String x) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很显然，子类 Son 是想覆盖 Father 的 fun 方法，但是却出现了问题。<br>当出现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Father&lt;String&gt; f = new Son();</span><br><span class="line">f.fun(x);</span><br></pre></td></tr></table></figure>

<p>变量 f 声明为类型 Father<string> 而此类型的方法是 fun(Object)，虚拟机用 f 引用的对象调用此方法，即 Son 的 fun(Object)，这个方法是虚拟机合成的桥方法，会调用 Son 的 fun(String) 方法。<br>总之就是保证了不会调用之前被覆盖的超类方法。</string></p>
<p>对于 get 方法等无参数的，子类会出现两个方法名相同，都无参数的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String get() &#123;&#125;</span><br><span class="line">Object get() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在编写中是不合法的，但虚拟机用参数类型和_返回类型_确定一个方法，故能正确处理。</p>
<h1 id="约束与局限部分"><a href="#约束与局限部分" class="headerlink" title="约束与局限部分"></a>约束与局限部分</h1><p><strong>不能用基本类型实例化类型参数</strong><br>没有诸如 <double> 而应该是 <double>，因为类型擦除后 Object 无法存储基本类型。</double></double></p>
<p><strong>类型查询的是原始类型</strong><br>虚拟机中的对象总是一个非泛型类型，比如 <code>if (a instanceof Pair&lt;String&gt;)</code> 仅仅测试 a 是否是任意类型的 Pair。getClass 方法总是返回原始类型，强制类型转换将 warning。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pair&lt;String&gt; stringPair = ... ;</span><br><span class="line">Pair&lt;Employee&gt; employeePair = ... ;</span><br><span class="line">if (stringPair.getClass() == employeePair.getClass()) // true</span><br></pre></td></tr></table></figure>

<p><strong>不能创建泛型数组</strong> 1.8 中存疑<br>类型擦除后使检查元素类型的机制无效，所以不允许创建泛型数组。声明泛型数组是合法的，但不能通过创建泛型数组来对其初始化。使用类似 ArrayList:ArrayList&lt;Pair<string>&gt;。</string></p>
<p><strong>Varargs 警告</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static &lt;T&gt; void addAll(Collection&lt;T&gt; coll, T... ts) &#123;</span><br><span class="line">	for (t : ts) coll.add(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Collection&lt;Pair&lt;String&gt;&gt; table = ... ;</span><br><span class="line">Pair&lt;String&gt; Pair1 = ... ;</span><br><span class="line">Pair&lt;String&gt; Pair2 = ... ;</span><br><span class="line">addAll (table, pair1, pair2);</span><br></pre></td></tr></table></figure>

<p>虚拟机不得不建立 Pair<string> 数组，违反了上一条。但这种情况规则有所放松只会得到警告，用 @SafeVarargs 标注来抑制。</string></p>
<p><strong>不能实例化类型变量</strong><br>诸如 <code>new T(...)</code> <code>T.class</code> 是非法的。类型擦除将 T 改变成 Object 从而违反了本意。<br>通过反射调用 Class.newInstance 方法来构造泛型对象，例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static &lt;T&gt; Pair&lt;T&gt; makePair(Class&lt;T&gt; cl) &#123;</span><br><span class="line">	try &#123; return new Pair&lt;&gt;(cl.newInstance(), cl.newInstance()); &#125;</span><br><span class="line">	catch (Exception ex) &#123; return null; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pair&lt;String&gt; p = Pair.makePair(String.class);</span><br></pre></td></tr></table></figure>

<p>Class 类本身是泛型，例 <code>String.calss</code> 是 <code>Class&lt;String&gt;</code> 的唯一实例，makePair 以此推断 Pair 类型。</p>
<p><strong>泛型类的静态域和方法无效</strong><br>不能在静态域或方法中使用泛型，经过类型擦除后只有一个非泛型域，会引起歧义。</p>
<p><strong>不能抛出或捕获泛型类的实例</strong><br>泛型类扩展 Throwable 都是不合法的，catch 子句中不能使用类型变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Problem&lt;T&gt; extends Exception &#123;&#125; // Error</span><br><span class="line"></span><br><span class="line">catch (T e) &#123;&#125; //Error</span><br></pre></td></tr></table></figure>

<p>在异常规范中使用是允许的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static &lt;T extends Throwable&gt; void doWork(T t) throws T &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>擦除后的冲突</strong><br>当：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Pair&lt;T&gt; &#123;</span><br><span class="line">	public boolean equals(T value) &#123; return first.equals(value) &amp;&amp; second.equals(value); &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如对于 Pai<string> 有两个 equals 方法：</string></p>
<ul>
<li>boolean equals(String) 由 Pair<t> 定义</t></li>
<li>boolean equals(Object) 继承自 Object</li>
</ul>
<p>方法擦除 <code>boolean equals(T)</code> 后即 <code>boolean equals(Object)</code> 覆盖了继承的方法。</p>
<p>一个类或类型变量不能同时成为两个接口类型的子类，这两个接口是同一接口的不同参数化（可能与桥方法产生冲突）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Employee implements Comparable&lt;Employee&gt; &#123; ... &#125;</span><br><span class="line">class mangeer extends Employee implements Comparable&lt;Manager&gt; &#123; ... &#125;</span><br><span class="line">// Error</span><br></pre></td></tr></table></figure>

<h1 id="通配符部分"><a href="#通配符部分" class="headerlink" title="通配符部分"></a>通配符部分</h1><p><strong>子类型限定</strong><br>例：Pair<manager> 是 Pair&lt;? extends Employee&gt; 的子类型，即将 Pair 的类型限定于 Employee 及其子类。通配符的引用不会引起破坏：</manager></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pair&lt;Manager&gt; managerBuddies = new Pair&lt;&gt;(ceo, cfo);</span><br><span class="line">Pair&lt;? extends Employee&gt; wildcardBuddies = managerBuddies; // OK</span><br><span class="line">wildcardBuddies.setFirst(lowlyEmployee); // error</span><br></pre></td></tr></table></figure>

<p>因为对于方法而言：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">? extends Employee getFirst() &#123;&#125;</span><br><span class="line">void setFirst(? extends Employee) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>编译器只知道 setFirst 需要某个 Employee 的子类型，不知道具体是什么类型，拒绝任何特定的类型。而对于 getFrist，将返回值赋给 Employee 的引用是合法的。</p>
<p><strong>超类型限定</strong><br>诸如 <code>&lt;? super Manger&gt;</code> 。<br>与子类型限定相反，可以为方法提供参数但不能使用返回值。</p>
<p>带有超类型限定的通配符可以向泛型对象写入，带有子类型限定的通配符可以从泛型读取。</p>
<p><strong>无限定通配符</strong><br>get 的返回值只能赋给一个 Object 。setFirst 只允许 null 值（子类型限定同）。</p>
<h1 id="反射部分"><a href="#反射部分" class="headerlink" title="反射部分"></a>反射部分</h1><p>对象是泛型类实例时，因为擦除，反射得不到太多信息。<br>详见 API</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>类型擦除</tag>
        <tag>继承</tag>
        <tag>通配符</tag>
        <tag>泛型约束</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 补丁-继承</title>
    <url>/2019/12/11/Java-%E8%A1%A5%E4%B8%81-%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="超类子类部分"><a href="#超类子类部分" class="headerlink" title="超类子类部分"></a>超类子类部分</h1><p><strong>this 和 super</strong></p><table>
<thead>
<tr>
<th>this</th>
<th>super</th>
</tr>
</thead>
<tbody><tr>
<td>引用隐式参数</td>
<td>调用超类方法</td>
</tr>
<tr>
<td>调用该类其他构造器</td>
<td>调用超类的构造器</td>
</tr>
</tbody></table><p>但是：super 不是一个对象的引用，只是一个指示编译器调用超类方法的<em>关键词</em></p><p><strong>is-a 规则</strong><br>出现超类对象的任何地方都可以通过子类对象置换。即置换法则。</p><p><strong>方法调用</strong><br>假设调用 x.f(args)，x 是类 C 的一个对象：</p><a id="more"></a>




<ol>
<li>编译器查看对象的声明类型和方法名。编译器会一一列举所有 C 类中名为 f 的方法和其超类中声明为 public 且名为 f 的方法。</li>
<li>编译器查看调用方法时提供的参数类型，选择第一步中与提供的参数类型完全匹配的方法。即重载解析。这个过程允许类型转换，若没有找到或找到多个则报告错误。&lt;– 此时已获得需要调用的方法名和参数类型</li>
<li>如果是 private static final 方法或者构造器，编译器已知道应该调用的方法，即静态绑定。若调用的方法依赖隐式参数的实际类型，称动态绑定。此例中编译器通过动态绑定确定调用 f(String) 方法。</li>
<li>采用动态绑定调用方法时，虚拟机会调用与 x 所引对象_实际类型_最符合的那个类的方法。若 x 实际类型为 D，是 C 的子类。若 D 定义了 f(String) 方法就调用，否则在 D 的超类中寻找。</li>
</ol>
<p>为了应对搜索方法的时间开销，虚拟机预先为每个类创建方法表，列出所有方法签名和实际调用的方法。</p>
<p><strong>绑定</strong><br>_静态绑定_：在程序执行以前已经被绑定（即在编译过程中就已经知道这个方法到底是哪个类中的方法）。<br>_动态绑定_：在运行时期根据具体对象的类型进行绑定。<br>Java 中重载的方法使用静态绑定，重写的方法使用动态绑定。</p>
<p><strong>protected</strong><br>仅对本类可见，包括子类。谨慎使用于数据域，因为他人可能由这个类派生出新类并访问 protected，若要对此类进行修改就必须通知所有相关人员。更适合使用于方法。</p>
<h1 id="Objects-部分"><a href="#Objects-部分" class="headerlink" title="Objects 部分"></a>Objects 部分</h1><p><strong>覆盖 equals</strong></p>
<ol>
<li>检测 this 与显式参数是否引用同一个对象。<code>if (this == otherObj) return true;</code></li>
<li>检测显式参数是否为 null，因为 null 调用方法会报错。 <code>if (otherObj == null) return false;</code></li>
<li>比较 this 与显式参数是否为同一类。为了保证 equals 的对称性，应该 <code>if (getClass() != otherObj.getclass()) return false;</code> 但是例如 AbstractSet 类拥有 TreeSet 和 HashSet 两个具体子类，实现了同样的操作。此时应该 <code>if (!(otherObj instanceof ClassName)) return false;</code></li>
<li>将 otherObj 转换为相应的类类型变量。 <code>ClassName other = (ClassName) otherObj;</code></li>
<li>对需要比较的域进行比较，== 比较基本域，Objects.equals 比较对象域。 <code>return field1 == other.field1 $$ Objects.equals(field2, other.field2);</code><br>如果在子类中重新定义了 equals，先调用 <code>super.equals(other);</code> 比较，再比较子类中的实例域。<br>覆盖 Objects 类的 equals 方法就不要弄错显式参数类型！可以用 @Override 进行标记。<br>对于数组类型，使用静态 Arrays.equals 方法。</li>
</ol>
<p><strong>覆盖 hashCode</strong><br>不同对象的散列码基本不会相同，最好使用 null 安全的 Objects.hashCode，参数为 null 时返回 0；使用静态方法避免创建对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int hashCode()&#123;</span><br><span class="line">	return 7 * Objects.hashCode(name) + 11* Double.hashCode(salary);</span><br><span class="line">	// 或者</span><br><span class="line">	return Objects.hashCode(name, salary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>覆盖 toString</strong><br>Objects 的 toString 输出对象所属的类名和散列码。有时候直接输出这个大概是设计者没覆盖…<br>比如数组继承了 Objects 的方法，所以用静态方法 Arrays.toString 比较好。</p>
<h1 id="泛型数组列表部分"><a href="#泛型数组列表部分" class="headerlink" title="泛型数组列表部分"></a>泛型数组列表部分</h1><p><strong>数组长度</strong><br>确认数组列表不再发生变化时使用 trimToSize 方法，将存储区域的大小调整为当前，回收多余存储空间。不影响之后再添加元素，但和扩展一样，会自动创建更大的数组并拷贝进去。</p>
<p><strong>参数数量可变方法</strong><br>… 代表当前方法可以接收任意数量的对象，相当于接收了对象数组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static double max(double... values)&#123;&#125;</span><br><span class="line">// 基本类型会自动装箱</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>泛型</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 补丁-网络</title>
    <url>/2020/03/15/Java-%E8%A1%A5%E4%B8%81-%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Socket s = <span class="keyword">new</span> Socket(<span class="string">"yuyurbq.club"</span>, <span class="number">80</span>);</span><br><span class="line"><span class="comment">// 打开一个套接字</span></span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(s.getInputStream(), <span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure><h2 id="套接字超时"><a href="#套接字超时" class="headerlink" title="套接字超时"></a>套接字超时</h2><p>对于读写操作没有数据可供访问而阻塞：使用 <code>SetSoTimeout</code> 方法设置（毫秒），若之后的读写操作在时间内没有完成将抛出 SocketTimeoutException 异常。</p><a id="more"></a>


<p>对于一直无法建立到主机的连接而阻塞：先构建无连接的套接字，再通过有超时参数的方法进行连接：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Socket s = <span class="keyword">new</span> Socket();</span><br><span class="line">s.connect(<span class="keyword">new</span> InetSocketAddress(host, port), timeout);</span><br></pre></td></tr></table></figure>

<h2 id="获取-ip"><a href="#获取-ip" class="headerlink" title="获取 ip"></a>获取 ip</h2><p>静态方法 <code>getByName</code> 方法将返回代表某主机的 InetAddress 对象，通过 <code>getAddress</code> 获取封装其中的 ip 字节序列：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InetAddress address = InetAddress.getByName(host);</span><br><span class="line"><span class="keyword">byte</span>[] addressBytes = address.getAddress();</span><br></pre></td></tr></table></figure>

<p>若主机名拥有多个地址，且希望获得所有这些：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InetAddress[] addresses = InetAddress.getAllByName(host);</span><br></pre></td></tr></table></figure>

<p>还有个 <code>getLocalHost</code> 避免获得 127.0.0.1 这样的本地地址。</p>
<h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><h2 id="服务端套接字"><a href="#服务端套接字" class="headerlink" title="服务端套接字"></a>服务端套接字</h2><p>建立套接字：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocket s = <span class="keyword">new</span> ServerSocker(port); <span class="comment">// port 不是字符串</span></span><br></pre></td></tr></table></figure>

<p>监听这个端口，一旦有客户端连接上（连接已建立）这个端口，将返回一个 Socket 对象，并以此获得输入输出流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Socket incoming = s.accept();</span><br><span class="line">InputStream inStream = incoming.getInputStream();</span><br><span class="line">OutputStream outStream = incoming.getOutputStream();</span><br></pre></td></tr></table></figure>

<p>将流转换成扫描器和写入器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner in = <span class="keyword">new</span> Scanner(inStream, <span class="string">"UTF-8"</span>);</span><br><span class="line">PrintWrite out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> OutputStreamWriter(outStream, <span class="string">"UTF-8"</span>), <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>通讯的最后关闭套接字：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">incoming.close();</span><br></pre></td></tr></table></figure>

<h2 id="多个客户端"><a href="#多个客户端" class="headerlink" title="多个客户端"></a>多个客户端</h2><p>通过线程解决，类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">	Socket incoming = s.accept();</span><br><span class="line">	Runnable r = <span class="keyword">new</span> ThreadedEchoHandler(incoming);</span><br><span class="line">	Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">	t.start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadedEchoHandler 实现 Runnable 接口，在 run 方法中包含与客户端通信的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadedEchoHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> (InputStream inStream = incoming.get...) &#123;</span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span>(IOException e) &#123;...&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="半关闭"><a href="#半关闭" class="headerlink" title="半关闭"></a>半关闭</h2><p>socket 对象的 <code>shutdownOutput()</code> 方法可以终止输出但保持接收，适合 HTTP 这种 one-shot 服务。</p>
<h2 id="可中断套接字"><a href="#可中断套接字" class="headerlink" title="可中断套接字"></a>可中断套接字</h2><p>套接字读写数据时，当前线程将被阻塞至操作成功或超时为止，此时想取消连接的话，当线程因套接字无法响应而阻塞时，无法通过调用 interrupt 解除。</p>
<p> 为了中断套接字操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SocketChannel channel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(host, port));</span><br><span class="line"><span class="comment">// 服务器端 host 用 localhost 即可</span></span><br></pre></td></tr></table></figure>

<h1 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h1><h2 id="URL-和-URI"><a href="#URL-和-URI" class="headerlink" title="URL 和 URI"></a>URL 和 URI</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[scheme:]schemeSpecificPart[#fragment]</span><br><span class="line">分层 URI : schemeSpecificPart &gt; [//authority][path][?query]</span><br><span class="line">基于服务器的 URL : authority &gt; [user-info@]host[:port]</span><br></pre></td></tr></table></figure>

<p>URI</p>
<ul>
<li>语法结构，指定 Web 资源的字符串；</li>
<li>URI 类解析标识符并将其分解成组成部分，如 <code>getScheme</code> <code>getHost</code> <code>getPath</code> 等；</li>
<li>还可以处理绝对和相对标识符，组合出绝对 URI 或相对化 URI，<code>relativize(combined)</code> <code>resolve(relative)</code> 。</li>
</ul>
<p>URL</p>
<ul>
<li>URI 的一个特例，定位 Web 资源；</li>
<li>从字符串构建 URL 对象：<code>URL url = new URL(urlString)</code> ;</li>
<li>从 URL 类的 <code>openStream</code> 方法获得 InputStream 对象，随后正常处理。</li>
</ul>
<p>URN</p>
<ul>
<li>无法定位数据的 URI，统一资源名称。</li>
</ul>
<h2 id="从-URLConnection-获取信息"><a href="#从-URLConnection-获取信息" class="headerlink" title="从 URLConnection 获取信息"></a>从 URLConnection 获取信息</h2><p>能获得比基本 URL 类更多的控制功能。</p>
<ol>
<li><p>URL 类的 openConnection 方法获得对象：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">URLConnection connection = url.openConnection();</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置任意的请求属性，如 <code>setDoInput</code> <code>setDoOutput</code> <code>setUseCaches</code> 等；</p>
</li>
<li><p>用 connect 方法连接：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">connection.connect();</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以进行头信息的查询，<code>getHeaderFields</code> 返回一个包含消息头所有字段的 Map 对象，通过 <code>getContentType</code> <code>getDate</code> <code>getContentLength</code> 等查询字段；</p>
</li>
<li><p><code>getInputStream</code> 方法访问资源数据，和 openStream 返回的流相同。</p>
</li>
</ol>
<p><strong>设置连接属性</strong></p>
<p>默认建立的连接只产生读取信息的输入流，若要获得执行写操作的输出流（提交数据）使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">connection.setDoOutput(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>设置请求头：<code>setIfModifiedSince</code> 方法针对某特定日期以来的修改；<code>setUseCaches</code>  只作用于 Applet ；<code>setUseCaches</code> 方法命令浏览器先检查缓存；<code>setAllowUserInteraction</code> 用于访问密码保护资源时弹出对话框，等。</p>
<p><strong>查询响应头</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String key = connection.getHeaderfieldKey(n);</span><br></pre></td></tr></table></figure>

<p>获得响应头的第 n 个键，n 从 1 开始，若 n 为 0 或大于消息头的字段总数则返回 null。此方法无法返回字段数量，只能遍历到 null 为止。类似的，<code>getHeaderField(n)</code> 获得第 n 个值。</p>
<p><code>getHeaderFields</code> 方法返回封装了响应头字段的 Map 对象。还有获取常用消息头字段的方法：</p>
<table>
<thead>
<tr>
<th align="center">键</th>
<th align="center">方法</th>
<th align="center">返回类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Date</td>
<td align="center">getDate</td>
<td align="center">long</td>
</tr>
<tr>
<td align="center">Expires</td>
<td align="center">getExpiration</td>
<td align="center">long</td>
</tr>
<tr>
<td align="center">LastModified</td>
<td align="center">getLastModified</td>
<td align="center">long</td>
</tr>
<tr>
<td align="center">Content-Length</td>
<td align="center">getContentLength</td>
<td align="center">int</td>
</tr>
<tr>
<td align="center">Content-Type</td>
<td align="center">getContentType</td>
<td align="center">String</td>
</tr>
<tr>
<td align="center">Content-Encoding</td>
<td align="center">getContent-Encoding</td>
<td align="center">String</td>
</tr>
</tbody></table>
<h2 id="提交表单数据"><a href="#提交表单数据" class="headerlink" title="提交表单数据"></a>提交表单数据</h2><p>首先创建 URLConnection 对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"http://host/path"</span>);</span><br><span class="line">URLConnection connection = url.openConnection();</span><br></pre></td></tr></table></figure>

<p>使用 setDoOutput 方法建立用于输出的连接：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">connection.setDoOutput(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>然后用 getOutputStream 方法获得一个流，并包装在 PrintWriter 对象中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintWrite out = <span class="keyword">new</span> PrintWriter(connection.getOutputStream(),<span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure>

<p>通过 out.print() 发送数据，最后 out.close() 关闭流。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 命令思维导图</title>
    <url>/2020/01/30/Linux-%E5%91%BD%E4%BB%A4%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
    <content><![CDATA[<p>没钱开 XMind… 理直气壮不去水印</p>
<p><img src="https://i.loli.net/2020/03/06/tQxgWw3LKerF8YH.png" alt="linux.png"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>思维导图</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux bash</title>
    <url>/2019/11/06/Linux-bash/</url>
    <content><![CDATA[<h1 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h1><p>用户默认取得的 shell 记录于 /etc/passwd，默认是 bash<br>上一次登录的历史命令记录在 ~/.bash_histroy，本次登录的会在注销后记录进去<br>内置命令和外部命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># type [-ta] name</span><br><span class="line">-t 仅显示执行时的依据</span><br><span class="line">-a 显示所有含 name 的命令</span><br></pre></td></tr></table></figure><p>内置命令是 shell 解释程序内建的，由 shell 直接执行，不需要派生新的进程；外部命令 shel会创建一个新的进程，新的进程在 PATH 变量内所列出的目录中寻找特定命令执行，默认 shell 将等待直到该进程结束</p><a id="more"></a>



<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>env 查看当前 shell 环境下的环境变量和内容<br>set 查看所有变量，包含环境变量和自定义变量</p>
<p><strong>设置规则</strong><br>不能以数字开头，连接的 = 两边不能直接接空格，变量内容若有空格使用 “ 或 ‘，必须成对</p>
<ul>
<li>“ 可以保持特殊字符的特性，如 var=lang is $LANG 相当于 lang is en_US<br>  ‘ 仅为纯文本</li>
<li>`命令` 和 $(命令) 用于在命令中使用其他命令的值，如 echo $version<br>  $变量名称 ${变量名称} 用于显示变量或增加变量内容，如 PATH=”$PATH”:/home/bin</li>
</ul>
<p>转义字符 / 将特殊符号变成一般符号，命令过长可以 /[enter] 换行<br>若变量需要在子进程进行需要用 export 变成环境变量，不加参数时和 env 相似<br>unset 取消变量</p>
<p><strong>语系问题</strong><br>locale 不加参数查询所有语系变量<br>可以逐一设置，当设置 LANG 或者 LC_ALL 时，其他语系变量都会被这两个替代<br>locale -a 查询所有支持的语系，语系文件放置在 /usr/lib/locale/<br>整体系统默认的语系定义在 /etc/sysconfig/i18h</p>
<p><strong>键盘输入</strong><br>读取来自键盘输入的变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># read [-pt] variable</span><br><span class="line">-p 后面可接提示符</span><br><span class="line">-t 后面可接等待秒数</span><br></pre></td></tr></table></figure>

<p><strong>声明变量类型</strong><br>declare 或 typeset 功能一样。变量类型默认为字符串，数值运算默认最多达到整数型<br>数组变量类型，var[index] = content 设置，${数组}读取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># declare [-aixrp] variable</span><br><span class="line">-a 定义成数组 array 类型</span><br><span class="line">-i 定义成整数 integer 类型</span><br><span class="line">-x 与 export 一样，变成环境变量</span><br><span class="line">-r 设置成只读 readonly 类型，不可被变更内容也不能重设</span><br><span class="line">-p 查看变量类型</span><br><span class="line">不接任何参数则显示所有变量与内容，类似 set</span><br><span class="line">将 - 换成 + 可进行取消操作</span><br><span class="line"></span><br><span class="line"># sum=1+2+3    &lt;--x</span><br><span class="line"># declare -i sum=1+2+3    &lt;--√</span><br><span class="line"># echo $sum</span><br></pre></td></tr></table></figure>

<p><strong>变量内容的删除和替换</strong><br>从变量内容向右删除，取最短的那个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># $&#123;variable#&#125;</span><br></pre></td></tr></table></figure>

<p>从变量内容向右删除，取最长的那个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># $&#123;variable##&#125;</span><br></pre></td></tr></table></figure>

<p>从变量内容向左删除，取最短的那个，最长同上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># $&#123;variable%&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">设置</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">${变量#关键字}</td>
<td align="center">变量内容从头开始的内容符合关键字，则删除符合的最短数据</td>
</tr>
<tr>
<td align="center">${变量##关键字}</td>
<td align="center">变量内容从头开始的内容符合关键字，则删除符合的最长数据</td>
</tr>
<tr>
<td align="center">${变量%关键字}</td>
<td align="center">变量内容从后向前的内容符合关键字，则删除符合的最短数据</td>
</tr>
<tr>
<td align="center">${变量%%关键字}</td>
<td align="center">变量内容从后向前的内容符合关键字，则删除符合的最短数据</td>
</tr>
<tr>
<td align="center">${变量/旧字符串/新字符串}</td>
<td align="center">变量内容符合旧字符串，则替换第一个旧字符串</td>
</tr>
<tr>
<td align="center">${变量//旧字符串/新字符串}</td>
<td align="center">变量内容符合旧字符串，则替换全部的旧字符串</td>
</tr>
</tbody></table>
<p><strong>变量的测试和内容替换</strong><br>判断变量是否存在，不存在便给予设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># new_var=$&#123;old_var-content&#125;</span><br></pre></td></tr></table></figure>

<p>判断变量是否存在或为空字符串，不存在或为空便给予设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># new_var=$&#123;old_var:-content&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">设置方式</th>
<th align="center">str 没有设置</th>
<th align="center">str 为空字符串</th>
<th align="center">str 已设置非空</th>
</tr>
</thead>
<tbody><tr>
<td align="center">var=${str-expr}</td>
<td align="center">var=exper</td>
<td align="center">var=</td>
<td align="center">var=$str</td>
</tr>
<tr>
<td align="center">var=${str:-expr}</td>
<td align="center">var=exper</td>
<td align="center">var=expr</td>
<td align="center">var=$str</td>
</tr>
<tr>
<td align="center">var=${str+expr}</td>
<td align="center">var=</td>
<td align="center">var=expr</td>
<td align="center">var=expr</td>
</tr>
<tr>
<td align="center">var=${str:+expr}</td>
<td align="center">var=</td>
<td align="center">var=</td>
<td align="center">var=expr</td>
</tr>
<tr>
<td align="center">var=${str=expr}</td>
<td align="center">var=expr str=expr</td>
<td align="center">var=  str 不变</td>
<td align="center">var=$str str 不变</td>
</tr>
<tr>
<td align="center">var=${str:=expr}</td>
<td align="center">var=expr str=expr</td>
<td align="center">var=expr str=expr</td>
<td align="center">var=$str str不变</td>
</tr>
<tr>
<td align="center">var=${str?expr}</td>
<td align="center">expr 输出至 stderr</td>
<td align="center">var=</td>
<td align="center">var=str</td>
</tr>
<tr>
<td align="center">var=${str:?expr}</td>
<td align="center">expr 输出至 stderr</td>
<td align="center">expr 输出至 stderr</td>
<td align="center">var=str</td>
</tr>
</tbody></table>
<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><p><strong>命令别名设置</strong><br>alias 单用查询当前命令别名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># alias rm=&apos;rm -i&apos;</span><br></pre></td></tr></table></figure>

<p>unalias 取消命令别名</p>
<p><strong>历史命令</strong><br>登录主机后，系统由 ~./bash_history 读取历史命令，记录的条数由 HISTSIZE 变量设定，注销时会将最近的 HISTSIZE 条记录到记录文件中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># history [n]</span><br><span class="line"># history [-c]</span><br><span class="line"># history [-raw] histfiles</span><br><span class="line">n 最近 n 条命令</span><br><span class="line">-c 清除目前 shell 中的 history</span><br><span class="line">-a 将新增的 history 更新进 histfiles，若没有则写入默认文件中</span><br><span class="line">-r 将 histfiles 的内容读到目前 shell 的 history 中</span><br><span class="line">-w 将目前 history 更新进 histfiles</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># !number</span><br><span class="line"># !command</span><br><span class="line"># !!</span><br><span class="line">number 执行第 number 条指令</span><br><span class="line">command 由近向远搜寻 command 开头的命令并执行</span><br><span class="line">!! 执行上一条命令</span><br></pre></td></tr></table></figure>

<h1 id="操作环境"><a href="#操作环境" class="headerlink" title="操作环境"></a>操作环境</h1><p><strong>命令运行的顺序</strong></p>
<ul>
<li>相对/绝对路径执行</li>
<li>由 alias 找到执行</li>
<li>bash 内置命令</li>
<li>$PATH 变量找到的第一个</li>
</ul>
<p><strong>bash 的登录欢迎信息</strong><br>登录后的欢迎字符串在 /etc/issue 中设置<br>telnet 远程登录用的是 /etc/issue.net</p>
<table>
<thead>
<tr>
<th align="center">-</th>
<th align="center">-</th>
</tr>
</thead>
<tbody><tr>
<td align="center">\d</td>
<td align="center">本地日期</td>
</tr>
<tr>
<td align="center">\l</td>
<td align="center">第几个终端机接口</td>
</tr>
<tr>
<td align="center">\m</td>
<td align="center">硬件等级</td>
</tr>
<tr>
<td align="center">\n</td>
<td align="center">主机的网络名称</td>
</tr>
<tr>
<td align="center">\0</td>
<td align="center">domain name</td>
</tr>
<tr>
<td align="center">\r</td>
<td align="center">操作系统版本 (uname -r)</td>
</tr>
<tr>
<td align="center">\t</td>
<td align="center">本地时间</td>
</tr>
<tr>
<td align="center">\s</td>
<td align="center">操作系统名称</td>
</tr>
<tr>
<td align="center">\v</td>
<td align="center">操作系统版本</td>
</tr>
</tbody></table>
<p>每个用户登录后都显示的信息加入 /etc/moted 中</p>
<p><strong>bash 的环境配置</strong><br>login shell ：完整登录流程取得的 bash<br>non-login shell ：没有重复登录取得的 bash，如 X Window 登录后图形界面启动终端机，没有再次要求输入密码</p>
<p>读入环境配置文件<br>source 或小数点 . 都可以将配置文件读进当前 shell 环境而不必注销</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># source 配置文件名</span><br></pre></td></tr></table></figure>

<p>login shell 读取的文件：</p>
<ol>
<li>/etc/profile 系统整体设置，会调用外部数据<ul>
<li>/etc/inputrc</li>
<li>/etc/profile.d/*.sh</li>
<li>/etc/sysconfig/i18n</li>
</ul>
</li>
<li>~/.bash_profile 或 ~/.bash_login 或 /.profile 用户个人设置，仅读取依此顺序第一个找到的，照顾其他 shell 的用户</li>
</ol>
<p>non-login shell 仅读取 ~.bashrc</p>
<p><strong>终端机环境设置</strong><br>查阅按键内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># stty [-a]</span><br><span class="line">-a 列出目前所有的按键和按键内容</span><br><span class="line">^ 代表 [ctrl]</span><br></pre></td></tr></table></figure>

<p>设置按键</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># stty 行为 按键</span><br></pre></td></tr></table></figure>

<p>set 可设置输出/输入环境</p>
<p><strong>通配符</strong><br>* 零到无穷个字符；? 一定有一个字符；[] 一定有一个在其中的字符；[-] 编码顺序内的所有字符；[^] 非</p>
<h1 id="数据流重定向"><a href="#数据流重定向" class="headerlink" title="数据流重定向"></a>数据流重定向</h1><p>将某个命令执行后的输出传输到其他地方<br>标准输入 stdin ：代码 0，用 &lt; &lt;&lt;<br>标准输出 stdout ：代码 1，用 &gt; &gt;&gt;<br>标准错误输出 stderr ：代码 2，用 2&gt; 2&gt;&gt;</p>
<p><strong>将数据输出到指定文件或设备</strong><br>&gt; 输出到已存在文件时，会先清空再写入<br>&gt;&gt; 会写入文件的最下方<br>垃圾桶黑洞设备（丢弃错误信息），/dev/null 可以吃掉任何导向该设备的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find /home -name .bashrc 2&gt; /dev/null</span><br></pre></td></tr></table></figure>

<p>将正确与错误信息写入到同一文件，使用 &amp; 语法，否则会交叉写入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ find /home -name .bashrc &gt; list 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>cat 命令后加入 &gt;，会主动创建文件，并且其内容即键盘输入的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat &gt; catfile</span><br><span class="line">testing</span><br><span class="line">&lt;==[ctrl]+d 离开</span><br></pre></td></tr></table></figure>

<p><strong>用文件内容代替键盘输入</strong><br>&lt; 指定文件内容替代键盘输入<br>&lt;&lt; 代表输入结束，键盘输入指定字符便结束输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat &gt; catfile &lt; ～/.bashrc</span><br></pre></td></tr></table></figure>

<h1 id="命令的判断依据"><a href="#命令的判断依据" class="headerlink" title="命令的判断依据"></a>命令的判断依据</h1><p><strong>;</strong> 一次执行多条命令，用 ; 隔开<br><strong>$?</strong> 命令回传码，若前一个命令执行的结果为正确，将回传 $?=0<br><strong>&amp;&amp;</strong> $?=0 才执行下一句<br><strong>||</strong> $?≠0 才执行下一句<br>cmd1 &amp;&amp; cmd2 || cmd3 是安全的，其余顺序要注意有效性和安全性</p>
<h1 id="管道命令-pipe"><a href="#管道命令-pipe" class="headerlink" title="管道命令 pipe"></a>管道命令 pipe</h1><p>使用 | 符号，仅处理由前一个命令传来的正确信息，并且接收数据成为 stdin 继续处理</p>
<ul>
<li>less more head 是可以接收 stdin 的管道命令</li>
<li>ls cp mv 则不是</li>
</ul>
<h3 id="选取命令"><a href="#选取命令" class="headerlink" title="选取命令"></a>选取命令</h3><p>cut 取出一段信息的某一段，常用于将同一行的数据进行分解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cut -d &apos;分隔字符&apos; -f fields</span><br><span class="line"># cut -c 字符范围</span><br><span class="line">-d -f 依据分隔字符将信息切成数段，取其中 fields 段</span><br><span class="line">-c 以字符的单位取出固定字符区间</span><br><span class="line"></span><br><span class="line">echo $PATH | cut -d &apos;:&apos; -f 3,5</span><br><span class="line">export | cut -c 12-</span><br></pre></td></tr></table></figure>

<p>grep 对行信息进行分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># grep [-acinv] [--color=auto] &apos;查找字符串&apos; filename</span><br><span class="line">-a 将 binary 文件以 text 文件的方式查找</span><br><span class="line">-c 计算找到 &apos;&apos; 的次数</span><br><span class="line">-i 忽略大小写</span><br><span class="line">-n 输出行号</span><br><span class="line">-v 反选</span><br><span class="line"></span><br><span class="line">last | grep &apos;root&apos; | cut -d &apos; &apos; -f 1</span><br></pre></td></tr></table></figure>

<h3 id="排序命令"><a href="#排序命令" class="headerlink" title="排序命令"></a>排序命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sort [-fbMnrtuk] [file or stdin]</span><br><span class="line">-f 忽略大小写</span><br><span class="line">-b 忽略最前面的空格符</span><br><span class="line">-M 以月份排序</span><br><span class="line">-n 使用纯数字排序，默认是文字类型</span><br><span class="line">-r 反向排序</span><br><span class="line">-u 相同数据仅显示一条</span><br><span class="line">-t 设置分隔符，默认 [TAB]</span><br><span class="line">-k 以区间（field）进行排序</span><br><span class="line"></span><br><span class="line">cat /etc/passwd | sort -t &apos;:&apos; -k 3 -n</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># uniq [-ic]</span><br><span class="line">-i 忽略大小写</span><br><span class="line">-c 进行计数</span><br><span class="line"></span><br><span class="line">last | cut -d &apos; &apos; -f 1 | sort | uniq -c</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># wc [-lwm]</span><br><span class="line">-l 仅列出行</span><br><span class="line">-w 仅列出多少英文单字</span><br><span class="line">-m 仅显示多少字符</span><br><span class="line">默认显示 行数 字数 字符数</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>bash</tag>
        <tag>数据流</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 文件与目录</title>
    <url>/2019/09/08/Linux-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h1 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h1><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-rw-r--r-- 1 root root 63428 Sep 8 19:24 xxxxx.md</span><br></pre></td></tr></table></figure>

<h3 id="第一列-第一位"><a href="#第一列-第一位" class="headerlink" title="第一列 第一位"></a>第一列 第一位</h3><ul>
<li>[d] 目录</li>
<li>[-] 文件</li>
<li>[l] 连接文件 linkfile</li>
<li>[b] 可供存储的设备 是设备文件</li>
<li>[c] 串行端口设备 是设备文件<a id="more"></a>
<h3 id="第一列-第二-九位"><a href="#第一列-第二-九位" class="headerlink" title="第一列 第二~九位"></a>第一列 第二~九位</h3>三个一组，分别为 </li>
<li>文件所有者权限</li>
<li>同用户组权限</li>
<li>其他用户权限</li>
</ul>
<p>每组三个参数依次为 r读-4 w写-2 x执行-1<br>Linux 中文件的可执行性与文件名无绝对关系<br>文件与目录的权限<strong>意义不同</strong></p>
<h3 id="第二列"><a href="#第二列" class="headerlink" title="第二列"></a>第二列</h3><p>链接到此节点 i-node 的不同文件名数<br>&ensp;&ensp;文件名集合权限与属性记录到文件系统的 i-node 中</p>
<h3 id="第六列"><a href="#第六列" class="headerlink" title="第六列"></a>第六列</h3><p>创建日期或最近修改日期<br>显示完整时间格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ls -l --full-time</span><br></pre></td></tr></table></figure>

<p>&ensp;&ensp;中文无法在终端显示所以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># LANG= en_US</span><br></pre></td></tr></table></figure>

<h2 id="改变文件属性"><a href="#改变文件属性" class="headerlink" title="改变文件属性"></a>改变文件属性</h2><blockquote>
<p>复制行为 cp 不会更改源文件的属性</p>
</blockquote>
<h3 id="chgrp-改变所属用户组"><a href="#chgrp-改变所属用户组" class="headerlink" title="chgrp 改变所属用户组"></a>chgrp 改变所属用户组</h3><p>change group</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># chgrp [-R] groupname dirname/filename</span><br></pre></td></tr></table></figure>

<p>组名在 /etc/group 中，否则报错</p>
<h3 id="chown-改变所有者"><a href="#chown-改变所有者" class="headerlink" title="chown 改变所有者"></a>chown 改变所有者</h3><p>change owner</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># chown [-R] ownername dirname/filename</span><br><span class="line"># chown [-R] ownername:groupname dirname/filename</span><br></pre></td></tr></table></figure>

<p>组名在 /etc/passwd 中，否则报错<br>ownername:groupname 同时更改 owner 和 group，不要用 . 防止误判</p>
<h3 id="chmod-改变权限"><a href="#chmod-改变权限" class="headerlink" title="chmod 改变权限"></a>chmod 改变权限</h3><p>change modify</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># chmod [-R] xyz dirname/filename</span><br><span class="line"># chmod u/g/o/a +/-/= r/w/x dirname/filename</span><br></pre></td></tr></table></figure>

<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>树状，记录文件名<strong>列表</strong></p>
<h2 id="FHS"><a href="#FHS" class="headerlink" title="FHS"></a>FHS</h2><p>/<br>根目录，开机相关<br>FHS建议 / 所在分区应越小越好，但以下不应该与根目录分开：</p>
<ul>
<li>/etc 配置文件</li>
<li>/bin 执行文件，可被 root 和一般用户共用</li>
<li>/dev 设备文件</li>
<li>/lib 函数库和内核所需模块</li>
<li>/sbin 执行文件，多用于设定系统文件，root 限定<br>因为与开机过程有关，开机仅挂载根目录，其他分区在开机完成后进行<br>根目录也有 . 和 ..，但两者都是根目录本身</li>
</ul>
<p>/usr<br>UNIX software resourse 软件资源数据，可分享 shareable 不可变动 static</p>
<p>/var<br>variable 常态性变动文件，缓存，登陆文件，软件运行产生的文件等</p>
<h2 id="权限之于目录"><a href="#权限之于目录" class="headerlink" title="权限之于目录"></a>权限之于目录</h2><ul>
<li>r read contents in directory<br>读取目录结构列表的权限，即<ul>
<li>文件名数据，可利用 ls 查询内容列表</li>
</ul>
</li>
<li>w modify contents in directory<br>读取目录结构列表的权限，即<ul>
<li>新建新的文件和目录</li>
<li>删除已存在的文件与目录（无视其它权限）</li>
<li>重命名已存在的文件与目录</li>
<li>转移目录内的文件与目录位置</li>
</ul>
</li>
<li>x access directory<br>用户进入该目录成为工作目录的权限<ul>
<li>目前所在的目录</li>
</ul>
</li>
</ul>
<p>例：r–（目录） 用户访问 root 的目录<br>仅可查询目录下的文件名列表但不能切换到此目录，无法执行任何该目录下的命令<br>例：rwx（目录） 用户访问 root 的 — 文件<br>不可读 编辑 执行 但可以删除</p>
<h1 id="路径-PATH"><a href="#路径-PATH" class="headerlink" title="路径 PATH"></a>路径 PATH</h1><p>相对路径<br>相对于当前工作目录，shell scrits 下执行环境不同可能导致问题</p>
<p>绝对路径<br>一定由根目录 / 写起，正确度更好</p>
<p>系统依照 PATH 的设置去 PATH 定义的目录下查询对应文件名的可执行文件<br>不同用户默认 PATH 不同，故默认可直接执行指令也不同<br>但 PATH 可以修改，一般用户可通过修改 PATH 执行 /sbin 或 /usr/sbin 的命令来查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># echo $PATH                查询</span><br><span class="line"># PATH=&quot;$PATH&quot;:/dirname     添加目录进 PATH</span><br></pre></td></tr></table></figure>

<p>相同命令在不同目录，先被查询到的目录先执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># basename 取文件名</span><br><span class="line"># dirname  取目录名</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>文件</tag>
        <tag>目录</tag>
        <tag>属性权限</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 文件与目录操作</title>
    <url>/2019/09/09/Linux-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="目录处理"><a href="#目录处理" class="headerlink" title="目录处理"></a>目录处理</h1><p>cd change directory 切换目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cd -          返回之前的目录</span><br></pre></td></tr></table></figure>

<p>pwd print working directory 显示当前目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># pwd -p        获得实际路径而非连接路径</span><br></pre></td></tr></table></figure>

<p>mkdir 新建目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mkdir [-mp] dirname</span><br><span class="line">-m ：新建自定义权限的目录 如 mkdir -m xyz test</span><br><span class="line">-p ：递归创建 如 mkdir -p test1/test2/test3</span><br></pre></td></tr></table></figure>

<p>rmdir 删除空目录</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># rmdir [-p] dirname 同上</span><br></pre></td></tr></table></figure>

<h1 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h1><p> cp copy</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cp [-adfilprsu] source destination</span><br><span class="line">-a ：同-pdr</span><br><span class="line">-d ：若源文件是连接文件则复制连接文件而非本身</span><br><span class="line">-i ：若目标文件存在，询问是否覆盖</span><br><span class="line">-l ：创建硬连接的连接文件</span><br><span class="line">-p ：连同文件属性复制，常用于备份</span><br><span class="line">-r ：递归复制，用于目录的复制行为</span><br><span class="line">-s ：创建符号连接文件，即快捷方式</span><br><span class="line">-u ：源文件新才 update</span><br></pre></td></tr></table></figure>

<p> 默认情况下目的文件的所有者是命令操作者<br> 没有参数时 cp 复制的是<strong>源文件</strong>而非连接文件</p>
<p> rm remove<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># rm [-fir] dirname/filename</span><br><span class="line">-f : force 强制，忽略不存在的文件且不警告</span><br><span class="line">-i ：删除前进行询问</span><br><span class="line">-r ：递归删除</span><br></pre></td></tr></table></figure></p>
<p> 目录名以 - 开头会造成误判，可以用 ./ 避免</p>
<p> mv move<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mv [-fiu] source destination</span><br><span class="line">-f ：force 若目标文件已存在则直接覆盖不询问</span><br><span class="line">-i ：若目标文件存在，询问是否覆盖</span><br><span class="line">-u ：源文件新才 update</span><br></pre></td></tr></table></figure></p>
<p> 多个源文件或目录要移动时，最后一个（即目标文件）一定是目录 <font color="#D3D3D3">废话</font></p>
<h1 id="文件内容查阅"><a href="#文件内容查阅" class="headerlink" title="文件内容查阅"></a>文件内容查阅</h1><h2 id="直接查看"><a href="#直接查看" class="headerlink" title="直接查看"></a>直接查看</h2><ul>
<li><p>cat concatenate 从第一行开始显示文件内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cat [-AbEnTv]</span><br><span class="line">-A ：相当 -vET 整合，特殊字符 断行字符$ Tab键＾I</span><br><span class="line">-b ：列出行号，空白行不标号</span><br><span class="line">-n ：列出行号，包括空白行</span><br></pre></td></tr></table></figure>
</li>
<li><p>tac cat 反写，功能也是</p>
</li>
<li><p>nl 添加行号显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># nl [-bnw]</span><br><span class="line">-b ：行号的指定方式 </span><br><span class="line">     a 空行也显示，类似 cat -n</span><br><span class="line">     t 空行不显示行号，默认值</span><br><span class="line">-n ：行号的表示方法</span><br><span class="line">     ln 行号字段最左显示</span><br><span class="line">     rn 行号字段的最右显示，不加 0</span><br><span class="line">     rz 行号字段的最右显示，加 0</span><br><span class="line">-w ：行号字段的位数，默认六位</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="翻页查看"><a href="#翻页查看" class="headerlink" title="翻页查看"></a>翻页查看</h2><ul>
<li>more<br>  Space ：向后翻一页<br>  Enter ：向下滚动一行<br>  /字符串 ：当前页向下查询，n 继续查询<br>  :f ：显示出文件名以及目前显示的行数<br>  b/ctrl+b ：回翻，仅限文件，FIFO无效</li>
</ul>
<ul>
<li>less<br>   Space/PageDown ：向后翻一页<br>   PageUp ：向前翻一页<br>   ?字符串 ：当前页向上查询，n 继续查询<br>   N ：反向继续查询</li>
</ul>
<h2 id="数据选取"><a href="#数据选取" class="headerlink" title="数据选取"></a>数据选取</h2><p>head 取出前几行，默认显示十行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># head [-n num] file      取前 num 行</span><br><span class="line"># head [-n -num] file     取 num 行之前，第二个是减号ao（x</span><br></pre></td></tr></table></figure>

<p>tail 取后面几行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># tail [-n num] file      取后 num 行</span><br><span class="line"># tail [-n +num] file     取 num 行之后</span><br><span class="line">-f 持续监测，应对数据随时写入</span><br></pre></td></tr></table></figure>

<p>od 非纯文本文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># od [-t TYPE] 文件</span><br><span class="line">TYPE a ：默认字符输出</span><br><span class="line">     c ：ASCII 字符输出</span><br><span class="line">     dfox ：十进制 浮点数 八进制 十六进制</span><br></pre></td></tr></table></figure>

<h1 id="文件时间处理"><a href="#文件时间处理" class="headerlink" title="文件时间处理"></a>文件时间处理</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ls -l --time=?time filname</span><br></pre></td></tr></table></figure>

<ul>
<li>mtime modification time<br>内容数据更改时更新，ls 默认值</li>
<li>ctime status time<br>状态改变时更新，如权限与属性</li>
<li>atime access time<br>内容被取用访问时更新</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># touch [-acdmt] file</span><br><span class="line">-a ：修改 atime</span><br><span class="line">-c ：修改文件时间，文件不存不创建新文件</span><br><span class="line">-d ：修改 atime mtime，ctime 不变</span><br><span class="line">-m ：修改 mtime</span><br><span class="line">-t ：修改 atime mtime，ctime 记录当前时间，格式 YYMMDDhhmm</span><br></pre></td></tr></table></figure>

<p>默认将三个时间更新为当前，若文件不存在创建新文件</p>
<h1 id="文件类型查看"><a href="#文件类型查看" class="headerlink" title="文件类型查看"></a>文件类型查看</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># file filename</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>文件</tag>
        <tag>目录</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 文件系统</title>
    <url>/2019/09/18/Linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="回顾硬盘"><a href="#回顾硬盘" class="headerlink" title="回顾硬盘"></a>回顾硬盘</h1><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p>磁盘分区指定分区的起始与结束<strong>柱面</strong>，分区的柱面范围记录在第一个扇区的分区表里面</p><p>硬盘的第一个扇区中有主引导记录 <strong>MBR 446bytes</strong> 和分区表 <strong>partition table 64bytes</strong>，由于大小限制最多只能记录四条分区的记录，即主分区或扩展分区</p><ul>
<li>GPT + UEFI 则扫描整块磁盘上的分区，读取 EFI 分区里的引导文件，所以不再限制在扇区开头的 512bytes 中</li>
</ul><a id="more"></a>


<p>硬盘限制主分区和扩展分区最多可以有四个，操作系统限制扩展分区只能有一个，无法被格式化即无法作为数据访问，但扩展分区可以再分出逻辑分区</p>
<h2 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h2><p>文件系统通过格式化将 inode 和 block 规划好，并不再变动；不同文件系统格式化方法不同，所以不能相互识别利用</p>
<ul>
<li>inode 记录文件属性和此文件的数据所在的 block，一个文件占用一个 inode</li>
<li>block 实际记录文件内容，可占用多个</li>
<li>super block 记录此文件系统的整体信息，如 inode/block 总量使用量剩余量，文件系统的格式等</li>
</ul>
<p>碎片整理即因为文件写入的 block 过于离散，影响文件读取性能，需要将它们汇合到一起；这针对没有 inode 的 FAT 系统，Linux 的索引式文件系统基本不需要</p>
<hr>
<h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><p>当 inode 和 block 数量极大时不容易管理，Ext2 在格式化时区分为多个块组 block group，每个块组有独立的 inode/block/superblock 系统<br><img src="http://cn.linux.vbird.org/linux_basic/0230filesystem_files/ext2_filesystem.jpg" alt="avatar"><br>boot sector 启动扇区<br>在文件系统最前面，用于安装引导装载程序，这样不用覆盖整块硬盘唯一的 MBR，制作多重引导环境</p>
<p>data block 数据块<br>放置文件内容，每个 block 最多放置一个文件的数据，若有剩余空间则浪费；Ext2 支持 1KB 2KB 4KB 三种 block 大小，其决定最大总容量和最大单一文件容量</p>
<p>inodetable<br>至少记录访问模式 所有者和组 大小 ctime atime mtime 内容指向 文件特性，系统读取文件时会先分析 inode 所记录的权限与用户是否符合；每个文件占用一个inode，所以文件系统能创建的文件数量与 inode 数量有关<br>inode 大小固定为 128bytes，当文件较大则不足以记录下所有的 block 编号，故定义了 12 个直接，一个间接，一个双间接，一个三间接记录区</p>
<ul>
<li>用一个 block 来记录额外的编号，若依然不够则用一个 block 指出下一个记录编号的 block，依此最多三层；以 1KB 大小的 block 计算，12*1K + 256*1K + 256*256*1K + 256*256*256*1K = 16GB，即该文件系统最大容量</li>
</ul>
<p>superblock<br>一般为 1024bytes，除了第一个 blockgroup 中含有 superblock 外，后面的不一定含有，若有则为备份</p>
<p>文件系统描述 File system Dscription<br>描述每个 blockgroup 的开始与结束编号，说明每个区段介于哪个 block 之间</p>
<ul>
<li>区段指 superblock bitmap inodemap datablock</li>
<li>block bitmap 标记/修改某个 block 是否被使用</li>
<li>inode bitmap同上</li>
</ul>
<p>查询文件系统</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># df         &lt;== 查询目前挂载的设备</span><br><span class="line"># dumpe2fs [-bh] devname</span><br><span class="line">-b ：列出坏道部分</span><br><span class="line">-h ：仅列出 superblock 数据</span><br></pre></td></tr></table></figure>

<p>新增文件的过程</p>
<ul>
<li>检查目录是否有 w 和 x 权限</li>
<li>根据 inode bitmap 查找没有使用的 inode 编号并写入新文件的权限属性</li>
<li>根据 block bitmap 查找没有使用的 block 编号并写入实际数据，更新 inode 的指向</li>
<li>将 inode 和 block 信息更新到 inode bitmap 与 block bitmap，并更新 superblock</li>
</ul>
<p>由于 superblock inodebitmap blockbitmap 的数据经常变动，被称为 metadata 中间数据，而 inode table 和 data block 称为数据存放区域</p>
<p>异步处理 asynchronoly<br>提高效率：系统加载一个文件到内存后，若文件没有被改动，则被设置成 <strong>clean</strong>，更改过则为 <strong>dirty</strong>，系统不定时将 dirty 数据写回硬盘</p>
<ul>
<li>可以 sync 命令手动写回</li>
<li>正常关机会主动调用 sync 命令</li>
</ul>
<hr>
<h1 id="与目录树的关系"><a href="#与目录树的关系" class="headerlink" title="与目录树的关系"></a>与目录树的关系</h1><p>ext2 中的目录<br>新建目录时，会分配一个 inode 和至少一块 block，inode 记录目录的相关权限，属性，和分配到的 block 编号；block 记录此目录下的文件名与文件名的 inode 编号数据</p>
<p>ext2 中的文件<br>新建一般文件时，会分配一个 inode 和对应大小的 block 数量，由于只有 12 个直接指向，可能分配额外的 block 用来记录块编号</p>
<p><strong>inode 本身不记录文件名，而是在目录的 block 中，所以增删改文件名与目录的 w 权限有关。<br>当读取某个文件时务必会经过目录的 inode 和 block，然后找到文件的 inode 最终获得 block 中的数据<br>系统通过挂载信息获得根目录的 inode 号码，并据此获得根目录 block 内的文件名数据，再一层层向下</strong></p>
<hr>
<h1 id="日志文件系统"><a href="#日志文件系统" class="headerlink" title="日志文件系统"></a>日志文件系统</h1><p>inconsistent 状态<br>文件在写入文件系统时发生中断，未同步更新 metadata 导致 metadata 的内容和实际数据存放区不一致</p>
<p>避免 inconsistent 发生</p>
<ul>
<li>写入文件前先在日志记录块记录准备要写入的信息</li>
<li>实际写入，包括更新 metadata 的数据</li>
<li>在日志记录块中完成该文件的记录</li>
</ul>
<p>发生问题时通过检查日志记录块定位到文件，不必检查整个文件系统，Ext2 中没有文件日志系统，需要对比 metadata 区域和数据存放区</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>日志</tag>
        <tag>目录树</tag>
        <tag>存储器</tag>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 文件与目录补充</title>
    <url>/2019/09/11/Linux-%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<h1 id="默认权限"><a href="#默认权限" class="headerlink" title="默认权限"></a>默认权限</h1><ul>
<li>文件<br>默认没有可执行权限，即最大为 666</li>
<li>目录<br>默认有所有权限，即 777</li>
</ul>
<p>umask 指定目前用户新建文件或目录时的权限默认值</p>
<ul>
<li><p>查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># umask [-S]</span><br><span class="line">-S ：以字母显示默认权限，否则是数字</span><br></pre></td></tr></table></figure>

<p>其数字结果是该默认值要被拿掉的权限</p>
<a id="more"></a></li>
<li><p>设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># umask xyz</span><br></pre></td></tr></table></figure>

<p>root 默认是 022，一般用户是 002<br>用字母进行计算更准确，如 (-rw-rw-rw-) - (——–wx) = -rw-rw-r–,而非 666 - 003 = 663</p>
</li>
</ul>
<h1 id="隐藏属性"><a href="#隐藏属性" class="headerlink" title="隐藏属性"></a>隐藏属性</h1><h2 id="chattr"><a href="#chattr" class="headerlink" title="chattr"></a>chattr</h2><p>设置文件的隐藏属性<br>仅在 Ext2/Ext3 的文件系统生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># chattr [+-=][ASacdistu] dirname/filname</span><br><span class="line">+ ：仅增加某一个参数</span><br><span class="line">- ：仅减少某一个参数</span><br><span class="line">= ：仅有后面指定的参数</span><br><span class="line"></span><br><span class="line">A ：访问此文件/目录时，访问时间 atime 将不会被修改</span><br><span class="line">S ：对文件的修改将 同步 写入磁盘</span><br><span class="line">a ：root 限定，只能增加数据不能删改</span><br><span class="line">c ：文件将被自动压缩，读取时自动解压，存储时先压缩再存储</span><br><span class="line">d ：dump 程序被执行时，该文件/目录不会被 dump 备份</span><br><span class="line">i ：root 限定，该文件无法被增删改和设置连接</span><br></pre></td></tr></table></figure>

<h2 id="lsattr"><a href="#lsattr" class="headerlink" title="lsattr"></a>lsattr</h2><p>显示文件的隐藏属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># lsattr [-adR] filname/dirname</span><br><span class="line">-a 包括隐藏文件</span><br><span class="line">-d 目录属性而非内容</span><br><span class="line">-R 递归，子目录数据也显示</span><br></pre></td></tr></table></figure>

<h1 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h1><h2 id="SUID-4-u-s"><a href="#SUID-4-u-s" class="headerlink" title="SUID 4 u+s"></a>SUID 4 u+s</h2><p>SetUID 只对文件有效，文件所有者的 x 权限为 s</p>
<ul>
<li>仅对二进制程序有效，对于 shell script 无效，靠看其根本的二进制文件设置</li>
<li>执行者对改程序有 x 权限 <font color="#D3D3D3">废话</font></li>
<li>仅在执行过程 run-time 中有效</li>
<li>执行者将拥有 owner 的权限</li>
</ul>
<p>例：/etc/shadow 记录了所有账号的密码，<strong>-rwsr-xr-x root root</strong> 仅有 root 可读可强制写入，但用户也能修改自己的密码</p>
<h2 id="SGID-2-g-s"><a href="#SGID-2-g-s" class="headerlink" title="SGID 2 g+s"></a>SGID 2 g+s</h2><p>SetGID 用户组的 x 权限为 s<br>文件同 SUID<br>目录</p>
<ul>
<li>用户对此目录有 r 与 x 权限时可进入</li>
<li>用户在此目录下的有效用户组将变成该目录的用户组</li>
<li>若在此目录下有 w 权限，则新文件的用户组和此目录的用户组相同</li>
<li><h2 id="SBIT-1-o-t"><a href="#SBIT-1-o-t" class="headerlink" title="SBIT 1 o+t"></a>SBIT 1 o+t</h2>StickyBit 只对目录有效，other 的 x 的权限为 x，仅用户自己和 root 有权利删除该目录下的文件/目录</li>
</ul>
<h1 id="查询文件"><a href="#查询文件" class="headerlink" title="查询文件"></a>查询文件</h1><h2 id="脚本文件名"><a href="#脚本文件名" class="headerlink" title="脚本文件名"></a>脚本文件名</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># which [-a] command</span><br><span class="line">-a 列出所有 PATH 目录中可以找到的同名命令，否者显示找到的第一个</span><br></pre></td></tr></table></figure>

<p>根据 PATH 环境变量规范的路径查找，查不到 bash 内置的命令</p>
<h2 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h2><ul>
<li><p>whereis寻找特定文件 数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># whereis [-bmsu] filname/filname</span><br><span class="line">-b 仅找二进制文件</span><br><span class="line">-m 仅找说明文件 manual 路径下的文件</span><br><span class="line">-s 仅找 source 源文件</span><br><span class="line">-u 其它特殊文件</span><br></pre></td></tr></table></figure>

<p>查找文件，故不在 PATH 中也能找到；利用数据库，速度快但结果有延迟</p>
</li>
<li><p>locate 数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># locate [-ir] keyword</span><br><span class="line">-i 忽略大小写</span><br><span class="line">-r 允许接正则表达式</span><br></pre></td></tr></table></figure>

<p>可以只输入文件的部分名称(包括路径中)，根据 /var/lib/mlocate/ 中的数据，默认每天更新一次可能有延迟，可手动 updatedb 更新</p>
</li>
<li><p>find 硬盘</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># find [PATH] [option] [action]</span><br><span class="line">与时间有关的参数</span><br><span class="line">-mtime n 在 n 天前的 一天之内 被更改过的文件，前24小时即 0 </span><br><span class="line">-mtime +n 在 n 天之前被更改过的文件，不含本身 </span><br><span class="line">-mtime -n 在 n 天之内被更改过的文件，含本身 </span><br><span class="line">-newer file 列出比 file 更新的文件</span><br><span class="line"></span><br><span class="line">与用户或用户组名有关的参数</span><br><span class="line">-uid n 即 UID，记录在 /etc/passwd</span><br><span class="line">-gid n 即 GID，记录在 /etc/group</span><br><span class="line">-user name 用户账号名称</span><br><span class="line">-group name 用户组名</span><br><span class="line">-nouser 所有者不在 /etc/passwd 的文件</span><br><span class="line">-nogroup 所有用户组不在 /etc/passwd 的文件</span><br><span class="line"></span><br><span class="line">与文件权限及名称有关的参数</span><br><span class="line">-name filename 根据文件名查询</span><br><span class="line">-size [+-]SIZE 查找比 SIZE 大或小的文件 k代表1024bytes</span><br><span class="line">-type TYPE 查找文件类型为 TYPE 的；一般文件 f，设备文件 b c，目录 d，连接文件 1，socket s，FIFO p</span><br><span class="line">-perm mode 文件权限刚好是 mode 的文件，类似 chmod 的属性值</span><br><span class="line">-perm +-mode 文件权限全部包含/包含任意 mode 的文件</span><br><span class="line">    例</span><br><span class="line">    #find /bin /sbin -perm +6000</span><br><span class="line">    查找/bin /sbin 两个目录下具有 SUID SGID 的文件</span><br><span class="line">    </span><br><span class="line">其他操作</span><br><span class="line">-exec command 后面可以接其他命令处理查到的结果</span><br><span class="line">    #find / -perm +7000 -exec ls -l &#123;&#125;\;</span><br><span class="line">    &#123;&#125; 代表 find 查找到的内容，\; 转义 本身代表额外命令结束</span><br><span class="line">利用通配符查找</span><br><span class="line">    #find /etc -name &apos;*httpd*&apos;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>文件</tag>
        <tag>目录</tag>
        <tag>属性权限</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 正则和文件格式化</title>
    <url>/2019/11/28/Linux-%E6%AD%A3%E5%88%99%E5%92%8C%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
    <content><![CDATA[<p>正则表达式即以行为单位，通过特殊符号查询删除替换某特定字符串的方法，在支持的工具里通用</p><h1 id="基础正则表达式"><a href="#基础正则表达式" class="headerlink" title="基础正则表达式"></a>基础正则表达式</h1><p><strong>语系</strong><br>避免编码造成的区别，建议使用特殊符号</p><table>
<thead>
<tr>
<th align="center">特殊符号</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">:alnum:</td>
<td align="center">A-Z a-z 0-9</td>
</tr>
<tr>
<td align="center">:alpha:</td>
<td align="center">A-Z a-z</td>
</tr>
<tr>
<td align="center">:upper:</td>
<td align="center">A-Z</td>
</tr>
<tr>
<td align="center">:lower:</td>
<td align="center">a-z</td>
</tr>
<tr>
<td align="center">:digit:</td>
<td align="center">0-9</td>
</tr>
</tbody></table><a id="more"></a>


<p><strong>字符</strong></p>
<table>
<thead>
<tr>
<th align="center">RE</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ˆword</td>
<td align="center">待查找字符串在首行</td>
</tr>
<tr>
<td align="center">word$</td>
<td align="center">待查找字符串在尾行</td>
</tr>
<tr>
<td align="center">.</td>
<td align="center">一定有一个任意字符</td>
</tr>
<tr>
<td align="center">\</td>
<td align="center">转义</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">重复的零到无穷个前一个字符</td>
</tr>
<tr>
<td align="center">[list]</td>
<td align="center">list 中任意一个</td>
</tr>
<tr>
<td align="center">[n1-n2]</td>
<td align="center">要选取的字符范围</td>
</tr>
<tr>
<td align="center">[ˆlist]</td>
<td align="center">上上个取反</td>
</tr>
<tr>
<td align="center">{n,m}</td>
<td align="center">连续 n 到 m 个前一个字符</td>
</tr>
<tr>
<td align="center">{n,}</td>
<td align="center">连续 n 个以上的前一个字符</td>
</tr>
</tbody></table>
<p><code># grep -n &#39;go\{2,3}g&#39; regular_express.txt</code> </p>
<p><strong>sed 工具</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># sed [-nefr] [动作]</span><br><span class="line">-n 安静模式，只显示 sed 处理过的列/操作</span><br><span class="line">默认列出所有 stdin 的数据</span><br><span class="line">-e 在命令行模式上进行 sed  的动作编辑</span><br><span class="line">-f 将 sed 的动作写入一个文件，可使用 -f filename 执行</span><br><span class="line">-r 使用扩展型正则表达式的语法</span><br><span class="line">-i 直接修改读取的文件内容而不由屏幕输出</span><br><span class="line">[n1],[n2] 动作 选择进行动作的行数，在 n1 到 n2 行之间进行</span><br><span class="line"></span><br><span class="line">function 参数</span><br><span class="line">a 新增，a 后的字符串在目前的下一行新增一行出现</span><br><span class="line">c 替换，c 后的字符串替换 n1,n2 之间的行</span><br><span class="line">d 删除</span><br><span class="line">i 插入，在目前的上一行新增一行出现</span><br><span class="line">p 打印，通常与 sed -n 用</span><br><span class="line">s 替换，通常接正则表达式</span><br></pre></td></tr></table></figure>

<p>部分数据的查找并替换<br><code># sed &#39;s/旧字符串/新字符串/g&#39;</code></p>
<p>例子🌰</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nl /etc/passwd | sed &apos;3,$d&apos;</span><br><span class="line">删除第 3 到最后一行</span><br><span class="line">nl /etc/passwd | sed &apos;2a text1...\</span><br><span class="line">&gt; text2&apos;</span><br><span class="line">增加 2 行字符串</span><br><span class="line">nl /etc/passwd | sed -n &apos;2,3p&apos;</span><br><span class="line">仅显示 2-3 行，注意 -n </span><br><span class="line">/sbin/ifconfig eth0 | grep &apos;inet addr&apos; | sed &apos;s/ˆ.*addr://g&apos; | sed &apos;s/Bcast.*$//g&apos;</span><br></pre></td></tr></table></figure>

<p>sed 可以直接修改文件内容，使用 -i</p>
<h1 id="文件的格式化"><a href="#文件的格式化" class="headerlink" title="文件的格式化"></a>文件的格式化</h1><p><strong>printf</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># printf &apos;打印格式&apos; 实际内容</span><br><span class="line">\a 警告音</span><br><span class="line">\b backspace 退格键</span><br><span class="line">\f 清除屏幕</span><br><span class="line">\n 输出新一行</span><br><span class="line">\r enter 回车键</span><br><span class="line">\t  水平 [tab]</span><br><span class="line">\v 垂直 [tab]</span><br><span class="line">\xNN 转换两位数 NN 数值为字符</span><br></pre></td></tr></table></figure>

<p><strong>awk</strong><br>处理每一行的字段内的数据，默认分隔符是空格键或 [tab] 键</p>
<p>内置变量</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NF</td>
<td align="center">每行的字段总数</td>
</tr>
<tr>
<td align="center">NR</td>
<td align="center">目前是第几行</td>
</tr>
<tr>
<td align="center">FS</td>
<td align="center">目前的分隔符</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># awk &apos;条件类型1&#123;动作1&#125; 条件类型2&#123;动作2&#125; ...&apos; filename</span><br></pre></td></tr></table></figure>

<h1 id="文件比较工具"><a href="#文件比较工具" class="headerlink" title="文件比较工具"></a>文件比较工具</h1><p>以行为单位，用于同一文件新旧版本的区别，也可以比较目录，找出 only in 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># diff [-bBi] fromfile tofile</span><br><span class="line">fromfile 欲比较的文件</span><br><span class="line">tofile 基准比较文件</span><br><span class="line">-b 一行中的多个空白视为一个</span><br><span class="line">-B 忽略空白行</span><br><span class="line">-i 忽略大小写</span><br></pre></td></tr></table></figure>

<p>补丁文件，使用 diff 制作出来的比较文件扩展名为 .patch，以行为单位新文件看到 - 会删除，+ 会加入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># patch -R -pN &lt; patch_file</span><br><span class="line">-R 还原，不加则为恢复</span><br><span class="line">-p 取消 N 层目录</span><br><span class="line"></span><br><span class="line">patch -p0 &lt; passwd.patch</span><br></pre></td></tr></table></figure>

<p>以字节为单位，用于比较二进制文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cmp [-s] file1 file2</span><br><span class="line">-s 列出所有不同点的字节处</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>文件</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 文件系统操作</title>
    <url>/2019/09/28/Linux-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="df-du"><a href="#df-du" class="headerlink" title="df du"></a>df du</h1><p>根据 super block 中的信息</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># df [-ahikHTm] [filenamedirname]</span><br><span class="line">-a : 列出所有文件系统，比默认多显示如内存中的</span><br><span class="line">-k : 以 KB 显示各文件系统</span><br><span class="line">-m : 同上</span><br><span class="line">-h : 自行以易阅读的单位显示</span><br><span class="line">-H : 以 1M=1000K 计算</span><br><span class="line">-T : 增加显示文件系统名称 type</span><br><span class="line">-i : 以 inode 数量显示</span><br></pre></td></tr></table></figure><a id="more"></a>


<p>/proc 这个挂载点在内存中，没有占用任何硬盘空间故大小为 0<br>/dev/shm 是利用内存虚拟的磁盘空间</p>
<hr>
<p>通过搜索文件计算每个的大小然后累加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># du [-ahskm] filenamedirname</span><br><span class="line">-a : 列出所有文件和目录容量，默认仅统计目录</span><br><span class="line">-hkm : 同 df</span><br><span class="line">-s : 仅显示最后加总的值</span><br><span class="line">-S : 类似 -s 不包括子目录的大小</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># du –hs xxx          显示目录总大小，不会列出目录中的每一个文件</span><br><span class="line"># du –hs xxx/*        列出 xxx 下每个目录和文件所占容量</span><br></pre></td></tr></table></figure>

<blockquote>
<p>du 能看到的文件是当前存在没有被删除的，删除一个文件的时候，这个文件不是马上就在文件系统当中消失了，而是暂时消失了，当所有程序都不用时，才会根据OS的规则释放掉已经删除的文件<br><strong>不要直接执行 du 命令，它会遍历并列出目录下的所有文件</strong></p>
</blockquote>
<h1 id="连接文件"><a href="#连接文件" class="headerlink" title="连接文件"></a>连接文件</h1><p>hard link 硬连接/实际连接<br>新建一个文件名连接到 inode 上</p>
<ul>
<li>文件内容和 inode 有关</li>
<li>通过文件名指向到对应 inode 读取文件</li>
</ul>
<p>所以 hard link 和源文件除了文件名，相关信息完全一样，若将其中一个文件删除，因为 inode 还有连接故实际还存在<br>不能跨文件系统，不能连接到目录（因为会产生大量连接造成开销）</p>
<p>symbolic link 符号连接/快捷方式<br>创建一个独立文件让数据读取指向连接的文件名<br>所以源文件删除后 symbolic link 将无法打开，两个文件指向不同的 indoe<br>目录快捷方式时将同步删除等，新建目录连接至少产生三个：本身 . .. 而上层目录连接数会加一，新目录连接数为二</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ln [-sf] 源文件 目标文件</span><br><span class="line">-s ：symbolic link，不加参数为 hard link</span><br><span class="line">-f ：目标文件若存在则先删除再创建</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>文件系统</tag>
        <tag>连接文件</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 磁盘管理</title>
    <url>/2019/10/10/Linux-%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="磁盘分区程序"><a href="#磁盘分区程序" class="headerlink" title="磁盘分区程序"></a>磁盘分区程序</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># fdisk [-l] 设备名称</span><br><span class="line">-l ：输出对应设备的所有的分区，未指定设备则显示系统内能找到的所有分区</span><br><span class="line"></span><br><span class="line">相关命令 m 查看</span><br><span class="line">cylinder 可以通过 +sizeM 让系统自动分配</span><br><span class="line"></span><br><span class="line"># partprobe     &lt;==强制内核重新读取分区表（不重启更新分区表信息）</span><br></pre></td></tr></table></figure><p>无法处理 2TB 以上的磁盘分区，使用 parted 命令<br>设备名称不应该加上数字如 /dev/hdc1 因为分区针对的是整个硬盘设备</p><a id="more"></a>


<h1 id="磁盘格式化"><a href="#磁盘格式化" class="headerlink" title="磁盘格式化"></a>磁盘格式化</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mkfs [-t 文件系统格式] 设备文件名</span><br></pre></td></tr></table></figure>

<h1 id="磁盘检验"><a href="#磁盘检验" class="headerlink" title="磁盘检验"></a>磁盘检验</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># fsck [-t 文件系统] [-ACay] 设备名称</span><br><span class="line">-t ：Linux 会通过 super block 分辨文件系统，可省略</span><br></pre></td></tr></table></figure>

<p>检查文件系统是否出错，可能会造成部分损坏，故执行 fsck 时被检查分区需要在卸载状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># badblocks [-svw] 设备名称</span><br></pre></td></tr></table></figure>

<p>检查扇区是否有坏轨</p>
<h1 id="磁盘挂载与卸载"><a href="#磁盘挂载与卸载" class="headerlink" title="磁盘挂载与卸载"></a>磁盘挂载与卸载</h1><p>被挂载的目录理论上应该是空目录，否则原有内容会隐藏到新分区卸载</p>
<blockquote>
<p>放弃磁盘，这部分还是面向谷歌吧x</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>存储器</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 性能-库表</title>
    <url>/2020/09/11/MySQL-%E6%80%A7%E8%83%BD-%E5%BA%93%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><blockquote>
<p>更小通常更好 选择不会超过范围的最小类型</p>
</blockquote><blockquote>
<p>简单更好 简单数据类型操作代价低</p>
</blockquote><blockquote>
<p>尽量避免 NULL 值 索引会变得复杂，但不要极端</p>
</blockquote><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">存储空间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">tinyint</td>
<td align="center">8 bit</td>
</tr>
<tr>
<td align="center">smallint</td>
<td align="center">16 bit</td>
</tr>
<tr>
<td align="center">mediumint</td>
<td align="center">24 bit</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">32 bit</td>
</tr>
<tr>
<td align="center">bigint</td>
<td align="center">64 bit</td>
</tr>
</tbody></table><a id="more"></a>



<p><code>UNSIGNED</code> 属性不影响性能。</p>
<p>整数计算一般（某些聚合函数使用 decimal double）使用 64 位，与类型定义和环境无关。</p>
<p>为整数类型指定宽度（<code>int(10)</code>）不会改变存储和计算的方式，不会限制值的合法范围。</p>
<h2 id="实数类型"><a href="#实数类型" class="headerlink" title="实数类型"></a>实数类型</h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">存储空间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">float</td>
<td align="center">4 byte</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">8 byte</td>
</tr>
<tr>
<td align="center">decimal</td>
<td align="center">每 4 byte / 9 个数字<br>小数点 1 byte</td>
</tr>
</tbody></table>
<p>浮点计算内部使用 double 类型。</p>
<p>decimal 类型计算由 MySQL 自身实现，速度不如浮点；可以用来存储比 bigint 大的整数；数据量大时考虑用 bigint 代替 decimal 计算（乘以倍数后存储）。</p>
<h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><p><em>注意字符串长度定义是字符数，多字节字符集需要更多存储空间</em></p>
<p><strong>varchar 和 char</strong></p>
<p>varchar 使用额外字节记录字符串的长度（&lt;=255 一字节 否则两字节），如 varchar(1000) 需要 1002 字节。若 update 使得字符串变长，MyISAM 将行拆成不同的片段存储，InnoDB 则分裂页使行可以放入。用更长的列存储短字符串虽然空间开销一样，但会消耗更多内存。</p>
<ul>
<li>字符串列的最大长度比平均长度大很多；</li>
<li>列的更新很少；</li>
<li>使用了每个字符字节数不同的复杂字符集（如 UTF-8）；</li>
</ul>
<p>char 会删除值末尾的空格，并根据需要填充空格以方便比较。因为定长，不宜产生碎片，没有额外字节。</p>
<ul>
<li>较短字符串（如 char(1) Y/N）；</li>
<li>经常变更的数据；</li>
<li>所有值接近一个长度；</li>
</ul>
<p><strong>blob 和 text</strong></p>
<p>blob 是 smallblob 的同义词，采用二进制方式存储，没有排序规则或字符集；text 是smalltext 的同义词，采用字符方式存储，有排序规则和字符集（两者仅有的不同）。</p>
<p>blob 或 text 值太大时，每个值会通过行内 1～4 个字节的指针指向存储区域中实际的值。</p>
<p><strong>enum</strong></p>
<p>MySQL 内部将每个值在列表中的位置保存为整数，并在 .frm 文件中保存映射表。</p>
<p>enum 按照定义时的顺序（即存储的整数）而非字符串进行排序。显示指定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select e from enum_table order by field(e, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;);</span><br></pre></td></tr></table></figure>

<p>某些情况下，char/varchar 列与枚举列进行连接可能比直接连接 char/varchar 列更慢。（采用整数主键而避免采用基于字符串的值进行关联）。</p>
<h2 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h2><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">存储空间</th>
<th align="center">时区</th>
<th align="center">格式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">datetime</td>
<td align="center">8 bit (1001 - 9999)</td>
<td align="center">无关</td>
<td align="center">YYYYMMDDHHMMSS 整数</td>
</tr>
<tr>
<td align="center">timestamp</td>
<td align="center">4 bit (1970 - 2038)</td>
<td align="center">依赖</td>
<td align="center">UNIX 时间戳</td>
</tr>
</tbody></table>
<p>比秒更小的粒度可以考虑 bigint （时间戳）或 double （秒后小数部分）。</p>
<h2 id="位数据类型"><a href="#位数据类型" class="headerlink" title="位数据类型"></a>位数据类型</h2><p>bit 在 MySQL 中作为字符串类型，而非数字类型；但在数字上下文中将是位字符串转换成的数字：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> bittest(a <span class="built_in">bit</span>(<span class="number">8</span>));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> bittest <span class="keyword">values</span>(b<span class="string">'00111001'</span>);</span><br><span class="line"><span class="keyword">select</span> a, a+<span class="number">0</span> <span class="keyword">from</span> bittest;</span><br><span class="line"><span class="comment">-- a 9</span></span><br><span class="line"><span class="comment">-- a+0 57</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>set 多选字符串数据类型，适合存储“多个值”。</p>
<p>设定set的格式：<br>　　字段名称 SET(‘选项1’, ‘选项2’, …, ‘选项n’)</p>
<p>set 的每个选项值也对应一个数字，依次是1，2，4，8，16…，最多有64个选项。<br>使用的时候，可以使用 set 选项的字符串本身（多个选项用逗号分隔），也可以使用多个选项的数字之和（比如：1+2+4=7）。</p>
</blockquote>
<hr>
<h1 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h1><h2 id="范式优缺点"><a href="#范式优缺点" class="headerlink" title="范式优缺点"></a>范式优缺点</h2><ul>
<li>更新操作比范式化快</li>
<li>重复数据很少或没有，修改更少的数据</li>
<li>表更小，执行操作更快</li>
<li>检索时更少需要 distinct 或 group by 语句</li>
</ul>
<ul>
<li>需要关联，产生额外代价</li>
<li>列存放在不同的表中，可能使一些索引无效</li>
</ul>
<h2 id="反范式优缺点"><a href="#反范式优缺点" class="headerlink" title="反范式优缺点"></a>反范式优缺点</h2><ul>
<li>避免关联，顺序 I/O （与引擎有关）。</li>
<li>使用更有效的索引</li>
</ul>
<ul>
<li>……略</li>
</ul>
<h2 id="混用范式化和反范式化"><a href="#混用范式化和反范式化" class="headerlink" title="混用范式化和反范式化"></a>混用范式化和反范式化</h2><p>从父表冗余一些数据到子表以方便排序。</p>
<p>缓存衍生值，避免性价比不高的子查询。</p>
<hr>
<h1 id="缓存表和汇总表"><a href="#缓存表和汇总表" class="headerlink" title="缓存表和汇总表"></a>缓存表和汇总表</h1><p><em>更快的读，更慢的写</em></p>
<blockquote>
<p>缓存表(Cache Table)指那些包含能够轻松从Schema中获得的数据的表（但每次获取的速度慢），即表中的数据是逻辑冗余(Logically Redundant)。</p>
<p>汇总表(Summary/Roll-up Table)是说包含通过聚合函数得到的数据的表，例如表中数据是通过GROUP BY得到的。对优化搜索和检索查询语句很有效。</p>
</blockquote>
<blockquote>
<p>最常见的场景就是报表等统计工作。生成这些统计数据要扫描大量数据，实时计算成本很高且很多时候没有必要。而且查询这些数据还要加大量组合索引才能提高性能，然而这些索引又会对平时的更新和插入等操作造成影响。于是常用技术就是添加中间表到其他引擎(利用MyISAM更小的索引和全文检索能力)，甚至其他系统(Lucene或Sphinx)。</p>
</blockquote>
<h2 id="计数表"><a href="#计数表" class="headerlink" title="计数表"></a>计数表</h2><p>解决独立表并发问题可以建多行，根据id随机更新，然后统计时 sum() 。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> hit_counter(</span><br><span class="line">     slot <span class="built_in">tinyint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</span><br><span class="line">     cnt <span class="built_in">int</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> hit_counter <span class="keyword">SET</span> cnt = cnt + <span class="number">1</span> <span class="keyword">WHERE</span> slot = <span class="keyword">RAND</span>() * <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(cnt) <span class="keyword">FROM</span> hit_counter;</span><br></pre></td></tr></table></figure>

<p>可以按天或小时单独建行，旧时间可定时任务合并到统一的一行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> daily_hit_counter(</span><br><span class="line">     <span class="keyword">day</span> <span class="built_in">date</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">     slot <span class="built_in">tinyint</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</span><br><span class="line">     cnt <span class="built_in">int</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">     primary <span class="keyword">key</span>(<span class="keyword">day</span>, slot)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="加速-alert-table-操作"><a href="#加速-alert-table-操作" class="headerlink" title="加速 alert table 操作"></a>加速 alert table 操作</h1><p>先禁用（删除）非唯一索引，导入数据之后重新启用索引。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 性能-索引</title>
    <url>/2020/09/13/MySQL-%E6%80%A7%E8%83%BD-%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h1><p>索引在存储引擎层实现。</p><p>扫描索引本身很快，但按索引顺序读取数据的速度通常要比顺序的全表扫描慢，因为基本是随机 I/O。</p><h2 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B-Tree 索引"></a>B-Tree 索引</h2><p><em>此处的 B 是平衡，而非二叉（演化自 AVLTree ）</em></p><p>B-Tree 作为术语使用（即使是 T-Tree 结构），多数存储引擎其实是 B+Tree 。</p><p>索引对多个值进行排序的依据是 create table 中定义索引时列的顺序。</p><a id="more"></a>




<p>适合如下查询：</p>
<ul>
<li><p>匹配全值，即所有列；</p>
</li>
<li><p>匹配最左前缀，即索引第一列；</p>
</li>
<li><p>匹配列前缀，即列值的开头部分；</p>
</li>
<li><p>匹配范围值；</p>
</li>
<li><p>精确匹配某一列范围匹配另一列；</p>
</li>
<li><p>仅访问索引。</p>
</li>
</ul>
<p>因为索引树的节点有序，还可用于查询中的 order by 操作。</p>
<p>限制：</p>
<ul>
<li>必须从索引的最左列 / 列的最左开始查找；</li>
<li>不能跳过索引中的列；</li>
<li>范围查询右边的所有列无法使用索引，<code>where last_name = &#39;S&#39; and first_name like &#39;J%&#39; and ...</code> 只能使用索引的前两项（<code>key(last_name, first_name, ...)</code>）。</li>
</ul>
<h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><p>仅 Memory 引擎显式支持。</p>
<p><strong>创建自定义哈希索引</strong></p>
<p>InnoDB 引擎中，某些索引值使用非常频繁时，会在内存中基于 B-Tree 索引再创建一个哈希索引。类似，在 B-Tree 基础上创建一个伪哈希索引，使用哈希值而不是键值本身进行索引查找（在 where 子句中使用哈希函数）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">url</span> <span class="keyword">where</span> <span class="keyword">url</span>=<span class="string">"http://..."</span>;</span><br><span class="line"><span class="comment">-- 删除 url 列的索引，新增被索引的 url_crc 列，使用 CRC32 做哈希。</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">url</span> <span class="keyword">where</span> <span class="keyword">url</span>=<span class="string">"http://..."</span> <span class="keyword">and</span> url_crc=<span class="keyword">CRC32</span>(<span class="string">"http://..."</span>);</span><br><span class="line"><span class="comment">-- 缺陷：通过手动/触发器在插入和更新时维护 url_crc 列</span></span><br></pre></td></tr></table></figure>

<p>ps：SHA1() 和 MD5() 计算出的哈希值过长，代价较大，除非最大限度消除冲突。</p>
<p><strong>处理哈希冲突</strong></p>
<p>数据表非常大时，考虑自己实现一个 64 位返回整数的哈希函数（比如截取 MD5() 的一部分）。</p>
<p>使用哈希索引进行查询时，必须在 where 子句中包含常量值：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 错误！哈希冲突可能导致返回多条记录。</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="keyword">url</span> <span class="keyword">where</span> url_crc=<span class="keyword">CRC32</span>(<span class="string">"http://..."</span>);</span><br></pre></td></tr></table></figure>

<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p><strong>空间数据索引（R-Tree）</strong></p>
<p>MyISAM 支持空间索引，用作地理数据存储。</p>
<p><strong>全文索引</strong></p>
<p>适用于 match against 操作而非 where 条件操作。</p>
<hr>
<h1 id="索引策略"><a href="#索引策略" class="headerlink" title="索引策略"></a>索引策略</h1><p>非常小的表使用简单的全表扫描可能更高效。</p>
<h2 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h2><p>索引列不能是表达式的一部分，或是函数的参数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 错误！</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> actor <span class="keyword">where</span> <span class="keyword">id</span> + <span class="number">1</span> = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h2 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h2><p>对于很长的字符串，通常索引开始的部分字符，可以大大节约索引空间，但也会降低索引的选择性。</p>
<p>索引的选择性：不重复的索引值（也称为基数，cardinality）和数据表的记录总数（#T）的比值，范围从 1/#T 到 1 之间，选择性越高则查询效率越高，因为选择性高的索引可以让 MySQL 在查找时过滤掉更多的行。</p>
<p>前缀的基数应该接近完整列的基数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> city) / <span class="keyword">count</span>(*) <span class="keyword">from</span> city_demo;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(city, <span class="number">3</span>)) / <span class="keyword">count</span>(*) <span class="keyword">as</span> sel3,</span><br><span class="line">-&gt; <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(city, <span class="number">4</span>)) / <span class="keyword">count</span>(*) <span class="keyword">as</span> sel4,</span><br><span class="line">-&gt; <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(city, <span class="number">5</span>)) / <span class="keyword">count</span>(*) <span class="keyword">as</span> sel5,</span><br><span class="line">-&gt;<span class="keyword">from</span> city_demo;</span><br><span class="line"><span class="comment">-- 平均选择性无法发现数据分布的不均匀。</span></span><br></pre></td></tr></table></figure>

<p>创建前缀索引（MySQL 无法使用前缀索引做 order by 和 group by ，也无法做覆盖扫描）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">alert table city_demo add key(city(7));</span><br></pre></td></tr></table></figure>

<h2 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h2><p>一个多列索引与多个列索引 MySQL 在解析执行上是不一样的，如果在 explain 中看到有索引合并，应该好好检查一下查询的表和结构是不是已经最优：</p>
<ul>
<li>当出现服务器对多个索引做交互操作时（通常有多个 and 条件），通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引；</li>
<li>当服务器需要对多个索引做联合操作时（通常有多个 or 条件），通常需要耗费大量CPU和内存资源在算法的缓存、排序和合并操作上。特别是当其中有些索引的选择性不高，需要合并扫描返回的大量数据的时候。</li>
</ul>
<h2 id="合适的索引列顺序（B-Tree）"><a href="#合适的索引列顺序（B-Tree）" class="headerlink" title="合适的索引列顺序（B-Tree）"></a>合适的索引列顺序（B-Tree）</h2><p>当不需要考虑排序和分组时，通常将选择性最高的列放在前面，此时索引只用于优化 where 条件的查找。</p>
<p>性能不只是依赖于所有索引列的选择性（整体基数），也和查询条件的具体值的分布有关。和选择前缀索引的长度需要考虑的地方一样，可能需要根据那些运行频率最高的查询来调整索引列的顺序，让这种情况下索引的选择性最高。</p>
<p>不要假设平均情况下的性能也能代表特殊情况下的性能，特殊情况可能会摧毁整个应用的性能（当使用前缀索引时，在某些条件值的基数比正常值高的时候）。</p>
<h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>一种数据存储方式，InnoDB 中实际是在同一个结构中保存了 B-Tree 索引和数据行。因为数据行不能同时存放在两个地方，所以一个表只能有一个聚簇索引（但覆盖索引可模拟）。</p>
<p>InnoDB 使用主键聚集数据，若没有定义主键则选择一个唯一的非空索引代替，若仍没有则隐式定义一个主键作为聚簇索引；二级索引（非聚簇索引）的叶子节点是引用行的主键列（行指针并非指向行的物理地址而是主键值），即二级索引访问需要两次 B-Tree 查找，不过免去了行移动或页分裂时二级索引的维护工作。</p>
<p>一些注意点：</p>
<ul>
<li>聚簇索引提高 I/O 密集型应用性能，若数据都放在内存里则没有多大优势；</li>
<li>插入速度严重依赖插入顺序，最好按主键的顺序插入（比如自增长），若随机插入使用 optimize table 重新组织一下表；</li>
<li>更新局促索引列的代价很高，每个被更新的行要移动到新位置；</li>
<li>插入新行，或主键更新导致行移动时，可能有页分裂问题（内碎片和占用更多磁盘空间）；</li>
</ul>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>索引中包含所有需要查询的字段的值，不需要回表查询；因为要存储值，所以只能用 B-Tree 索引。</p>
<p>发起索引覆盖查询时，explain 的 extra 列为 using index 。</p>
<p>使用<strong>延迟关联</strong>解决索引无法覆盖问题：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> actor = <span class="string">'SEAB CARREY'</span> <span class="keyword">AND</span> title <span class="keyword">like</span> <span class="string">'%APPOLO%'</span></span><br><span class="line"><span class="comment">-- 1.没有覆盖全部列的索引；2.like操作只有在匹配左前缀时才能使用索引。</span></span><br></pre></td></tr></table></figure>

<p>建立 (actor, title, prod_id) 索引。先在子查询中找到匹配的 prod_id ，然后在外层查询中匹配获取所有列值。优化效果取决于 where 条件匹配返回的行数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products </span><br><span class="line">    <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> prod_id <span class="keyword">FROM</span> products </span><br><span class="line">          <span class="keyword">WHERE</span> actor = <span class="string">'SEAB CARREY'</span> <span class="keyword">AND</span> title <span class="keyword">like</span> <span class="string">'%APPOLO%'</span>)</span><br><span class="line">	<span class="keyword">AS</span> t1 <span class="keyword">ON</span> (t1.prod_id = products.prod_id)</span><br></pre></td></tr></table></figure>

<p>当符合 where 条件的数据数量远小于 actor 过滤出的数据数量的时效率尤其高。因为根据子查询的where过滤出数据之后才与外层查询关联，而后者使用 actor 读取出数据之后，再用 title 进行关联。</p>
<h2 id="使用索引扫描做排序"><a href="#使用索引扫描做排序" class="headerlink" title="使用索引扫描做排序"></a>使用索引扫描做排序</h2><p>使用索引扫描排序时，explain 的 type 列为 index 。MySQL 可以使用一个索引既满足排序，又满足查找。只有当索引的列顺序和 order by 子句顺序一致，且列的排序方向（倒序或正序）都一样时，才能用索引对结果做排序。</p>
<p>order by 子句需要满足索引的最左前缀要求，除非前导列制定为常量：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">key col_key (col1, col2, col3)</span><br><span class="line"></span><br><span class="line">...where col1 = 1 order by col2, col3; <span class="comment">-- (√) </span></span><br><span class="line">...where col1 = 1 order by col2; <span class="comment">-- (√)</span></span><br><span class="line">...where col1 &gt; 1 order by col1, col2; -- (√)</span><br><span class="line"></span><br><span class="line">...where col1 = 1 order by col2 desc, col3 asc; <span class="comment">-- (X)</span></span><br><span class="line">...where col1 = 1 order by col2, col4; <span class="comment">-- (X)</span></span><br><span class="line">...where col1 = 1 order by col3; <span class="comment">-- (X)</span></span><br><span class="line">...where col1 &gt; 1 order by col2, col3; -- (X) 范围条件</span><br><span class="line">...where col1 = 1 and col2 in(1,3) order by col3; <span class="comment">-- (X) 范围条件</span></span><br></pre></td></tr></table></figure>

<h2 id="前缀压缩索引"><a href="#前缀压缩索引" class="headerlink" title="前缀压缩索引"></a>前缀压缩索引</h2><p>MyISAM 先保存索引块的第一个值，然后将其他值和第一个值进行比较得到相同前缀的字节数和剩余的不同后缀部分，如 “perform” “performance” 类似 “7,ance” 的形式。</p>
<p>因为每个值的压缩前缀都依赖前面的值，所以查找时只能从头开始扫描（无法二分查找），倒序扫描的速度就更差了（order by desc）。</p>
<h2 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a>冗余和重复索引</h2><p>增加新索引将会导致 insert update delete 等操作的速度变慢。</p>
<p>重复索引是指在相同的列上按照相同的顺序创建的<strong>相同类型</strong>的索引，索引类型不同不算重复。 </p>
<p>主键限制和唯一限制是通过索引来实现的，如果再定义索引就会重复。</p>
<p>对于 B-Tree 索引，若创建了索引 (A,B) 再创建索引 (A) 则冗余，而索引 (B,A) 和 (B) 不是，因为 (B) 不是最左前缀。</p>
<p>冗余索引通常发生在添加新索引的时候。如已有索引 (A) ，增加 (A,B) 而不是扩展；或扩展为 (A,PK)，对于 InnoDB 而言主键列已经包含在二级索引中。</p>
<ul>
<li>避免扩展已有的索引导致其变得太大，从而影响其他使用该索引查询的性能。</li>
</ul>
<h2 id="索引和锁"><a href="#索引和锁" class="headerlink" title="索引和锁"></a>索引和锁</h2><p>InnoDB 只有在访问行的时候才会对其加锁，而索引能够减少 InnoDB 访问的行数，从而减少锁的数量。</p>
<p>InnoDB在二级索引上使用共享锁（读锁），但在访问主键时使用排它锁（写锁）。</p>
<p>ps 在即使使用了索引，也可能锁住一些不需要的行。</p>
<hr>
<h1 id="维护索引和表"><a href="#维护索引和表" class="headerlink" title="维护索引和表"></a>维护索引和表</h1><h2 id="表损坏"><a href="#表损坏" class="headerlink" title="表损坏"></a>表损坏</h2><blockquote>
<p>当碰到古怪的问题，比如不应该发生的主键冲突，可以通过 CHECK TABLE 来检查是否发生了表损坏。该命令通常能够找出大多数表和索引的错误。 可以执行 REPAIR TABLE 来修复损坏的表。 也可以通过一个不做任何数据操作的 ALTER 操作来重建表，以达到修复的目的：ALTER TABLE innodb_tbl ENGINE=INNODB;</p>
</blockquote>
<h2 id="减少碎片"><a href="#减少碎片" class="headerlink" title="减少碎片"></a>减少碎片</h2><p>行碎片，行间碎片，剩余空间碎片（页内碎片）。</p>
<p>InnoDB 会移动短小的行重写到一个片段中，不会出现短小的行碎片。</p>
<p>通过 optimize table 或者导出再导入的方式重新整理数据。</p>
<p>考虑数据是否已到稳定状态，以免之后的更新操作引发分页和重组。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>P420i 阵列卡开启 HBA 直通</title>
    <url>/2020/03/16/P420i-%E9%98%B5%E5%88%97%E5%8D%A1%E5%BC%80%E5%90%AF-HBA-%E7%9B%B4%E9%80%9A/</url>
    <content><![CDATA[<p>HP P420i 阵列卡 ESXi 下开启 HBA 直通：</p>
<p>教程：<a href="https://communities.vmware.com/thread/484114" target="_blank" rel="noopener">https://communities.vmware.com/thread/484114</a></p>
<p>因为时间久远与现在有一些出入，故作补丁。</p>
<ol>
<li><p>自检界面根据提示进入 SmartArray，删除所有已配置的硬盘，重启；</p>
</li>
<li><p>在 ESXi 管理界面启用 shell ；</p>
</li>
<li><p>ssh 连接 ESXi (原教程 iLO 的延迟太痛苦了)强制开启 HBA：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">esxcli ssacli cmd -q "controller slot=0 modify hbamode=on forced"</span><br></pre></td></tr></table></figure>

<p> 我的机器上 hpssacli 叫 ssacli，不确定可以直接 <code>esxcli</code> 一下看提示；</p>
<p> 没有反馈就是最好的反馈，不放心就手动确认是否成功：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">esxcli ssacli cmd -q "controller slot=0 show config detail"</span><br></pre></td></tr></table></figure>

<p> <code>HBA Mode Enabled</code> 为 True 即可；</p>
</li>
<li><p>硬盘全部插回去，然后你就会发现 ESXi 将 disks 一律当做 SAS 通信了(笑</p>
<p> 而且这是不可修改项 (笑</p>
<p> 所以只有 SAS 硬盘才能成功建立 datastore，即 SSD 无法被添加 (笑</p>
</li>
<li><p>感觉索然无味的话就回到 RAID 吧：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">esxcli ssacli cmd -q "controller slot=0 modify hbamode=off"</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>ESXi</tag>
        <tag>HBA</tag>
      </tags>
  </entry>
  <entry>
    <title>Padavan 添加 GoDaddy DDNS 服务</title>
    <url>/2020/03/15/Padavan-%E6%B7%BB%E5%8A%A0-GoDaddy-DDNS-%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>04-04 更新，将历史 ip 保存在本地，不通过 api 获取（国内访问 Godaddy 太慢了）。</p>
<ol>
<li><p>到 DNS 管理中新增一条 A 记录，“指向” 随便填；</p>
</li>
<li><p>到 <a href="https://developer.godaddy.com/keys" target="_blank" rel="noopener">https://developer.godaddy.com/keys</a> 创建并记录 key 和 Secret；</p>
</li>
<li><p>创建 shell 脚本和本机记录文件，通过 GoDaddy 的 api 更新 ip 地址：</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">mydomain=<span class="string">"填域名"</span></span><br><span class="line">myhostname=<span class="string">"填刚才那条A记录的名称"</span></span><br><span class="line">gdapikey=<span class="string">"填 key:secret 不要忘记中间冒号"</span></span><br><span class="line"></span><br><span class="line">myip=`curl -s <span class="string">"https://api.ipify.org"</span>`</span><br><span class="line">oldip=$(tail -n 1 /path/iprecord.txt)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [<span class="string">"<span class="variable">$oldip</span>"</span> == <span class="string">"<span class="variable">$myip</span>"</span>]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Nothing happened."</span></span><br><span class="line">  <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$myip</span>"</span> &gt; /path/iprecord.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"IP has changed."</span></span><br><span class="line">curl -s -X PUT <span class="string">"https://api.godaddy.com/v1/domains/<span class="variable">$&#123;mydomain&#125;</span>/records/A/<span class="variable">$&#123;myhostname&#125;</span>"</span> -H <span class="string">"Authorization: sso-key <span class="variable">$&#123;gdapikey&#125;</span>"</span> -H <span class="string">"Content-Type: application/json"</span> -d <span class="string">"[&#123;\"data\": \"<span class="variable">$&#123;myip&#125;</span>\"&#125;]"</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>
</li>
<li><p>chmod 777 ，然后在本机上测试下；</p>
</li>
<li><p>进入路由器管理页面启用 SSH 服务；</p>
</li>
<li><p>sftp 连接路由器把脚本文件放到 <code>/etc/storage</code> 目录下；</p>
</li>
<li><p>路由器管理界面 系统管理 -&gt; 恢复/导出/上传设置 -&gt; 保存 /etc/storage/ 内容到闪存，点击后没有反馈是正常的，右上角 log 里有执行情况；</p>
</li>
<li><p>路由器管理界面 系统管理 -&gt; 服务 -&gt; 计划任务：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">*/10 * * * * /etc/storage/yours.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">每十分钟执行</span></span><br></pre></td></tr></table></figure>

<p> 点击 应用本页设置 完成。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>DDNS</tag>
      </tags>
  </entry>
  <entry>
    <title>Padavan 添加 NameSilo DDNS 服务</title>
    <url>/2020/09/11/Padavan-%E6%B7%BB%E5%8A%A0-NameSilo-DDNS-%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>步骤同之前 <a href="https://www.yuyurbq.icu/2020/03/15/Padavan-%E6%B7%BB%E5%8A%A0-GoDaddy-DDNS-%E6%9C%8D%E5%8A%A1/">Padavan 添加 GoDaddy DDNS 服务</a> ；</p>
<p>apikey 到 <a href="https://www.namesilo.com/account/api-manager" target="_blank" rel="noopener">https://www.namesilo.com/account/api-manager</a> 创建；</p>
<p>shell 脚本如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">MYAPIKEY=<span class="string">"填apikey"</span></span><br><span class="line">MYDOMAIN=<span class="string">"域名"</span></span><br><span class="line">MYHOST=<span class="string">"A记录名称"</span></span><br><span class="line">MYFULLDOMAIN=<span class="string">"<span class="variable">$MYHOST</span>.<span class="variable">$MYDOMAIN</span>"</span></span><br><span class="line"></span><br><span class="line">MYIP=`curl -s <span class="string">"https://api.ipify.org"</span>`</span><br><span class="line">OLDIP=$(tail -n 1 /home/root/iprecord.txt)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [<span class="string">"<span class="variable">$OLDIP</span>"</span> == <span class="string">"<span class="variable">$MYIP</span>"</span>]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"Nothing happened."</span></span><br><span class="line">  <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$MYIP</span>"</span> &gt; /home/root/iprecord.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"IP has changed."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fetch DNS record ID</span></span><br><span class="line">RESPONSE=<span class="string">"<span class="variable">$(curl -s "https://www.namesilo.com/api/dnsListRecords?version=1&amp;type=xml&amp;key=$MYAPIKEY&amp;domain=$MYDOMAIN")</span>"</span></span><br><span class="line">RECORD_ID=<span class="string">"<span class="variable">$(echo $RESPONSE | sed -n 's/^.*&lt;record_id&gt;\(.*\)&lt;\/record_id&gt;&lt;type&gt;A&lt;\/type&gt;&lt;host&gt;'$MYFULLDOMAIN'&lt;\/host&gt;.*$/\1/p')</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Update</span></span><br><span class="line">RESPONSE=<span class="string">"<span class="variable">$(curl -s "https://www.namesilo.com/api/dnsUpdateRecord?version=1&amp;type=xml&amp;key=$MYAPIKEY&amp;domain=$MYDOMAIN&amp;rrid=$RECORD_ID&amp;rrhost=$MYHOST&amp;rrvalue=$MYIP&amp;rrttl=7207")</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>DDNS</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 性能-查询</title>
    <url>/2020/09/20/MySQL-%E6%80%A7%E8%83%BD-%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>优化查询，实际上要优化其子任务，要么消除其中一些子任务，要么减少子任务的执行次数，要么让子任务运行得更快。<br>查询的生命周期大致可以按照：从客户端，到服务器，然后在服务器上进行解析，生成执行计划，执行，并返回结果给客户端。</p><h1 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h1><h2 id="不要请求不需要的数据"><a href="#不要请求不需要的数据" class="headerlink" title="不要请求不需要的数据"></a>不要请求不需要的数据</h2><ol>
<li><p>查询不需要的记录</p>
<p> 例如在处理分页时，应该使用 limit 限制 MySQL 只返回一页的数据，而不是向应用程序返回全部数据后，再由应用程序过滤不需要的行。</p>
</li>
<li><p>多表关联时返回全部列</p>
<p> 只取需要的列。</p>
</li>
<li><p>总是取出全部列</p>
<p> select * 会让优化器无法完成索引覆盖扫描这类优化，带来额外的 I/O 内存 CPU 消耗。</p>
</li>
<li><p>重复查询相同的数据</p>
<p> 当一行数据被多次使用时可以考虑缓存起来，避免每次使用都要到MySql查询。</p>
</li>
</ol><a id="more"></a>

<h2 id="避免扫描额外的记录"><a href="#避免扫描额外的记录" class="headerlink" title="避免扫描额外的记录"></a>避免扫描额外的记录</h2><p>响应时间：数据库处理查询所用的服务时间，和服务器等待资源的排队时间。并无规律和公式，尝试上限估计法。</p>
<p>扫描的行数：不是所有行的访问代价都相同；较短的行的访问速度更快，内存中的行也比磁盘中的行的访问速度要快得多。</p>
<p>访问类型：explain 中的 type 列反应了访问类型，全表扫描，索引扫描，范围扫描，唯一索引扫描，常数引用，速度从慢到快；通常增加合适的索引。</p>
<p>where 条件从好到坏：</p>
<ul>
<li>在索引中使用 where 条件来过滤不匹配的记录，在存储引擎层完成；</li>
<li>使用索引覆盖扫描返回记录，直接从索引中过滤不需要的记录并返回命中结果，在服务器层完成但无需回表查询；</li>
<li>从数据表中返回数据，然后过滤不满足条件的记录（Extra 列中出现 Using Where）</li>
</ul>
<p>若发现查询需要扫描大量数据但只返回少数的行：</p>
<ul>
<li>使用索引覆盖扫描（见索引）；</li>
<li>改变库表结构，如使用单独的汇总表（见库表）；</li>
<li>重写这个查询以适应优化器</li>
</ul>
<hr>
<h1 id="重构查询的方式"><a href="#重构查询的方式" class="headerlink" title="重构查询的方式"></a>重构查询的方式</h1><h2 id="一个复杂查询-or-多个简单查询"><a href="#一个复杂查询-or-多个简单查询" class="headerlink" title="一个复杂查询 or 多个简单查询"></a>一个复杂查询 or 多个简单查询</h2><p>一些情况下分解很有必要，但不要对能够胜任的查询下手。</p>
<h2 id="切分查询"><a href="#切分查询" class="headerlink" title="切分查询"></a>切分查询</h2><p>分治，将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果，可以避免锁住很多数据、占满事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>
<h2 id="分解关联查询"><a href="#分解关联查询" class="headerlink" title="分解关联查询"></a>分解关联查询</h2><p>对每个要关联的表进行单表查询，然后将结果在应用程序中进行关联：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tag</span><br><span class="line">-&gt;	<span class="keyword">join</span> tag_post <span class="keyword">on</span> tag_post.tag_id=tag.id</span><br><span class="line">-&gt;	<span class="keyword">join</span> post <span class="keyword">on</span> tag_post.post_id=post.id</span><br><span class="line"><span class="keyword">where</span> tag.tag=<span class="string">'mysql'</span>;</span><br></pre></td></tr></table></figure>

<p>可以分解成：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tag <span class="keyword">where</span> tag=<span class="string">'mysql'</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tag_post <span class="keyword">where</span> tag_id=<span class="number">1234</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> post <span class="keyword">where</span> post.id <span class="keyword">in</span>(<span class="number">123</span>,<span class="number">456</span>,<span class="number">789</span>);</span><br></pre></td></tr></table></figure>

<p>优势：</p>
<ul>
<li>让缓存的效率更高。如果缓存的是关联查询的结果，那么其中的一个表发生变化，整个缓存就失效了。而拆分后，如果只是某个表很少的改动，并不会破坏所有的缓存；</li>
<li>可以减少锁的竞争；</li>
<li>应用层做关联，更容易对数据库进行拆分，做到高性能和可扩展；</li>
<li>查询本身的效率也有可能会有所提升。例如用 in() 代替关联查询比随机的关联更加高效；</li>
<li>可以减少冗余记录的查询，对于某条记录应用只需要查询一次；、、</li>
<li>相当于在应用中实现了哈希关联，而不是使用 MySQL 的嵌套循环关联。</li>
</ul>
<p>场景：</p>
<ul>
<li>应用能够方便地缓存单个查询的结果的时候；</li>
<li>数据分布到不同的 MySQL 服务器上的时候；</li>
<li>能够使用 IN() 的方式代替关联查询的时候；</li>
<li>查询中使用同一个数据表的时候。</li>
</ul>
<hr>
<h1 id="查询执行基础"><a href="#查询执行基础" class="headerlink" title="查询执行基础"></a>查询执行基础</h1><ol>
<li><p>客户端发送一条查询给服务器；</p>
</li>
<li><p>服务器先检查查询缓存，如果命中则立刻返回结果，否则进入下一阶段；</p>
</li>
<li><p>服务器端进行 SQL 解析、预处理，再由优化器生成对应的执行计划；</p>
</li>
<li><p>MySQL 根据优化器生成的执行计划，调用存储引擎的 API 来执行查询；</p>
</li>
<li><p>将结果返回给客户端。</p>
</li>
</ol>
<h2 id="MySQL-CS间的通信"><a href="#MySQL-CS间的通信" class="headerlink" title="MySQL CS间的通信"></a>MySQL CS间的通信</h2><p>半双工，无法进行流量控制，一旦一端开始发生消息，另一端要接收完整个消息才能响应它。</p>
<p>多数连接 MySQL 的库函数从 MySQL 获取数据时，实际是从这个库函数的缓存获取数据，这样可以尽早释放服务器的资源。</p>
<p>查询连接/线程状态，SHOW FULL PROCESSLIST 命令 Command 列：</p>
<ul>
<li><p>Sleep，线程正在等待客户端发送新的请求；</p>
</li>
<li><p>Query，线程正在执行查询或者正在将结果发送给客户端；</p>
</li>
<li><p>Locked，在 MySQL 服务器层，该线程正在等待表锁。存储引擎级别的锁如 InnoDB 的行锁，不会体现在线程状态；</p>
</li>
<li><p>Analyzing and statistics，线程正在收集存储引擎的统计信息，并生成查询的执行计划；</p>
</li>
<li><p>Copying to tmp table [on disk]，线程正在执行查询，并且将其结果集都复制到一个临时表中，要么是在做 group by 操作，要么是文件排序操作，或者是 union 操作。on disk 则正在将内存临时表放到磁盘上；</p>
</li>
<li><p>Sorting result，线程正在对结果集进行排序；</p>
</li>
<li><p>Sending data，线程可能在多个状态之间传送数据，或者在生成结果集，或者在向客户端返回数据。</p>
</li>
</ul>
<h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>若查询缓存是打开的，MySQL 通过一个对大小写敏感的哈希查找检查是否命中。若恰好命中，返回查询结果之前 MySQL 会检查一次用户权限。</p>
<p>查询不会被解析，不用生成执行计划，不会被执行。</p>
<h2 id="查询优化处理"><a href="#查询优化处理" class="headerlink" title="查询优化处理"></a>查询优化处理</h2><p>未匹配缓存时，查询的生命周期的下一步是将 SQL 转换成一个执行计划，MySQL 再依照执行计划和存储引擎交互。这些包括：解析 SQL，预处理，优化执行计划。</p>
<p><strong>语法解析器和预处理</strong></p>
<p>MySQL 解析器使用语法规则验证和解析查询，是否使用错误的关键字，其顺序是否正确，引号能否前后匹配等。</p>
<p>预处理器则根据一些 MySQL 规则进一步检查是否合法。检查数据表和数据列是否存在，名字和别名是否有歧义等，然后验证权限。</p>
<p><strong>查询优化器</strong></p>
<p>一条查询可以有多种执行方式，优化器从中找到最好的执行计划。</p>
<p>MySQL 使用基于成本的优化器，其尝试预测一个查询使用某种执行计划时的成本（不考虑任何缓存），并选择其中成本最小的一个。使用<code>show status like &#39;Last_query_cost&#39;;</code> 查看需要多少个数据页的随机查找。</p>
<p>导致优化器选择错误的执行计划的原因：</p>
<ul>
<li><p>统计信息不准确，依赖存储引擎提供的统计信息进行评估，如 InnoDB 引擎不能维护一个数据表的行数的精确统计信息（因为 MVCC）；</p>
</li>
<li><p>执行计划中的成本估算不等同于实际执行的成本，无法得知真实的物理 I/O，比如顺序读或者在内存中；</p>
</li>
<li><p>MySQL 的最优基于成本模型，而不是时间尽可能短；</p>
</li>
<li><p>MySQL 从不考虑其他并发执行的查询；</p>
</li>
<li><p>MySQL 也并不是任何时候都是基于成本的优化，一些固定规则有更高优先级，如 match() 子句（即使别的索引或 where 条件更快，仍使用对应的全文索引）；</p>
</li>
<li><p>MySQL 不会考虑不受其控制的操作的成本，如执行存储过程或用户自定义函数；</p>
</li>
<li><p>优化器无法去估算所有可能的执行计划。</p>
</li>
</ul>
<p>查询优化器的策略可以简单分为静态优化和动态优化。静态优化不依赖于特别的值，在第一次完成后就一直有效即使用不同的参数重复执行查询也不会发生变化，比如通过一些简单的代数变化将条件转换成另一种等价形式。动态优化和查询的上下文有关，每次执行都要重新评估，比如 where 条件中的取值，索引中条目对应的数据行数等。MySQL 可以处理：</p>
<ul>
<li><p>重新定义关联表的顺序；</p>
</li>
<li><p>将外连接转化成内连接，where 条件，库表结构等因素可能让外连接等价于一个内连接；</p>
</li>
<li><p>使用等价变换规则，合并和减少一些比较，移除一些恒成立和恒不成立的判断，比如 <code>(a&lt;b and b=c) and a=5</code> 会改写成 <code>b&gt;5 and b=c and a=5</code> 。</p>
</li>
<li><p>优化 count() min() max() ，要找到某一列的最小值，只需要查找对应 B-Tree 索引的最左端即直接获取第一行记录，查找最大值则是最后一条记录，在 explain 中可以看到 “Select tables optimized away”，表示优化器已经从执行计划中移除了该表，并以一个常数取而代之。类似的， count(*) 查询通常可以使用存储引擎提供的数据。</p>
</li>
<li><p>预估并转化为常数表达式，如一个用户自定义变量在查询中没有发生变化时就转换为一个常数。如果 where 子句中使用了索引的常数条件，MySQL 可以在查询开始阶段就先查找到这些值，优化器将其转换为常数表达式：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">select</span> film.film_id, film_actor.actor_id</span><br><span class="line">   -&gt; <span class="keyword">from</span> film</span><br><span class="line">-&gt;     <span class="keyword">inner</span> <span class="keyword">join</span> film_actor <span class="keyword">using</span>(film_id)</span><br><span class="line">   -&gt; <span class="keyword">where</span> film.film_id=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<pre><code>&gt; MySQL 会分成两步来执行这个查询，也就是上面的两行输出。第一步先从 film 表找到需要的行。因为在 film_id 字段上有主键索引，所以 MySQL 优化器知道这只会返回一行数据，优化器在生成执行计划的时候，就已经通过索引信息知道将返回多少行数据。因为优化器已经明确知道有多少个值（ WHERE 条件中的值）需要做索引查询，所以这里的表访问类型是 const 。
在执行计划的第二步，MySQL 将第一步中返回的 film_id 列当作一个已知取值的列来处理。因为优化器清楚在第一步执行完后，该值就是明确的了。注意到正如第一步一样，使用film_actor字段对表的访问类型也是 coonst 。
另一种会看到常数条件的情况是通过等式将常数值从一个表传到另一个表，这可以通过 WHERE、USING 或者 ON 语句来限制某列数的值为常数。在上面的例子中，因为使用了 USING 子句，优化器知道这也限制了 film_id 在整个查询过程中都始终是一个常量——因为他必须等于 WHERE 子句中的那个取值。</code></pre><ul>
<li><p>覆盖索引扫描，当索引中的列包含所有查询中需要使用的列的时候，就可以使用索引返回需要的数据，而无须查询对应的数据行；</p>
</li>
<li><p>子查询优化，某些情况下 MySQL 将子查询转换为效率更高的形式，以减少多个查询多次对数据访问；</p>
</li>
<li><p>提前终止查询，在发现已经满足查询需求的时候，MySQL 能够立刻终止查询，如 limit 子句。若发现了一个不成立的条件，MySQL 会立刻返回一个空结果。当存储引擎需要检索不同取值或判断存在性时，会提前终止查询判断下一个，类似这种 不同值 不存在 的优化一般可用于 DISTINCT、NOT EXIST() 或者 LEFT JOIN 类型的查询；</p>
</li>
<li><p>等值传播，如果两个列的值通过等式关联，那么MySQL能够把其中一列的WHERE条件传递到另一列上：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> film.film_id</span><br><span class="line">-&gt; <span class="keyword">from</span> sakila.film</span><br><span class="line">-&gt;     <span class="keyword">inner</span> <span class="keyword">join</span> sakila.film_actor <span class="keyword">using</span>(film_id)</span><br><span class="line">-&gt; <span class="keyword">where</span> film.film_id &gt; <span class="number">500</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为这里使用了film_id字段进行等值关联，MySQL知道这里的WHERE子句不仅适用于film表，而且对于film_actor表同样适用。</p>
</blockquote>
</li>
<li><p>列表 in() 的比较，在 MySQL 中，in() 先将自己列表中的数据进行排序，然后通过二分查找的方式确定列的值是否在 in() 的列表中，这个时间复杂度是 O(logn) 。如果换成 or 操作，则时间复杂度是 O(n) 。所以，对于 in() 的列表中有大量取值的时候，用 in() 替换 or 操作将会更快。</p>
</li>
</ul>
<p><strong>数据和索引的统计信息</strong></p>
<p>服务器层有查询优化器，但不保存数据和索引的统计信息，统计信息由存储引擎实现，不同的存储引擎可能会存储不同的统计信息（甚至没有）。查询优化器在生成查询的执行计划时需要向存储引擎获取。</p>
<p><strong>MySQL 执行关联查询 (join)</strong></p>
<p>在 MySQL 中，任何一个查询都是一次关联，即使只有一个表的查询也是如此。</p>
<p>对于 union 查询，MySQL 先将一系列的单个查询结果放到一个临时表中，然后再重新读出临时表数据来完成 union 查询。MySQL 读取结果临时表和普通表一样，也是采用的关联方式。</p>
<p>当遇到子查询时，先执行子查询并将结果放到一个临时表中，然后再将这个临时表当做一个普通表对待。MySQL 的临时表是没有任何索引的，在编写复杂的子查询和关联查询的时候需要注意这一点，临时表也叫派生表。</p>
<p>MySQL 对任何关联都执行嵌套循环关联操作，即先在一个表中循环取出单条数据，然后再嵌套到下一个表中寻找匹配的行，直到找到所有表中匹配的行为止。例如对于 SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tbl1.col1,tbl2.col2</span><br><span class="line">-&gt; <span class="keyword">FROM</span> tbl1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tbl2 <span class="keyword">USING</span>(col3)</span><br><span class="line">-&gt; <span class="keyword">WHERE</span> tbl1.col1 <span class="keyword">IN</span>(<span class="number">5</span>,<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>伪代码表示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">out_iter = iterator over tbl1 where col1 IN(5,6)</span><br><span class="line">outer_row = out_iter.next</span><br><span class="line">while outer_row</span><br><span class="line">    inner_iter = iterator over tbl2 where col3 = outer_row.col3</span><br><span class="line">    inner_row = inner_iter.next</span><br><span class="line">    while inner_row</span><br><span class="line">        output[outer_row.col1, inner_row.col2]</span><br><span class="line">        inner_row = inner_iter.next</span><br><span class="line">    end</span><br><span class="line">    outer_row = outer_iter.next</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>对于单表查询，那么只需要完成外层的基本操作。</p>
<p><strong>关联查询优化器</strong></p>
<p>尝试在所有的关联顺序中选择一个成本最小的来生成执行计划树（MySQL 不生成查询字节码而是指令树）。</p>
<p>如果可能，优化器会遍历每一个表然后逐个做嵌套循环计算每一棵可能的执行树的成本，最后返回一个最优的执行计划，如果有超过 n 个表的关联，那么需要检查 n 的阶乘关联顺序，此时搜索空间的增长速度非常快。一旦超过 optimizer_search_depth 的限制，优化器会选择贪婪搜索模式。</p>
<p>有时各个查询的顺序不能随意安排，比如左连接等需要依赖前表的结果。这会大大减少搜索空间。</p>
<p><strong>排序优化</strong></p>
<p>应该尽量让 MySQL 使用索引进行排序。当不能使用索引生成排序结果的时候，如果数据量小于“排序缓冲区”的大小，则 MySQL 使用内存进行“快速排序”操作。如果数据量太大超过“排序缓冲区”的大小，那么 MySQL 会将数据分块，对每个块“快速排序”并将结果存放在磁盘上，最后合并返回。</p>
<p>MySQL 文件排序操作使用的临时存储空间可能相当大，因为每一个排序记录都会分配一个足够长的定长空间，此空间必须能容纳其中最长的字符串（varchar 列需要分配完整长度，UTF-8 每个字符预留三字节）。</p>
<h2 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h2><p>经查询执行引擎逐步执行指令后（并非字节码），将结果增量、逐步的返回客户端，比如服务器处理完最后一个关联表开始生成第一条结果时，就可以逐步返回结果集了。</p>
<p>即使不需要返回结果集，MySQL 仍会返回查询的一些信息，比如影响到的行数。</p>
<hr>
<h1 id="查询优化器的局限性"><a href="#查询优化器的局限性" class="headerlink" title="查询优化器的局限性"></a>查询优化器的局限性</h1><h2 id="关联子查询"><a href="#关联子查询" class="headerlink" title="关联子查询"></a>关联子查询</h2><p>MySQL 的子查询实现的非常糟糕。最糟糕的一类查询是 where 条件中包含 in() 的子查询语句。MySQL 会将外层表压到子查询中，导致关联子查询，比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> film</span><br><span class="line">-&gt; <span class="keyword">where</span> film_id <span class="keyword">in</span>(</span><br><span class="line">-&gt;     <span class="keyword">select</span> film_id <span class="keyword">from</span> film_actor <span class="keyword">where</span> actor_id=<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 预想的处理</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> film</span><br><span class="line">-&gt; <span class="keyword">where</span> film_id</span><br><span class="line">-&gt;     <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">23</span>,<span class="number">25</span>,<span class="number">213</span>,<span class="number">344</span>,<span class="number">546</span>,<span class="number">788</span>,<span class="number">907</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 实际的处理</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> film</span><br><span class="line">-&gt; <span class="keyword">where</span> <span class="keyword">exists</span>(</span><br><span class="line">-&gt;     <span class="keyword">select</span> * <span class="keyword">from</span> film_actor <span class="keyword">where</span> actor_id=<span class="number">1</span></span><br><span class="line">-&gt;     <span class="keyword">and</span> film_actor.film_id = film.film_id);</span><br></pre></td></tr></table></figure>

<p>MySQL 先对 film 表全表扫描，然后根据返回的 film_id 逐个执行子查询。</p>
<p>应该尽可能用关联替换子查询，可以提高查询效率（如果使用MySQL5.6以上或MariaDB则可以忽略）。当然，子查询不一定是最慢的，应该用测试来验证。</p>
<h2 id="union-的限制"><a href="#union-的限制" class="headerlink" title="union 的限制"></a>union 的限制</h2><p>如果希望 union 的各个子句能根据 limit 只取部分结果集，或先排好序再合并结果集的话，则需要在各个子句中分别使用 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 将 actor 和 customer 的所有记录存放在临时表</span></span><br><span class="line">(<span class="keyword">select</span> first_name, last_name <span class="keyword">from</span> actor <span class="keyword">order</span> <span class="keyword">by</span> last_name)</span><br><span class="line">-&gt; <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">-&gt; (<span class="keyword">select</span> first_name, last_name <span class="keyword">from</span> customer <span class="keyword">order</span> <span class="keyword">by</span> last_name)</span><br><span class="line">-&gt; <span class="keyword">limit</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 临时表只包含 40 条记录</span></span><br><span class="line">(<span class="keyword">select</span> first_name, last_name <span class="keyword">from</span> actor <span class="keyword">order</span> <span class="keyword">by</span> last_name <span class="keyword">limit</span> <span class="number">20</span>)</span><br><span class="line">-&gt; <span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line">-&gt; (<span class="keyword">select</span> first_name, last_name <span class="keyword">from</span> customer <span class="keyword">order</span> <span class="keyword">by</span> last_name <span class="keyword">limit</span> <span class="number">20</span>)</span><br><span class="line">-&gt; <span class="keyword">limit</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<h2 id="最大值最小值优化"><a href="#最大值最小值优化" class="headerlink" title="最大值最小值优化"></a>最大值最小值优化</h2><p>比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- first_name 字段没有索引，将会全表扫描</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">min</span>(actor_id) <span class="keyword">from</span> actor <span class="keyword">where</span> first_name=<span class="string">'xxx'</span>;</span><br></pre></td></tr></table></figure>

<p>MySQL 读到第一个满足条件的记录时就是最小值了，因为 actor_id 上主键索引是按大小顺序排列的。曲线优化：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> actor_id <span class="keyword">from</span> actor <span class="keyword">use</span> <span class="keyword">index</span>(primary)</span><br><span class="line">-&gt; <span class="keyword">where</span> first_name=<span class="string">'xxx'</span> <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="在同一张表上查询和更新"><a href="#在同一张表上查询和更新" class="headerlink" title="在同一张表上查询和更新"></a>在同一张表上查询和更新</h2><p>MySQL 不允许同时进行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 将表中相似行的数量记录到字段里</span></span><br><span class="line"><span class="keyword">update</span> tb1 <span class="keyword">as</span> outer_tb1</span><br><span class="line">-&gt;     <span class="keyword">set</span> cnt = (</span><br><span class="line">-&gt;         <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb1 <span class="keyword">as</span> inner_tb1</span><br><span class="line">-&gt;         <span class="keyword">where</span> inner_tb1.type = outer_tb1.type</span><br><span class="line">-&gt;     );</span><br></pre></td></tr></table></figure>

<p>使用临时表来处理：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> tb1</span><br><span class="line">-&gt;     <span class="keyword">inner</span> <span class="keyword">join</span>(</span><br><span class="line">-&gt;         <span class="keyword">select</span> <span class="keyword">type</span>, <span class="keyword">count</span>(*) <span class="keyword">as</span> cnt <span class="keyword">from</span> tb1</span><br><span class="line">-&gt;         <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">type</span></span><br><span class="line">-&gt;     ) <span class="keyword">as</span> der <span class="keyword">using</span>(<span class="keyword">type</span>)</span><br><span class="line">-&gt; <span class="keyword">set</span> tb1.cnt = der.cnt;</span><br></pre></td></tr></table></figure>

<p>子查询在 update 打开表之前完成，update 关联的表是一个临时表。</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>MySQL 无法利用多核特性来并行执行查询。</p>
<p>MySQL 不支持哈希关联，其关联都是嵌套循环关联。</p>
<p>MySQL 不支持松散索引扫描，5.0 后在分组查询中需要找到分组的最大值和最小值时可以使用。5.6 后通过<em>索引条件下推</em>的方式解决。</p>
<hr>
<h1 id="优化特定类型的查询"><a href="#优化特定类型的查询" class="headerlink" title="优化特定类型的查询"></a>优化特定类型的查询</h1><h2 id="count"><a href="#count" class="headerlink" title="count()"></a>count()</h2><p>count() 有两个不同的作用：</p>
<ol>
<li>统计某个列值的数量，即统计某列值不为 null 的个数。</li>
<li>统计行数。</li>
</ol>
<p>当使用 count(*) 时，统计的是行数，它会忽略所有的列而直接统计所有的行数。而在括号中指定了一个列的话，则统计的是这个列上值不为 null 的个数。</p>
<p>比如将条件反转：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 扫描记录较多</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> city <span class="keyword">where</span> <span class="keyword">id</span>&gt;<span class="number">5</span>;</span><br><span class="line"><span class="comment">-- 用总数减去</span></span><br><span class="line"><span class="comment">-- 子查询会直接作为常数处理</span></span><br><span class="line"><span class="keyword">select</span> (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> city) - <span class="keyword">count</span>(*) <span class="keyword">from</span> city <span class="keyword">where</span> <span class="keyword">id</span>&lt;=<span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<h2 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h2><p>确保 on 或者 using 子句中的列上有索引。</p>
<p>确保任何的 group by 和 order by 中的表达式只涉及到一个表中的列，这样 MySQL 才有可能使用索引优化这个过程。</p>
<h2 id="limit-分页"><a href="#limit-分页" class="headerlink" title="limit 分页"></a>limit 分页</h2><p>处理分页会使用到 limit ，当翻页到非常靠后的页面的时候，偏移量会非常大，这时 limit 的效率会非常差。例如对于 <code>LIMIT 10000，20</code> 这样的查询，MySQL 需要查询 10020 条记录，将前面 10000 条记录抛弃，只返回最后的 20 条。这样的代价非常高，如果所有的页面被访问的频率都相同，那么这样的查询平均需要访问半个表的数据。</p>
<p>优化此类分页查询的一个最简单的办法就是尽可能地使用索引覆盖扫描，而不是查询所有的列。然后根据需要与原表做一次关联操作返回所需的列。对于偏移量很大的时候，这样的效率会提升非常大。考虑下面的查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id, description <span class="keyword">FROM</span> sakila.film <span class="keyword">ORDER</span> <span class="keyword">BY</span> title <span class="keyword">LIMIT</span> <span class="number">50</span>, <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>如果这个表非常大，那么这个查询最好改写成下面的这样子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film.film_id, film.description <span class="keyword">FROM</span> film</span><br><span class="line">-&gt; <span class="keyword">INNER</span> <span class="keyword">JOIN</span> </span><br><span class="line">-&gt; (<span class="keyword">SELECT</span> film_id <span class="keyword">FROM</span> film <span class="keyword">ORDER</span> <span class="keyword">BY</span> title <span class="keyword">LIMIT</span> <span class="number">50</span>,<span class="number">5</span>) <span class="keyword">AS</span> lim</span><br><span class="line">-&gt; <span class="keyword">USING</span>(film_id);</span><br></pre></td></tr></table></figure>

<p>注意优化中关联的子查询，因为只查询 film_id 一个列，数据量小，使得一个内存页可以容纳更多的数据，这让 MySQL 扫描尽可能少的页面。在获取到所需要的所有行之后再与原表进行关联以获得需要的全部列。<br>limit 的优化问题，其实是 offset 的问题，它会导致 MySQL 扫描大量不需要的行然后再抛弃掉。可以借助书签的思想记录上次取数据的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就避免了使用 offset 。可以把主键当做书签使用，例如下面的查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> rental <span class="keyword">ORDER</span> <span class="keyword">BY</span> rental_id <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p>假设上面的查询返回的是主键为 16049 到 16030 的租借记录，那么下一页查询就可以直接从 16030 这个点开始：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> rental <span class="keyword">WHERE</span> rental_id &lt; <span class="number">16030</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> rental_id <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p>该技术的好处是无论翻页到多么后面，其性能都会很好。此外，也可以用关联到一个冗余表的方式提高 limit 的性能，冗余表只包含主键列和需要做排序的数据列。</p>
<h2 id="union-查询"><a href="#union-查询" class="headerlink" title="union 查询"></a>union 查询</h2><p>除非确实需要服务器消除重复的行，否则一定要使用 union all 。如果没有 all 关键字，MySQL 会给临时表加上 distinct 选项，这会导致对整个临时表的数据做唯一性检查，这样做的代价非常高。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh 修改 iLO 的 SSL 端口</title>
    <url>/2020/05/04/ssh%E4%BF%AE%E6%94%B9iLO%E7%9A%84SSL%E7%AB%AF%E5%8F%A3/</url>
    <content><![CDATA[<p>问题：修改 iLO Web 服务器 SSL 端口到 <strong>21</strong> 后无法连接。</p><p>原因：浏览器认为不安全（http 访问 21）</p><p>解决：改回默认或者换个不冲突的。</p><hr><ol>
<li><p>VPN 接入内网，ssh 登录 iLO。</p>
</li>
<li><p>不认 ls cat 什么的，<code>help</code> 说要用 <code>show</code> ，<em>system1</em> 目录是主机信息和 iLO 没啥关系。</p>
<p> <img src="https://i.loli.net/2020/05/04/GRYOdgyHnFZmC1f.png" alt="0505-01.png"></p>
</li>
<li><p><code>show /map1</code> 能找到一个配置文件 <em>config1</em> ，<code>show /map1/config1</code> 看一下，果然有 <em>oemhp_sslport</em> 这项 (图片是修改后的) ：</p>
<p> <img src="https://i.loli.net/2020/05/04/1KtHeNEFklS75PR.png" alt="0505-03.png"></p>
</li>
<li><p>最后 <code>cd /map1/config1</code> :</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;/map1/config1&gt;hpiLO-&gt; set oemhp_sslport=443</span><br></pre></td></tr></table></figure>

</li>
</ol><a id="more"></a>




<hr>
<p>校园网访问家里的服务器要连上机场当跳板 (没有国内 vps) 。今天 ssh 居然裸连上了… 然后恶从胆边生 (不是) 试了隔壁的 FTP 端口 (x</p>
<p>不过远程卡真的会用上 21 端口 <del>(某300页手册说) iLO 进入某个恢复模式时会自启一个 FTP 服务…</del>  </p>
]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
  </entry>
  <entry>
    <title>vim 的乱七八糟</title>
    <url>/2019/10/27/vim-%E7%9A%84%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/</url>
    <content><![CDATA[<h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><p>vim 编辑文件时会新建 .filename.swp 文件，记录所作操作，当 vim 被不正常中断（或他人正在编辑<br>）时暂存文件不会消失，继续编辑时允许如下操作：</p><ul>
<li>R 加载暂存文件的内容，恢复未保存的工作，记得离开 vim 后手动删掉暂存文件</li>
<li>D 确定暂存文件无用，删除并新建本次使用的 .swp</li>
<li>O 以只读打开，不进行编辑行为，用于他人正在编辑</li>
</ul><a id="more"></a>

<p>环境记录文件<br>~/.viminfo</p>
<p>环境配置文件<br>/etc/vimrc，建议创建 ~/.vimrc</p>
<table>
<thead>
<tr>
<th align="center">-</th>
<th align="center">-</th>
</tr>
</thead>
<tbody><tr>
<td align="center">:setnu :set nonu</td>
<td align="center">行号</td>
</tr>
<tr>
<td align="center">:set all</td>
<td align="center">当前环境参数</td>
</tr>
<tr>
<td align="center">:set</td>
<td align="center">与默认不同的参数</td>
</tr>
</tbody></table>
<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>1.块选择</p>
<p>一般模式下 [ctrl]-v 选择，y 复制，p 粘贴</p>
<hr>
<p>2.多窗口</p>
<table>
<thead>
<tr>
<th align="left">新窗口</th>
<th align="right">光标向下</th>
<th align="center">光标向上</th>
</tr>
</thead>
<tbody><tr>
<td align="left">:sp / :sp{filename}</td>
<td align="right">[ctrl]-w+j</td>
<td align="center">[ctrl]-w+k</td>
</tr>
</tbody></table>
<hr>
<p>3.多文件<br>| 当前打开的文件  | 下一个 | 上一个   |<br>|—————|:————–|:————–:|<br>|  :files  | :n  | :N |</p>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>中文编码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># LANG=zh_CN.xxx</span><br><span class="line"></span><br><span class="line"># iconv --list</span><br><span class="line"># iconv -f 原编码 -t 新编码 filename [-o newfile]</span><br><span class="line">-f from</span><br><span class="line">-t to</span><br><span class="line">-o newfile 保留原本文件</span><br></pre></td></tr></table></figure>

<hr>
<p>断行符<br>DOS ：^M$，即 CR 和 LF<br>Linux ：$，仅 LF</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># dos2UNIX [-kn] file [newfile]</span><br><span class="line"># UNIX2dos [-kn] file [newfile]</span><br><span class="line">-k 不修改 mtime</span><br><span class="line">-n 输出到新文件</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>环境配置</tag>
        <tag>断行符</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim 思维导图</title>
    <url>/2020/02/02/Vim-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
    <content><![CDATA[<p>没钱开 XMind… 理直气壮不去水印</p>
<p><img src="https://i.loli.net/2020/03/06/nqQfTsWvU2C54hc.png" alt="vim.png"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>思维导图</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>久久久远的2017</title>
    <url>/2020/01/30/%E4%B9%85%E4%B9%85%E4%B9%85%E8%BF%9C%E7%9A%842017/</url>
    <content><![CDATA[<p>图片已压缩… 阿里云 OSS 太贵了 qvq</p>
<p><img src="https://i.loli.net/2020/03/02/dHeotmyg2lCNqRF.jpg" alt="0212-01.jpg"></p>
<p><em>那天和对象出来干啥来着的… 咱俩坐在水游城负一楼休息，正巧在扶梯那。</em></p>
<p><em>相比另一张横幅的，这张更有气势，但内容有点乱。</em></p>
<a id="more"></a>

<hr>
<p><img src="https://i.loli.net/2020/03/02/zcT5wmgXStBd7vf.jpg" alt="0212-02.jpg"></p>
<p><em>和舍友们在玄武湖遇到的一只老猫，毛都秃了x 。</em></p>
<p><em>emmm 比较…气质？</em></p>
<hr>
<p><img src="https://i.loli.net/2020/03/02/fBzIupQEiRSAxa1.jpg" alt="0212-03.jpg"></p>
<p><em>学校图书馆，录完对比视频顺手合影。想表达锤子科技产品理念的更迭，好像失败了x ，现在看简直是对 M 系列的鞭尸。</em></p>
<p><em>为了让 M 产生虚化两者前后距离实际相当远，用长焦压缩的距离。暖光比较符合 M 系列的性格和地位，也能和锐利的坚果产生冲突。对象打光穿帮了，应该挡一下坚果方向的，嗯对象的锅。</em></p>
<hr>
<p><img src="https://i.loli.net/2020/03/02/C3y4xmScps2hEdt.jpg" alt="0212-04.jpeg"></p>
<p><em>17 年才摸到真机，比后面几代圆角怪x 好看多了。</em></p>
<hr>
<p><img src="https://i.loli.net/2020/03/02/5o1rHYLpjWNMZC3.jpg" alt="0212-05.jpeg"></p>
<p><em>宿舍床上拍的，按使用时间算遗照。是个正经大法，不像后来某些 A25 A35 A45 A55 x</em></p>
<hr>
<p><img src="https://i.loli.net/2020/03/02/HoaDWZpUPduylYC.jpg" alt="0212-06.jpg"></p>
<p><em>大晚上爬紫金山还吃了晚归，第一次拍全景弄拼接，嗯也就这一次。</em></p>
<p><em>光污染没救回来，天空占比也多了。紫峰左边那部分截掉其实也可，当时为了长吧x ，左右下角一片黑是因为机位没选好，山坡和护栏把视野挡了。</em></p>
]]></content>
      <categories>
        <category>碎碎念</category>
      </categories>
  </entry>
  <entry>
    <title>关于 Java 标签404</title>
    <url>/2019/12/08/%E5%85%B3%E4%BA%8E-Java-%E6%A0%87%E7%AD%BE404/</url>
    <content><![CDATA[<p><del>之前的标签名是 JAVA，后来改了小写，hexo 好像没有对标签的文件夹 <code>git mv</code>，有时间再手动改吧…</del></p>
<p><del>干脆直接戳 <a href="https://www.yuyurbq.club/categories/JAVA/" target="_blank" rel="noopener">https://www.yuyurbq.club/categories/JAVA/</a> 吧…</del></p>
<p>没事了</p>
]]></content>
  </entry>
  <entry>
    <title>变量赋值与构造函数的执行顺序</title>
    <url>/2019/09/06/%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC%E4%B8%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<ol>
<li>子类给成员变量分配空间，在栈中默认初始化成0</li>
<li>调用子类构造函数，因为继承，调用 super();</li>
<li>调用父类构造函数，因为覆盖，执行子类方法</li>
<li>执行父类构造函数其他语句</li>
<li>父类构造函数结束弹栈</li>
<li>子类对成员变量显示初始化(赋值)</li>
<li>调用子类构造函数其他语句   </li>
</ol>
<a id="more"></a>
<p><strong>检验</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    Fu()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.getNum();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"父类"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">4</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Zi</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        System.out.println(<span class="string">"子类构造函数中"</span>+<span class="keyword">this</span>.num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"getNum方法"</span>+<span class="keyword">this</span>.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">learn</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Zi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>构造函数</tag>
      </tags>
  </entry>
  <entry>
    <title>对象实例化过程</title>
    <url>/2019/09/06/%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Test t = <span class="keyword">new</span> Test;</span><br></pre></td></tr></table></figure>

<ol>
<li>JVM 读取 Test.class 文件并加载进内存，加载 Test 的父类(如果有)</li>
<li>堆内存中开辟空间，分配地址</li>
<li>在对象空间中，对对象中的属性进行默认初始化</li>
<li>调用对应的构造函数进行初始化<a id="more"></a></li>
<li>在构造函数中，先调用父类的构造函数进行初始化</li>
<li>父类初始化完毕后，对子类的属性进行显示初始化<br>（ super(); 和第二句之间的动作）</li>
<li>进行子类构造函数的特定初始化</li>
<li>初始化完毕，将地址值赋值给引用变量</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>构造函数</tag>
        <tag>实例化</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器驯化-之一</title>
    <url>/2020/03/02/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A9%AF%E5%8C%96-%E4%B9%8B%E4%B8%80/</url>
    <content><![CDATA[<h1 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h1><h2 id="Ivy-Bridge-EP"><a href="#Ivy-Bridge-EP" class="headerlink" title="Ivy Bridge EP"></a>Ivy Bridge EP</h2><p>制程比上一代新，价格也够便宜，可惜没有 AVX2 指令集。</p><p>撇掉高功耗也没啥可选的了：</p><table>
<thead>
<tr>
<th align="center">E5-2650V2</th>
<th align="center">E5-2630V2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">8C 16 T</td>
<td align="center">6C 12T</td>
</tr>
<tr>
<td align="center">95 W</td>
<td align="center">80 W</td>
</tr>
<tr>
<td align="center">2.60 GHz</td>
<td align="center">2.60 GHz</td>
</tr>
</tbody></table><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>多是 2012-2015 年的机器，大概来自测试机房；</p><a id="more"></a>



<p>对外观锋利的东西没有抵抗力，超喜欢 1U 的外观，2.5 寸硬盘同理，所以在联想的 R620 和 HP DL360pG8 间进行选择；</p>
<p>最后选择 HP，因为同系列下还有一款 MicroServer Gen8，因为造型小巧玩家群体很广，有问题时可以进行参考，况且：风扇实在太好看了。</p>
<h1 id="风扇"><a href="#风扇" class="headerlink" title="风扇"></a>风扇</h1><p>再好看的风扇都难逃卸载 [，___________都 ________ ]。</p>
<p>定义如下：</p>
<img src="https://i.loli.net/2020/03/03/mFD9CbKB1lncjaH.jpg" alt="IMG_20200303_110558.jpg" style="zoom: 25%;">

<h2 id="降噪"><a href="#降噪" class="headerlink" title="降噪"></a>降噪</h2><p>1U 服务器的改造空间有限，要保持整机结构不变得从原装风扇位上动手：替换 or 优化，替换明显比改造代价要大，对于结果没有预期，可以在整机可用后再考虑。</p>
<p>现有手段分两种，减速和移除，减速即串联电阻降低风扇供电，网上有教程可以自己做，TB 上也有现成的减速线卖，而金钱与物理双缺失下的我选择了移除。ps：服务器风扇一般 20W+，务必关注电阻发热情况。</p>
<p>服务器主板通过独立硬件监控风扇状态，在损坏或缺失情况下会执行关机。所以只好找方法欺骗主板插槽上仍有风扇在运行：</p>
<ul>
<li><p><del>由在线风扇提供转速信号，短接地线</del>：</p>
<p>  <img src="https://i.loli.net/2020/03/02/ycJSb8j9k2wCvqR.jpg" alt="0302-06.jpeg"></p>
<p>  流行且省事的方法，要注意主板对每个模组的转速是动态调整的，借用其他风扇的信号可能会（因为转速不符）触发保护机制。HP 虽然是动态但不存在这个顾虑，原因下面说；</p>
</li>
<li><p>推荐：短接地线和测速线：</p>
<p>  <img src="https://i.loli.net/2020/03/02/Wz4mpvOTIXM8lNB.jpg" alt="0302-05.jpeg"></p>
<p>  来自 <a href="https://homeservershow.com/" target="_blank" rel="noopener">https://homeservershow.com/</a> Microserver Gen 8 版的方法，不出意外在 DL360p 上也通用：</p>
<p>  原贴：<a href="https://homeservershow.com/forums/topic/7294-faking-the-fan-signal/" target="_blank" rel="noopener">Faking the fan signal</a></p>
<blockquote>
<p>There is no need for external circuitry, the type of fan present in the MS Gen8 has a RD ( rotational detect ) tachometer signal.</p>
<p>What that means ? It means that it doesn’t output pulses but just a low voltage ( 0.12V measured ) if the fan spins.</p>
<p>Connection: </p>
<p>You must tie the RD sense pin (yellow cable on the fan wire harness ) to both grounds ( black ).</p>
</blockquote>
<p>  补充 服务器（通常）不可能更换原厂以外的风扇，所以 pwm 控速已经按照原厂风扇的转速曲线固定了，无需接收风扇的脉冲信号。之后控制台的转速监控也证实了这点（显示的是输出值）。<br>  当然，对于更换 pwm 风扇来说就是弊端了，因为转速曲线与原厂不一致，调速效果基本看脸。</p>
</li>
<li><p><del>购买脉冲发生器</del>：</p>
<p>  模拟转速信号给主板，设定好频率后就固定了。原理和第一条一样，提出来在于可以把原装风扇全部移除，而且信号衰减问题会小一点。<br>  (监控转速的无法用定频，不检测转速直接短接就是。</p>
</li>
<li><p>购买风扇拟速器：</p>
<p>  矿场的神奇造物，根据 pwm 信号反馈对应的转速信号，最近更新了模拟 1700-20000 转正好可以模拟服务器风扇，不过是 4pin 需要改一下。适合监控机制特别严苛的主板。</p>
</li>
</ul>
<h2 id="散热"><a href="#散热" class="headerlink" title="散热"></a>散热</h2><p>当前安装的 HPE 定制版 ESXi6.0U3，气温 10℃，风扇基础转速 19%，我的方案是保留 #2 #6 #7 三个风扇，发热大户都在右边，整机控制如下。</p>
<p><img src="https://i.loli.net/2020/03/03/rgO5WuoY7J1UDhE.png" alt="2020-03-03 11-14.png"></p>
<p>需要特别注意 HD Controller 的温度：</p>
<p><img src="https://i.loli.net/2020/03/02/wFQKfha3RUCsIkx.jpg" alt="0302-04.jpeg"></p>
<p>↑开机后从 60 ℃ 起步；风扇没留几个的话建议单独给一个 4010/2010 风扇，供电可以从主板内的 USB 口引。</p>
]]></content>
      <categories>
        <category>瞎折腾</category>
      </categories>
      <tags>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编课程记录 1</title>
    <url>/2019/09/23/%E6%B1%87%E7%BC%96%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-1/</url>
    <content><![CDATA[<h1 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h1><p>为了区分不同的内存单元（一字节），每个单元会分配一个存储器地址；地址在计算机中用无符号二进制数表示，可简写成十六进制<br>而字，双字，四字数据类型占用多个单元，在低地址中存放低位字节数据，高地址存放高位字节数据，访问时根据最低单元的地址依此存取后续字节</p>
<a id="more"></a>
<blockquote>
<p>MSB (Most Significant Byte)，最高有效字节，是一个数据中权值最大的那一个字节<br>LSB (Least Significant Byte)，最低有效字节，是一个数据中权值最小的那一个字节<br>Little-Endian，是指数据的高字节(MSB)保存在内存的高地址中，而数据的低字节(LSB)保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低<br>例如：整型数 0x1A2B3C4D 在内存中存储的方式如下:<br><img src="https://i.loli.net/2019/09/24/kiIS2B8DAxwZdWy.jpg" alt="ram.jpg"></p>
</blockquote>
<h1 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h1><p>本身意义是代表真实的物理地址<br>8086CPU 的数据总线为 16 位，一次最多读取 2^16=64KB 数据（故实模式每个段最大64KB），但地址总线为 20 位，最大寻址能力是 2^20=1MB<br>实模式下存储器物理地址由段基址和偏移量给出。段基址必须定位在 16 的整数倍上，使得在十六进制表示的地址中最低位为 0，于是 1MB 空间的的 20 位地址的低 4 位可以不表示，而高 16 位就可以放进段寄存器。偏移地址虽然是四位但放在十六位寄存器，即可能跨越本身的分段，所以同一个物理地址可以有不同表示。<br><strong>10H × 段基址 + 偏移量 = 物理地址</strong></p>
<ul>
<li>代码段为 CS:IP</li>
<li>堆栈段为 SS:SP</li>
</ul>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>存储器</tag>
        <tag>Little-Endian</tag>
        <tag>实模式寻址</tag>
      </tags>
  </entry>
  <entry>
    <title>数理逻辑名词</title>
    <url>/2019/11/10/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91%E5%90%8D%E8%AF%8D/</url>
    <content><![CDATA[<h1 id="数理逻辑-gt-命题逻辑"><a href="#数理逻辑-gt-命题逻辑" class="headerlink" title="数理逻辑 -&gt; 命题逻辑"></a>数理逻辑 -&gt; 命题逻辑</h1><p><strong>范式</strong><br>真值表的规模会随命题变元（文字）的数量呈指数增长，使用范式替代真值表</p><ul>
<li>有限个简单合取式（短语）的析取称 <u>析取范式</u></li>
<li>有限个简单析取式（子句）的合取称 <u>合取范式</u></li>
</ul><p>否定联结词仅出现在文字之前<br>单独的文字可看作子句 / 短语 / 合取范式 / 析取范式<br>单独的短语 / 子句也可构成析取范式 / 合取范式</p><a id="more"></a>


<ul>
<li>P∨Q∨R 是子句 / 合区范式 / 析取范式 <em>将文字看作短语即析取范式</em></li>
<li>(P∨Q∨R) 是子句 / 合取范式 <em>不可拆分</em></li>
<li>P∨(Q∨R) 既不是合取范式也不是析取范式 <em>析取析取范式，范式关注于当前的书写形式</em></li>
</ul>
<p>析取范式指出公式何时为真，合取范式指出公式何时为假，故能替代真值表<br>命题公式的范式表达不唯一</p>
<hr>
<p><strong>主范式</strong><br>对构成范式的短语和子句进一步规范化，形成唯一的主析取范式和主合区范式<br>极大项：子句状，每个极大项只有一个成假赋值，命题变元对应 0 命题变元的否定对应 1； Mi∨Mj=1<br>极小项：短语状，每个极小项只有一个成真赋值，命题变元对应 1 命题变元的否定对应 0； mi∧mj=0</p>
<ul>
<li>析取范式中，每一个短语都是极小项且按编码从小到大排列，称 <u>主析取范式</u></li>
<li>合取范式中，每一个子句都是极大项且按编码从小到大排列，称 <u>主合取范式</u></li>
</ul>
<p>对任何命题公式，主析取范式与主合取范式的项编码是互补关系<br>包含所有极小项的主析取范式为永真式，包含所有极大项的主合取范式为永假式</p>
<hr>
<p><strong>推理</strong><br>推理的有效性不等同结论的真实性，因为前提可能为假；推理有效等价前提为真结论为真<br>推理规则</p>
<ul>
<li>规则 P ：前提引用规则，可随时引用前提集合中的任意前提…废话</li>
<li>规则 T ：逻辑结果引用规则，可随时引用之前推导出来的逻辑结果…废话</li>
<li>规则 CP ：附加前提规则，多用反证法找冲突</li>
</ul>
<hr>
<h1 id="数理逻辑-gt-谓词逻辑"><a href="#数理逻辑-gt-谓词逻辑" class="headerlink" title="数理逻辑 -&gt; 谓词逻辑"></a>数理逻辑 -&gt; 谓词逻辑</h1><p>解决命题逻辑的局限性（无法表达内部的逻辑关系），如三段论和含变量语句，</p>
<p><strong>个体词</strong><br>可以独立存在的客体，如主语宾语</p>
<ul>
<li>个体词的取值范围称为 <u>个体域（论域）</u></li>
<li>表示具体或特定的个体词称为 <u>个体常量</u></li>
<li>表示抽象或泛指的个体词称为 <u>个体变量</u></li>
</ul>
<hr>
<p><strong>谓词</strong><br>刻画客体性质或客体间关系，采用函数形式表达，定义域在个体域中取值，值域是 0/1</p>
<ul>
<li>表示具体性质或关系的谓词称为 <u>谓词常量</u></li>
<li>表示抽象或泛指的性质或关系的谓词称为 <u>谓词变量</u></li>
<li>没有任何个体变量的谓词称为 <u>0 元谓词</u></li>
</ul>
<hr>
<p><strong>量词</strong><br>全称量词 (∀x) ：每一个，刻画其个体域的特性谓词作为蕴含式的前件加入<br>存在量词 (∃x) ：至少有一个，刻画其个体域的特性谓词作为合取式的合取项加入</p>
<p>真值确定<br>(∀x)G(x) ：任意/所有 x 使 G(x) 为 1 则真；存在 x 使 G(x) 为 0 则假<br>(∃x)G(x) ：存在 x 使 G(x) 为 1 则真；任意/所有 x 使 G(x) 为 0 则假<br>当个体域是有限集合时，真值可用等价的命题公式表示</p>
<ul>
<li>(∀x)G(x) = G(x0) ∨ G(x1)… ∨ G(xn)</li>
<li>(∃x)G(x) = G(x0) ∨ G(x1)… ∨ G(xn)</li>
</ul>
<p>量词辖域<br>若量词后有括号，括号内的子公式为辖域；若量词后无括号，与量词邻接的子公式为辖域</p>
<ul>
<li>变元 x 出现在使用变元的量词的辖域内，称 <u>约束变元</u></li>
<li>若不是约束出现，则为 <u>自由变元</u></li>
<li>一个公式中若无自由出现的个体变元，则称 <u>闭式</u>，故闭式是命题</li>
</ul>
<hr>
<p><strong>前束范式</strong><br>公式中的所有量词都在最前端且不含否定，这些量词的辖域都延伸到公式末端</p>
]]></content>
      <categories>
        <category>离散数学</category>
      </categories>
      <tags>
        <tag>命题逻辑</tag>
        <tag>谓词逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 补丁-输入输出</title>
    <url>/2020/04/12/Java-%E8%A1%A5%E4%B8%81-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h1 id="输入-输出流"><a href="#输入-输出流" class="headerlink" title="输入/输出流"></a>输入/输出流</h1><h2 id="读写字节"><a href="#读写字节" class="headerlink" title="读写字节"></a>读写字节</h2><p>若一个流（对象）不能被立即访问，read 和 write 方法在执行时将被阻塞，在等待流可用的时间里，时间片分给其他线程。available 方法检查当前可读入的字节数量，可以避免阻塞：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> bytesAvailable = in.available();</span><br><span class="line"><span class="keyword">if</span> (bytesAvailable &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[byteAvailable];</span><br><span class="line">		in.read(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>


<p>完成读写后应该调用 close 方法关闭，close 方法释放资源的同时，会送出输出流缓冲区中的字节。人为冲刷缓冲区用 flush 方法。</p>
<h2 id="组合输入输出流过滤器"><a href="#组合输入输出流过滤器" class="headerlink" title="组合输入输出流过滤器"></a>组合输入输出流过滤器</h2><p>通过嵌套过滤器添加功能，例：用 DataInputStream 使用缓冲机制从文件中读取。输入流默认不被缓冲区缓存（ read 每次请求操作系统分发一个字节），DataInputStream 没有从文件中获取数据的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataInputStream din = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">		<span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">			<span class="keyword">new</span> FileInputStream(<span class="string">"test.dat"</span>)));</span><br></pre></td></tr></table></figure>

<p>PushbackInputStream 用于预读下一个字节 <code>int b = pbin.read;</code> ，并退回非期望的值 <code>if(b != &#39;&lt;&#39;) pbin.unread(b);</code> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataInputStream din = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">		pbin = <span class="keyword">new</span> PushbackInputStream(</span><br><span class="line">			<span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">				<span class="keyword">new</span> FileInputStream(<span class="string">"test.dat"</span>))));</span><br></pre></td></tr></table></figure>

<h1 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h1><h2 id="文本输出"><a href="#文本输出" class="headerlink" title="文本输出"></a>文本输出</h2><p>使用 PrintWrite 类建立写出器对象，用 print，println，printf 方法输出到写出器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintfWrite out = <span class="keyword">new</span> PrintWrite(<span class="string">"emp.txt"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">String str = <span class="string">"abc"</span>;</span><br><span class="line">out.print(str);</span><br></pre></td></tr></table></figure>

<p>println 通过 <code>System.getProperty(&quot;line.separator&quot;)</code> 获取当前系统的换行符。<br>自动冲刷：<code>PrintWriter(Writer out, Boolean autoFlush)</code> ，开启后每次调用 println 都会发送缓冲区中的所有字符。默认关闭。</p>
<h2 id="文本输入"><a href="#文本输入" class="headerlink" title="文本输入"></a>文本输入</h2><p>从任何输入流构建 Scanner 对象处理文本。</p>
<p>或者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String content = <span class="keyword">new</span> String(Files.readAllBytes(path), charset);</span><br><span class="line"><span class="comment">// 处理为字符串</span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; lines = Files.readAllLines(path, charset);</span><br><span class="line"><span class="comment">// 按行读入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> (Stream&lt;String&gt; lines = Files.lines(path, charset)) &#123; ... &#125;</span><br><span class="line"><span class="comment">// 处理为 Stream&lt;String&gt; 对象</span></span><br></pre></td></tr></table></figure>

<p>早期版本通过 BufferedReader 类，其 readLine 方法返回一行文本或 null，lines 方法可以产生一个 Stream<string> 对象。没有用于读入数字的方法。</string></p>
<h1 id="读写二进制数据"><a href="#读写二进制数据" class="headerlink" title="读写二进制数据"></a>读写二进制数据</h1><p>Java 中所有值按高位在前的模式写出，以保证 Java 文件独立于平台。</p>
<h2 id="DataInput-和-DataOutput-接口"><a href="#DataInput-和-DataOutput-接口" class="headerlink" title="DataInput 和 DataOutput 接口"></a>DataInput 和 DataOutput 接口</h2><p>DateOutput 接口定义了以二进制格式写数组，字符，布尔值和字符串的方法：<code>writeChars</code> <code>writeByte</code> <code>writeInt</code> <code>writeShort</code> <code>writeLong</code> <code>writeFloat</code> 等。虽然结果非人可读，但对于给定类型的每个值，其所需空间相同，读回也比文本更快。其中 writeUTF 方法先用 UTF-16 表示码元序列，再用 UTF-8 规则编码，所以对于编码大于 0xFFFF 的字符的处理有所不同（为了兼容）。用于虚拟机的字符串才需要 writeUTF 方法（如生成字节码的程序），其他情况应该用 writeChars。</p>
<p>DateInput 接口定义了读回数据的方法。DataInputStream 类通过与字节源相组合，从文件中读入二进制数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataInputStream in = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.dat"</span>));</span><br></pre></td></tr></table></figure>

<p>DataOutputStream 与此类似：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataOutputStream in = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"test.dat"</span>));</span><br></pre></td></tr></table></figure>

<h2 id="随机访问文件"><a href="#随机访问文件" class="headerlink" title="随机访问文件"></a>随机访问文件</h2><blockquote>
<p>随机访问文件的行为类似存储在文件系统中的一个大型 byte 数组。存在指向该隐含数组的光标或索引，称为文件指针；</p>
<p>输入操作从文件指针开始读取字节，并随着对字节的读取而前移此文件指针。如果随机访问文件以读取/写入模式创建，则输出操作也可用；输出操作从文件指针开始写入字节，并随着对字节的写入而前移此文件指针。隐含数组的当前末尾之后的输出操作导致该数组扩展。</p>
</blockquote>
<p><code>RandomAccessFile</code> 类，磁盘文件都可以随机访问，注意套接字通信的流不是。使用字符串 “r” 或 “rw” 作为第二个参数指定只读或可读写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RandomAccessFile in = <span class="keyword">new</span> RandomAccessFile(<span class="string">"file.dat"</span>, <span class="string">"r"</span>);</span><br></pre></td></tr></table></figure>

<p><code>seek</code> 方法用来设置文件指针到文件的任意位置，其参数是一个 long 型整数，<code>getFilePointer</code> 方法返回指针的当前位置。</p>
<p>例，从第三个开始读：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> n = <span class="number">3</span>;</span><br><span class="line">in.seek((n-<span class="number">1</span>) * SIZE); <span class="comment">// 第三个处即第二个末尾</span></span><br><span class="line">Employee e = <span class="keyword">new</span> Employee();</span><br><span class="line">e.readDate(in);</span><br></pre></td></tr></table></figure>

<p>在文件中（非尾部）进行修改只允许进行替换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">in.seek((n-<span class="number">1</span>) * RECORD_SIZE);</span><br><span class="line">e.wirteDate(out);</span><br></pre></td></tr></table></figure>

<p><code>length</code> 方法可以确认文件中的字节总数。</p>
<h2 id="ZIP-文档"><a href="#ZIP-文档" class="headerlink" title="ZIP 文档"></a>ZIP 文档</h2><p>ZIP 文档头包含文件名和压缩方法等信息，使用 ZipInputStream 读入 ZIP 文档，<code>getNextEntry</code> 方法返回描述文档头项目的 ZipEntry 对象，将该项传递给 ZipInputStream 的 getInputStream 方法以获取读取该项的输入流。调用 closeEntry 读入下一项：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ZipInputStream zin = <span class="keyword">new</span> ZipInputStream(<span class="keyword">new</span> FileInputStream(zipname));</span><br><span class="line">ZipEntry entry;</span><br><span class="line"><span class="keyword">while</span>((entry = zin.getNextEntry()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    InputStream in = zin.getInputStream(entry);</span><br><span class="line">    ...</span><br><span class="line">    zin.closeEntry();</span><br><span class="line">&#125;</span><br><span class="line">zin.close();</span><br></pre></td></tr></table></figure>

<p>使用 ZipOutputStream 写出到 ZIP 文件，对要写入的每一项都应该创建一个 ZipEntry 对象，并将文件名传递给 ZipEntry 的构造器，其自动设置如文件日期解压缩方法等参数（也可自定义进行覆盖）。调用 ZipOutputStream 的 putNextEntry 方法将文件数据发送到 ZIP 输出流中，完成时 closeEntry。其后对其他文件重复此过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(<span class="string">"test.zip"</span>);</span><br><span class="line">ZipOutputStream zout = <span class="keyword">new</span> ZipOutputStream(fout);</span><br><span class="line"><span class="comment">// for all files :</span></span><br><span class="line">ZipEntry ze = <span class="keyword">new</span> ZipEntry(filename);</span><br><span class="line">zout.putNextEntry(ze);</span><br><span class="line">...</span><br><span class="line">zout.closeEntry();</span><br><span class="line"></span><br><span class="line">zout.close;</span><br></pre></td></tr></table></figure>

<p>JAR 文件使用 JarInputStream 和 JarOutputStream 类读写，是带有特殊项的 ZIP 文档。</p>
<h1 id="对象输入输出流与序列化"><a href="#对象输入输出流与序列化" class="headerlink" title="对象输入输出流与序列化"></a>对象输入输出流与序列化</h1><h2 id="保存和加载序列化对象"><a href="#保存和加载序列化对象" class="headerlink" title="保存和加载序列化对象"></a>保存和加载序列化对象</h2><p>对象序列化：将对象写出到输出流并可以再读回。类必须实现 Serializable 接口。</p>
<p>首先创建 <code>ObjectOutputStream</code> 对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"test.dat"</span>));</span><br></pre></td></tr></table></figure>

<p><code>ObjectOutputStream</code> 的 <code>writeObject</code> 方法保存对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Employee harry = <span class="keyword">new</span> Employee(<span class="string">"harry"</span>);</span><br><span class="line">out,writeObject(harry)</span><br></pre></td></tr></table></figure>

<p>若要读回，获取一个 ObjectInputStream 对象，然后用 readObject 方法以被写出时的顺序获得对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.dat"</span>));</span><br><span class="line">Employee e = (Employee) in.readObject();</span><br></pre></td></tr></table></figure>

<p>每个对象是用一个序列号保存的：</p>
<ul>
<li>对每个对象引用都关联一个序列号</li>
<li>对每个对象，第一次遇到时保存到输出流</li>
<li>若之前已经保存过，则写出类似“与序列号 x 相同”</li>
</ul>
<p>读入时：</p>
<ul>
<li>对于输入流中的对象，第一次遇到其序列号时构建并初始化</li>
<li>遇到“与序列号 x 相同”时获取对象引用</li>
</ul>
<h2 id="修改默认的序列化机制"><a href="#修改默认的序列化机制" class="headerlink" title="修改默认的序列化机制"></a>修改默认的序列化机制</h2><p>对于只对本地方法有意义的数据域，使用 transient 标记以避免序列化。</p>
<p>为默认的读写方法添加其他行为，序列化的类中定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span> <span class="params">(ObjectInputStream in)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    in.defaultReadObject();</span><br><span class="line">    ...    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span> <span class="params">(ObjectOutputStream out)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    out.defaultWriteObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义序列化机制，必须实现 Externalizable 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span> <span class="params">(ObjectInputStream in)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ClassNotFoundException</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeExternal</span> <span class="params">(ObjectOutputStream out)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure>

<p>这两个方法对包含超类数据在内的整个对象负责，序列化机制在读入时用无参构造器创建一个对象，然后调用 readExternal 方法。</p>
<h2 id="序列化单例和类型安全的枚举"><a href="#序列化单例和类型安全的枚举" class="headerlink" title="序列化单例和类型安全的枚举"></a>序列化单例和类型安全的枚举</h2><p>类型安全的枚举实现 Serializable 接口时不适用默认的序列化机制，即使构造器私有，序列化机制也可以创建新对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orientation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Orientation HORTZONTAL = <span class="keyword">new</span> Orientation(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Orientation VERTICAL = <span class="keyword">new</span> Orientation(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Orientation</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Orientation = Orientation.HORTZONTAL;</span><br><span class="line"><span class="comment">// orientation == Orientation.HORTZONTAL -&gt; true</span></span><br><span class="line"></span><br><span class="line">ObjectOutputStream out = ... ;</span><br><span class="line">out.write(original);</span><br><span class="line">out.close();</span><br><span class="line">ObjectInputStream in = ...;</span><br><span class="line">Orientation saved = (Orientation) in.read();</span><br><span class="line"><span class="comment">// saved == Orientation.HORTZONTAL -&gt; false</span></span><br></pre></td></tr></table></figure>

<p>需要定义 <code>readResolve</code> 特殊序列化方法，其在对象被序列化之后调用。该方法必须返回一个对象，并会成为 readObject 的返回值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">1</span>) <span class="keyword">return</span> Orientation.HORTZONTAL;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="number">2</span>) <span class="keyword">return</span> Orientation.VERTICAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h2><p>将对象序列化到输出流中，然后将其读回，产生的新对象是对现有对象的深拷贝，可以用 <code>ByteArrayOutputStream</code> 将数据保存在数组中而不必写出到文件。</p>
<h1 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h1><h2 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h2><p><code>Paths.get</code> 方法接受一个或多个字符串，并用默认路径分隔符连接（\ /），然后返回 Path 对象。路径不必实际存在，其仅是抽象名字序列，先创建一个路径再调用方法创建对应文件。</p>
<p><code>resolve</code> 方法产生子目录：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path workRelative = Paths.get(<span class="string">"work"</span>);</span><br><span class="line">Path workPath = basePath.resolve(workRelative);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">Path workPath = basePath.resolve(<span class="string">"work"</span>);</span><br></pre></td></tr></table></figure>

<p><code>resolveSibling</code> 方法产生兄弟路径：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path tempPath = workPath.resolveSibling(<span class="string">"temp"</span>);</span><br></pre></td></tr></table></figure>

<p>相对化路径 <code>relativize</code> 方法，<code>normalize</code> 移除冗余，<code>toAbsolutePath</code> 产生给定路径的绝对地址。及诸如 <code>getParent()</code> <code>getFilename</code> 等。</p>
<h2 id="读写文件-1"><a href="#读写文件-1" class="headerlink" title="读写文件"></a>读写文件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = Files.readAllBytes(path); <span class="comment">// 读入</span></span><br><span class="line">String content = <span class="keyword">new</span> String(bytes, charset); <span class="comment">// 作字符串</span></span><br><span class="line">List&lt;String&gt; lines = Files.readAllLines(path, charset); <span class="comment">// 作行序列读入</span></span><br><span class="line">Files.write(path, content.getBytes(charset)); <span class="comment">// 写出字符串</span></span><br><span class="line">Files.write(path, context.getBytes(charset), StandardOpenOption.APPEND);</span><br><span class="line"><span class="comment">// 追加内容</span></span><br><span class="line">Files.write(path, lines); <span class="comment">// 写出行集合</span></span><br></pre></td></tr></table></figure>

<p>适合中等长度的文本文件，若文件长度较大或为二进制，应当使用输入输出流或读入写入器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStream in = Files.newInputStream(path);</span><br><span class="line">Reader in = Files.newBufferedReader(path, charset);</span><br></pre></td></tr></table></figure>

<h2 id="创建文件和目录"><a href="#创建文件和目录" class="headerlink" title="创建文件和目录"></a>创建文件和目录</h2><p>路径中除最后一个，都已存在：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Files.createDirctory(path);</span><br></pre></td></tr></table></figure>

<p>创建路径中的中间目录：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Files.createFile(path);</span><br></pre></td></tr></table></figure>

<p><code>createTempFile()</code> 和 <code>createTempDirectory()</code> 用于创建临时文件和目录。</p>
<h2 id="复制移动删除文件"><a href="#复制移动删除文件" class="headerlink" title="复制移动删除文件"></a>复制移动删除文件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Files.copy(fromPath, toPath); <span class="comment">// 已存在则失败</span></span><br><span class="line">Files.move(fromPath, toPath); <span class="comment">// 已存在则失败</span></span><br><span class="line">Files.copy(fromPath, toPath, StandardCopyOption.REPLACE_EXISTING,</span><br><span class="line">    StandardCopyOption.COPY_ATTRIBUTES);</span><br><span class="line"><span class="comment">// 覆盖目标，复制所有文件属性</span></span><br><span class="line">Files.move(fromPath, toPath, StandardCopyOption.ATOMIC_MOVE);</span><br><span class="line"><span class="comment">// 原子移动，完成或保持原位</span></span><br><span class="line">Files.copy(inputStream, toPath);</span><br><span class="line">Files.copy(fromPath, outputStream);</span><br><span class="line">Files.delete(path); <span class="comment">// 失败抛异常</span></span><br><span class="line">Files.deleteIfExists(path); <span class="comment">// 返回 bool 值，可作为 delete 替代</span></span><br></pre></td></tr></table></figure>

<h2 id="访问目录中的项"><a href="#访问目录中的项" class="headerlink" title="访问目录中的项"></a>访问目录中的项</h2><p><code>Files.list</code> 方法返回一个可以读取目录中项的 Stream<path> 对象，若要进入子目录，使用 <code>File.walk</code> 方法，File.walk(pathToRoot, depth) 限制树的深度。涉及系统资源要 try 块。</path></p>
<h2 id="目录流"><a href="#目录流" class="headerlink" title="目录流"></a>目录流</h2><p>比 walk 更细粒的控制，<code>File.newDirectoryStream</code> 是 Iterable 的子接口，可以用于增强 for 循环。</p>
<p>使用 glob 模式过滤文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (DirectoryStream&lt;Path&gt; entries = Files.newDirectoryStream(dir, <span class="string">"*.java"</span>));</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="center">描述</th>
<th align="center">例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">*</td>
<td align="center">匹配路径中 0 或多个字符</td>
<td align="center">当前目录中匹配</td>
</tr>
<tr>
<td align="center">**</td>
<td align="center">匹配跨目录的 0 或多个字符</td>
<td align="center">子目录中匹配</td>
</tr>
<tr>
<td align="center">?</td>
<td align="center">匹配一个字符</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">[…]</td>
<td align="center">匹配字符集和</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">{…}</td>
<td align="center">匹配 , 隔开的可选项之一</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">\</td>
<td align="center">转译</td>
<td align="center"><em>*</em> 带 * 的文件</td>
</tr>
</tbody></table>
<p>若要访问某个目录的所有子孙成员，调用 <code>walkFileTree</code> 方法，并传递一个 FileVisitor 类型的对象，</p>
<ul>
<li><p>遇到文件或目录：<code>FileVisitResult visitFile(T path, BasicFileAtttributes attrs)</code></p>
</li>
<li><p>在一个目录被处理前：<code>FileVisitResult perVisitDirectory(T dir, IOException ex)</code></p>
</li>
<li><p>在一个目录被处理后：<code>FileVisitResult postVisitDirectory(T dir, IOException ex)</code></p>
</li>
<li><p>试图访问时发生错误：<code>FileVisitResult visitFileFailed(path, IOException)</code></p>
</li>
</ul>
<p>以上情况可用的操作：</p>
<ul>
<li>继续访问下一个：<code>FileVisitResult.CONTINUE</code></li>
<li>继续访问，但不再访问这个目录下的任何项：<code>FileVisitResult.SKIP_SUBBTREE</code></li>
<li>继续访问，但不再访问这个文件的兄弟文件：<code>FileVisitResult.SKIP_SIBLINGS</code></li>
<li>终止访问：<code>FileVisitResult.TERMINATE</code></li>
</ul>
<p>任何方法抛出异常将终止访问，并从 walkFileTree 方法抛出。</p>
<p><code>SimpleFileVisitor</code> 实现了 FileVisitor 接口，除 visitFileFailed 方法外不做任何处理即直接访问。由 visitFileFailed 方法抛出由失败导致的异常，并终止访问。</p>
<p>例，删除目录树：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Files.walkFileTree(Paths.get(<span class="string">"/"</span>), <span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAtttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            Files.delete(file);</span><br><span class="line">            <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">postVisitDirectory</span><span class="params">(Path dir, IOException e)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(e != <span class="keyword">null</span>) <span class="keyword">throw</span> e;</span><br><span class="line">            Files.delete(dir);</span><br><span class="line">            <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>覆盖 postVisitDirectory 方法，防止遇到不允许打开的目录或不允许访问的文件时立刻失败。</p>
<h2 id="ZIP-文件系统"><a href="#ZIP-文件系统" class="headerlink" title="ZIP 文件系统"></a>ZIP 文件系统</h2><p>建立一个包含 ZIP 文档所有文件的文件系统：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileSystem fs = FileSystems.newFileSystem(Paths.get(zipname), <span class="keyword">null</span>);</span><br><span class="line">Files.copy(fs.getPath(sourceName), targetPAth);</span><br></pre></td></tr></table></figure>

<h1 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先从文件中获取一个通道（磁盘文件的抽象），以获得访问内存映射等特性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileChannel channel = FileCHannel.open(path, options);</span><br></pre></td></tr></table></figure>

<p>调用 <code>FileChannel</code> 类的 map 方法获得一个 ByteBuffer，可以指定模式：</p>
<ul>
<li>FileChannel.MapMode.READ_ONLY</li>
<li>FileChannel.MapMode.READ_WRITE</li>
<li>FileChannel.MapMode.PRIVATE 可写，但不会写回进文件</li>
</ul>
<p>然后使用 ByteBuffer 和 Buffer 超类方法读写。缓冲区支持顺序和随机访问，有一个通过 get put 操作移动的位置。</p>
<p>顺序遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">		<span class="keyword">byte</span> b = buffer.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随机访问：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; buffer.limit(); i++) &#123;</span><br><span class="line">		<span class="keyword">byte</span> b = buffer.get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读写字节数组：</p>
<ul>
<li>get(byte[] bytes)</li>
<li>get(bytes[], int offset, int length)</li>
</ul>
<p>读入二进制基本类型：</p>
<ul>
<li>getInt</li>
<li>getLong</li>
<li>getChar</li>
<li>…</li>
</ul>
<p>写入数字：</p>
<ul>
<li>putInt</li>
<li>putLong</li>
<li>…</li>
</ul>
<h2 id="缓冲区数据结构"><a href="#缓冲区数据结构" class="headerlink" title="缓冲区数据结构"></a>缓冲区数据结构</h2><p>缓冲区是由具有相同类型的数值构成的数组，Buffer 是一个抽象类，其具体子类有 ByteBuffer Charbuffer DoubleBuffer 等（没有 StringBuffer ！）。</p>
<p>0 &lt;= 标记 &lt;= 位置 &lt;= 界限 &lt;= 容量</p>
<p>缓冲区执行写读循环，假设不断 put 填充缓冲区，当耗尽所有数据或达到容量大小切换读入操作；<br>调用 flip 方法将界限设置到当前位置，然后位子复位到 0，当 remaining 方法返回正数就不断调用 get，当读入所有数值后，用 clear 复位位置到 0，恢复界限到容量，等待下次写循环。</p>
<p>获取缓冲区有 ByteBuffer.allocate 或 ByteBuffer.warp 等方法，使用某个通道的数据填充。</p>
<h2 id="文件加锁"><a href="#文件加锁" class="headerlink" title="文件加锁"></a>文件加锁</h2><p>锁定一个文件使用 FileChannel 类的 <code>lock</code> 或 <code>trylock</code> 方法，前者会阻塞至可获得锁，后者将立刻返回锁或 null。文件将锁定至通道关闭或在锁上调用 release 方法。</p>
<p>锁定文件的一部分：<code>lock(long start, long size, boolean shared)</code> 或 <code>trylock(long start, long size, boolean shared)</code> ,share 标志为 false 则锁定文件的目的是读写，若为 true 允许多个进程从文件读入并阻止进程获得独占的锁。注意这依赖于操作系统。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>汇编课程记录 2</title>
    <url>/2019/10/06/%E6%B1%87%E7%BC%96%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-2/</url>
    <content><![CDATA[<p>太困了没听… 实际上不算课程记录…</p><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>CPU 优先读写寄存器，依靠名称而非地址区分数据。80386 以上的 CPU 有 </p><p>8 个 32 位通用寄存器：</p><ul>
<li>EAX 有时也是累加器</li>
<li>EBX</li>
<li>ECX</li>
<li>EDX</li>
<li>ESP 栈指针/栈顶指针，栈顶的偏移量</li>
<li>EBP</li>
<li>ESI</li>
<li>EDI</li>
</ul><p>6 个 16 位段寄存器</p><ul>
<li>CS 代码段</li>
<li>SS 堆栈段，配合 ESP 食用</li>
<li>DS 主数据段</li>
<li>ES 附加数据段</li>
<li>FS</li>
<li>GS</li>
</ul><a id="more"></a>





<p>2 个 32 位控制寄存器</p>
<ul>
<li>EIP 指令指针，存放偏移量部分，配合 CS 指出下一条指令的地址</li>
<li>FLAGS 标志寄存器</li>
</ul>
<h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>堆 Heap<br>来自用户主动请求，从起始地址开始向高位增长，不会自动消失</p>
<p>栈 Stack<br>函数运行而临时占用的内存区域，为每个函数建立一个桢，运行结束则回收桢释放内部变量不再占用内存，由内存区域的结束地址开始向低位，后进先出；<br>生成新的帧即入栈 push；栈的回收即出栈 pop</p>
<h1 id="段寄存器装入"><a href="#段寄存器装入" class="headerlink" title="段寄存器装入"></a>段寄存器装入</h1><p>ASSUME 仅指出段和段寄存器之间的关系，并未真正装入</p>
<p>DS/ES<br>串操作的目操作数必须为 ES:DI</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOV AX,DATA</span><br><span class="line">MOV DS,AX</span><br></pre></td></tr></table></figure>

<p>CS IP<br>利用 END 后标号完成，系统自动将 START 所在段段地址送 CS 段内偏移地址送 IP</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">START:</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    END    START</span><br></pre></td></tr></table></figure>

<p>SS SP<br>定义堆栈段时将参数写全，则系统自动装入，用于堆栈的内存段地址送 SS，该堆栈的栈顶送 SP</p>
]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>寄存器</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编课程记录 3</title>
    <url>/2019/10/27/%E6%B1%87%E7%BC%96%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-3/</url>
    <content><![CDATA[<h1 id="数据寻址方式"><a href="#数据寻址方式" class="headerlink" title="数据寻址方式"></a>数据寻址方式</h1><p><strong>立即数寻址</strong><br>操作数直接存放于指令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOV AX,1234H    ;即1234H</span><br></pre></td></tr></table></figure><p><strong>寄存器寻址</strong><br>操作数存放于 CPU 的某个寄存器中，不需访问存储器速度快<br>8 位操作数寄存器可以是 AH AL BH BL CH CL DH DL<br>16 位操作数寄存器可以是 AX BX CX DX SP BP SI DI</p><a id="more"></a>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOV AX,BX</span><br></pre></td></tr></table></figure>

<p><strong>存储器直接寻址</strong><br>数据在存储器中，存储单元的有效地址（即偏移地址 EA）由指令直接给出。计算机通过段基址和有效地址获得物理地址（左移四位 + 偏移量balabala），段基址默认为 DS 数据段<br>允许段跨越前缀和符号地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOV AX,[100H]</span><br><span class="line">MOV AX,A1</span><br><span class="line">MOV AX,[A1]    ;和上面那条等效，方括号可加可不加</span><br><span class="line">MOV AX,ES:[100H]    ;取 ES 段段基址，加偏移量 100H</span><br></pre></td></tr></table></figure>

<p><strong>寄存器间接寻址</strong><br>操作数在存储器中，寄存器的内容作为操作数的有效地址<br>所有间接寻址中，仅可使用 BX BP SI DI，其中 BP 默认段是 SS 的堆栈段，其余为 DS 的数据段<br>允许段跨越前缀和符号地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOV AX,[SI]</span><br></pre></td></tr></table></figure>

<p><strong>寄存器相对寻址</strong><br>操作数的有效地址是一个基址寄存器（BX/BP）或变址寄存器（SI/DI）内容与指令中指定的 8/16 位偏移量之和<br>允许段跨越前缀和符号地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOV AX,100H[SI]</span><br><span class="line">MOV AX,[SI+100H]    ;和上面那条等效</span><br><span class="line">MOV AX,COUNT[SI]</span><br><span class="line">;COUNT 为 16 位位移量的符号地址，设 (DS)=3000H (SI)=2000H COUNT=3000H (35000H)=5678H</span><br><span class="line">;物理地址 = 30000H + 2000H + 3000H = 35000H 即(AX)=5678H</span><br></pre></td></tr></table></figure>

<p><strong>基址变址寻址</strong><br>操作数的有效地址是一个基址寄存器的内容加上一个变址寄存器的内容，与 DS/SS 的内容组合为物理地址，BX 默认段则为 DS，BP 默认段则为 SS，适用于数组或表格处理，首地址存放在基址寄存器中，用变址寄存器访问数组的元素<br>允许段跨越前缀</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOV AX,[BX][DI]</span><br></pre></td></tr></table></figure>

<p><strong>相对基址变址寻址</strong><br>基址变址寻址的基础上再加一个指令中的 8/16 位位移量，适用于二维数组，偏移量指向文件首，基址寄存器指向某记录，变址寄存器指向记录中的元素<br>允许段跨越前缀和符号地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOV AX,MASK[BX][SI]</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="程序转移寻址方式"><a href="#程序转移寻址方式" class="headerlink" title="程序转移寻址方式"></a>程序转移寻址方式</h1><p>程序的执行由指令的地址指针（CS 和 IP）决定，IP 的内容会自动改变指向下一条指令的地址，若需要改变程序的执行顺序，需要修改 IP CS 的内容；段内转移仅改变 IP 地址，段间转移因为不在同一个代码段同时要改变 CS 的值</p>
<p><strong>段内直接寻址</strong><br>转向的有效地址是相对于当前 IP 值的 8/16 位位移量，即 IP 寄存器内容与指令中指定的位移量之和，使用于条件转移和无条件转移<br>用于条件转移指令时位移量仅允许 8 位，用于无条件转移指令时，8 位称短跳转，16 位称近跳转</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JMP SHORT ADDR2    ;短跳转</span><br><span class="line">JMP NEAR PTR ADDR1    ;近跳转</span><br></pre></td></tr></table></figure>

<p><strong>段内间接寻址</strong><br>转向的有效地址是一个寄存器或一个存储单元的内容，通过除立即数寻址以外的任何寻址方式获得，然后取代 IP 寄存器的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JMP BX</span><br><span class="line">JMP WORD PTR [BX+ADDR]    ;WORD PTR 指出其后的地址长度为一个字</span><br></pre></td></tr></table></figure>

<p><strong>段间直接寻址</strong><br>在指令中直接提供转向地址和偏移地址，分别取代 CS 和 IP 寄存器的内容<br>FAR PTR 段间转移操作符，允许符号地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JMP FAR PTR ADDR</span><br></pre></td></tr></table></figure>

<p><strong>段间间接寻址</strong><br>用存储器中两个相继字的内容取代 IP 和 CS 的内容，通过除立即数寻址和寄存器寻址以外的任何寻址方式获得，有效地址的第一个字作为转移偏移地址送 IP 寄存器，第二个字节作为转移段地址送 CS 寄存器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JMP DWORD PTR [ADDR+BX]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>数据寻址</tag>
        <tag>程序转移寻址</tag>
        <tag>寻址方式</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编课程记录 4</title>
    <url>/2019/11/04/%E6%B1%87%E7%BC%96%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-4/</url>
    <content><![CDATA[<p>这篇里的指令都不影响标志位</p><h1 id="通用数据传送指令"><a href="#通用数据传送指令" class="headerlink" title="通用数据传送指令"></a>通用数据传送指令</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOV DST,SRC ;传送指令</span><br></pre></td></tr></table></figure><p>目不能为 CS IP 或立即数<br>存储单元和段寄存器之间不能直接传送数据，要用通用寄存器为桥梁<br>立即数不能直接送到段寄存器，同样要用通用寄存器为桥梁</p><hr><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUSH SRC ;进栈指令</span><br><span class="line">;(SP) ⬅ (SP) -2</span><br><span class="line">;((SP+1), (SP)) ⬅ (SRC)</span><br><span class="line">POP DST ;出栈指令</span><br><span class="line">;(DST) ⬅ ((SP+1), (SP))</span><br><span class="line">;(SP) ⬅ (SP) +2</span><br></pre></td></tr></table></figure><a id="more"></a>






<p>PUSH 操作数为 16 位的寄存器，存储器，不允许立即数，避免 PUSH SP，因为 8086/8088 和 80286 对此的处理方式不同<br>POP 目为 16 位的寄存器（不允许 CS 段寄存器），存储器<br>堆栈的存取必须以字为单位，PUSH 和 POP 只能做字操作</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">XCHG DST, SCR ;交换指令</span><br></pre></td></tr></table></figure>

<p>两个操作数必须有一个在寄存器中，且不允许段寄存器，允许字或字节操作（长度 8/16 位），允许立即数寻址以外的寻址方式</p>
<h1 id="累加器专用传送指令"><a href="#累加器专用传送指令" class="headerlink" title="累加器专用传送指令"></a>累加器专用传送指令</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IN AL, PORT ;长格式-字节</span><br><span class="line">IN AX, PORT ;长格式-字</span><br><span class="line">IN AL, DX ;短格式-字节</span><br><span class="line">IN AX, DX ;短格式-字</span><br></pre></td></tr></table></figure>

<p>将外部设备的信息输入到 CPU 的累加器 AL/AX 中，源操作数是外部设备端口地址，通过 DX 寄存器指明的地址可以间接寻址 65536 个端口，而用立即数直接指明的地址只能寻址 256 个</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OUT PORT, AL ;长格式-字节</span><br><span class="line">OUT PORT, AX ;长格式-字</span><br><span class="line">OUT DX, AL ;短格式-字节</span><br><span class="line">OUT DX, AX ;短格式-字</span><br></pre></td></tr></table></figure>

<p>将 CPU 累加器中的信息输出到外部设备，基本和 IN 反过来</p>
<h1 id="地址传送指令"><a href="#地址传送指令" class="headerlink" title="地址传送指令"></a>地址传送指令</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LEA REG, SRC ;有效地址送寄存器指令</span><br><span class="line"></span><br><span class="line">LEA BX, TABLE</span><br><span class="line">MOV BX, OFFSET TABLE</span><br><span class="line">;两个功能相同，MOV 执行速度比 LEA 快，但 OFFSET 只能用简单符号地址</span><br><span class="line">;与 MOV DST,SRC 区别，此处得到的是有效地址而非存储单元的内容</span><br></pre></td></tr></table></figure>

<p>REG 表示寄存器，将源操作数的有效地址送到指定寄存器，且必须为 16 位通用寄存器</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LDS REG, SRC ;送寄存器和 DS 指令</span><br><span class="line">LES REG, SRC ;送寄存器和 ES 指令</span><br><span class="line">;(REG) ⬅ (SRC)</span><br><span class="line">;(SREG) ⬅ (SRC+2)</span><br><span class="line">;将存储单元中存放的 16 位偏移地址（即 SRC 的内容）装入</span><br><span class="line">;指定寄存器，然后将（SRC+2）中的 16 位段地址装入指定的</span><br><span class="line">;段寄存器</span><br></pre></td></tr></table></figure>

<p>SREG 表示 DS 或 ES，源操作数只能用存储器寻址，目不允许段寄存器</p>
<h1 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CBW ;字节转字</span><br><span class="line">;将 AL 中的内容扩展到 AH，若 (AL) 最高有效位为 0，</span><br><span class="line">;则 (AH) 为 0，为 1，则 (AH) =0FFH</span><br><span class="line">CWD ;字转双字</span><br><span class="line">;将 AX 中的内容扩展到 DX，形成 DX:AX 双字，</span><br><span class="line">;若 (AX) 最高有效位为 0，则 (DX) 为 0，为 1，则 (DX) =0FFFFH</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>指令系统</tag>
        <tag>数据传送</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编课程记录 6</title>
    <url>/2019/11/17/%E6%B1%87%E7%BC%96%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-6/</url>
    <content><![CDATA[<p>（没有遵循标题格式…因为显示的差别太小了…</p><h1 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h1><h2 id="无条件转移指令"><a href="#无条件转移指令" class="headerlink" title="无条件转移指令"></a>无条件转移指令</h2><p><strong>段内直接转移</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JMP SHORT 目标标号</span><br><span class="line">;(IP) ← (IP)+8位位移量、、</span><br><span class="line">;8 位短转移</span><br><span class="line">JMP NEAR PTR 目标标号</span><br><span class="line">;(IP) ← (IP)+16位位移量</span><br><span class="line">;16 位近转移</span><br></pre></td></tr></table></figure><p><strong>段内间接转移</strong><br>用寄存器或存储单元的内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JMP 字地址指针</span><br><span class="line">;(IP) ← (EA)</span><br></pre></td></tr></table></figure><a id="more"></a>






<p><strong>段间直接转移</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JMP FAR PTR 目标标号</span><br><span class="line">;(IP) ← 目标标号的段内偏移地址</span><br><span class="line">;(CS) ← 目标标号所在段的段基址</span><br></pre></td></tr></table></figure>

<p><strong>段间间接转移</strong><br>32 位双字，前两个字节送 IP，后；两个字节送 CS</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JMP DWORD PTR 目标标号</span><br><span class="line">;(IP) ← (EA)</span><br><span class="line">;(CS) ← (EA+2)</span><br></pre></td></tr></table></figure>

<h2 id="条件转移指令"><a href="#条件转移指令" class="headerlink" title="条件转移指令"></a>条件转移指令</h2><p>条件转移指令只能使用段内直接寻址的 8 位位移量</p>
<p><strong>根据单个标志位设置情况</strong></p>
<table>
<thead>
<tr>
<th align="center">格式</th>
<th align="center">标志设置</th>
<th align="center">测试条件</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JC/JNC 地址标号</td>
<td align="center">CF=1/CF=0</td>
<td align="center">有/无进位则转移</td>
</tr>
<tr>
<td align="center">JE/JNE 地址标号</td>
<td align="center">ZF=1/ZF=0</td>
<td align="center">结果相等/不相等则转移</td>
</tr>
<tr>
<td align="center">JZ/JNZ 地址标号</td>
<td align="center">ZF=1/ZF=0</td>
<td align="center">结果为零/不为零则转移</td>
</tr>
<tr>
<td align="center">JS/JNS 地址标号</td>
<td align="center">SF=1/SF=0</td>
<td align="center">结果为负/正则转移</td>
</tr>
<tr>
<td align="center">JO/JNO 地址标号</td>
<td align="center">OF=1/OF=0</td>
<td align="center">结果溢出/不溢出则转移</td>
</tr>
<tr>
<td align="center">JP/JNP 地址标号</td>
<td align="center">PF=1/PF=0</td>
<td align="center">奇偶位为 1/0 则转移</td>
</tr>
</tbody></table>
<p><strong>比较两个无符号数</strong></p>
<table>
<thead>
<tr>
<th align="center">格式</th>
<th align="center">测试条件</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JA/JNBE 地址标号</td>
<td align="center">高于/不低于等于时转移</td>
</tr>
<tr>
<td align="center">JAE/JNB 地址标号</td>
<td align="center">高于等于/不低于时转移</td>
</tr>
<tr>
<td align="center">JB/JNAE 地址标号</td>
<td align="center">低于/不高于等于时转移</td>
</tr>
<tr>
<td align="center">JBE/JNA 地址标号</td>
<td align="center">低于等于/不高于转移</td>
</tr>
</tbody></table>
<p><strong>比较两个带符号数</strong></p>
<table>
<thead>
<tr>
<th align="center">格式</th>
<th align="center">测试条件</th>
</tr>
</thead>
<tbody><tr>
<td align="center">JG/JNLE OPR</td>
<td align="center">大于/不小于等于时转移</td>
</tr>
<tr>
<td align="center">JGE/JNL OPR</td>
<td align="center">大于等于/不小于时转移</td>
</tr>
<tr>
<td align="center">JL/JNGE OPR</td>
<td align="center">小于/不大于等于时转移</td>
</tr>
<tr>
<td align="center">JLE/JNG OPR</td>
<td align="center">小于等于/不大于时转移</td>
</tr>
</tbody></table>
<p><strong>测试 CX 的值为 0 则转移</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JCXZ 地址标号</span><br><span class="line">;若 CX 寄存器的内容为零，则转移到指定地址标号</span><br></pre></td></tr></table></figure>

<h2 id="循环控制指令"><a href="#循环控制指令" class="headerlink" title="循环控制指令"></a>循环控制指令</h2><p>用 CX 寄存器作为计数器控制程序的循环，目地址只能用段内直接寻址的 8 位位移量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOOP 标号</span><br><span class="line">;循环指令</span><br><span class="line">;(CX) ⬅ (CX)-1</span><br><span class="line">;(CX) ≠ 0，则转移至标号处循环直至 (CX)=0</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOOPZ(LOOPE) 标号</span><br><span class="line">;为零/相等循环指令</span><br><span class="line">;(CX) ⬅ (CX)-1</span><br><span class="line">;(CX) ≠ 0，且 ZF=1 则循环直至 (CX)=0</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOOPNZ(LOOPNE) 标号</span><br><span class="line">;不为零/不相等循环指令</span><br><span class="line">;(CX) ⬅ (CX)-1</span><br><span class="line">;(CX) ≠ 0，且 ZF=0 则循环直至 (CX)=0</span><br></pre></td></tr></table></figure>

<h2 id="过程调用和返回指令"><a href="#过程调用和返回指令" class="headerlink" title="过程调用和返回指令"></a>过程调用和返回指令</h2><p><strong>CALL 子进程调用指令</strong><br>段内直接近调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CALL DST</span><br><span class="line">CALL NEAR PTR DST (DST一般为子程序名)</span><br><span class="line">;PUSH (IP)</span><br><span class="line">;(IP) ⬅ (IP)+D16</span><br><span class="line">;将子程序的返回地址存入堆栈以便子程序返回时使用</span><br><span class="line">;DST 给出转向地址即子程序入口</span><br><span class="line">;D16 为机器指令中的位移量，是转向地址和返回地址之间的差值</span><br></pre></td></tr></table></figure>

<p>段内间接近调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CALL DST</span><br><span class="line">CALL WORD PTR DST (DST 为通用寄存器或字存储器)</span><br><span class="line">;PUSH (IP)</span><br><span class="line">;(IP) ⬅ (EA)</span><br><span class="line">;DST 可用寄存器寻址和存储器寻址</span><br></pre></td></tr></table></figure>

<p>段间直接远调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CALL FAR PTR DST (DST 一般为子程序名)</span><br><span class="line">;PUSH (CS)</span><br><span class="line">;PUSH (IP)</span><br><span class="line">;(IP) ⬅ DST 指定的偏移地址</span><br><span class="line">;(CS) ⬅ DST 指定的段地址</span><br></pre></td></tr></table></figure>

<p>段间间接远调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CALL DWORD PTR DST (DST 为双字存储器)</span><br><span class="line">;PUSH (CS)</span><br><span class="line">;PUSH (IP)</span><br><span class="line">;(IP) ⬅ (EA)</span><br><span class="line">;(CS) ⬅ (EA)+2</span><br><span class="line">;EA 是由 DST 的寻址方式确定的有效地址</span><br><span class="line">;可使用任一的存储器寻址方式取得 EA</span><br></pre></td></tr></table></figure>

<p><strong>RET 子程序返回指令</strong><br>在子程序的末尾，使完成后返回调用处，返回地址是调用子程序时放在堆栈中的，RET 操作时返回地址出栈送 IP 寄存器 和 CS 寄存器（仅段间）</p>
<p>段内近返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RET</span><br><span class="line">;(IP) ⬅ POP()</span><br></pre></td></tr></table></figure>

<p>段内带立即数近返回<br>允许返回地址出栈后修改的指针，便于调用程序再用 CALL 指令调用子程序前把子程序所需要的参数入栈，当子程序返回后修改指针使其指向参数入栈以前的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RET EXP</span><br><span class="line">;(IP) ⬅ POP()</span><br><span class="line">;(SP) ⬅ (SP)+D16</span><br></pre></td></tr></table></figure>

<p>段间远返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RET</span><br><span class="line">;(IP) ⬅ POP()</span><br><span class="line">;(CS) ⬅ POP()</span><br></pre></td></tr></table></figure>

<p>段间带立即数远返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RET EXP</span><br><span class="line">;(IP) ⬅ POP()</span><br><span class="line">;(CS) ⬅ POP()</span><br><span class="line">;(SP) ⬅ (SP)+D16</span><br></pre></td></tr></table></figure>

<h1 id="中断指令"><a href="#中断指令" class="headerlink" title="中断指令"></a>中断指令</h1><p>CPU 暂时中止现行程序转向另一处处理程序称为中断</p>
<p><strong>int 软中断</strong><br>将控制转向一个型号为 n 的软中断，该中断处理程序入口地址在中断向量表的 n*4 地址处的两个存储字中，n 为类型号，可以是 0-255 的常数或常数表达式，影响 IF TF 标志位</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INT n</span><br><span class="line">;PUSH (FLAGES)</span><br><span class="line">;IF ⬅️ 0</span><br><span class="line">;TF ⬅️ 0</span><br><span class="line">;AC ⬅️ 0</span><br><span class="line">;PUSH (CS)</span><br><span class="line">;PUSH (IP)</span><br><span class="line">;(IP) ⬅️ (n*4)</span><br><span class="line">;(CS) ⬅️ (n*4+2)</span><br></pre></td></tr></table></figure>

<p><strong>IRET 中断返回指令</strong><br>从中断程序处理程序返回主程序，恢复中断前的 CS 和 IP 的内容，软中断硬中断皆可，影响所有标志位</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IRET</span><br><span class="line">;(IP)  ⬅️ POP()</span><br><span class="line">;(CS) ⬅️ POP()</span><br><span class="line">;(FLAGES) ⬅️ POP()</span><br></pre></td></tr></table></figure>

<p><strong>INTO 溢出中断指令</strong><br>立即产生一个中断类型为 4 的中断，OF=0 时不起作用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INTO</span><br><span class="line">;若 OF=1 则</span><br><span class="line">;PUSH (FLAGES)</span><br><span class="line">;IF ⬅️ 0</span><br><span class="line">;TF ⬅️ 0</span><br><span class="line">;AC ⬅️ 0</span><br><span class="line">;PUSH (CS)</span><br><span class="line">;PUSH (IP)</span><br><span class="line">;(IP) ⬅️ (10H)</span><br><span class="line">;(CS) ⬅️ (12H)</span><br></pre></td></tr></table></figure>

<h1 id="处理器控制指令"><a href="#处理器控制指令" class="headerlink" title="处理器控制指令"></a>处理器控制指令</h1><h2 id="标志位操作指令"><a href="#标志位操作指令" class="headerlink" title="标志位操作指令"></a>标志位操作指令</h2><p>对 CF DF IF 进行设置<br><strong>进位位标志操作指令</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CLC</span><br><span class="line">;进位位清 0 指令</span><br><span class="line">STC</span><br><span class="line">;进位位置 1 指令</span><br><span class="line">CMC</span><br><span class="line">;进位位求反指令</span><br></pre></td></tr></table></figure>

<p><strong>方向标志操作指令</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CLD</span><br><span class="line">;方向标志清 0 指令</span><br><span class="line">STD</span><br><span class="line">;方向标志置 1 指令</span><br></pre></td></tr></table></figure>

<h2 id="其他处理器控制指令"><a href="#其他处理器控制指令" class="headerlink" title="其他处理器控制指令"></a>其他处理器控制指令</h2><p>都不影响标志位<br><strong>NOP 空操作指令</strong><br>不执行任何操作，其机器码占用一个字节单元，通常用于调试程序时替代被删除指令的机器码而无须重新汇编链接；或在延时程序中作为延时时间的调节</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NOP</span><br></pre></td></tr></table></figure>

<p><strong>HLT 停机指令</strong><br>使处理器暂停不进行任何操作，当 CPU 发生复位或来自外部的中断时，脱离暂停状态。用于程序中断等待，在 PC 机中会引发死机，一般的应用程序不要使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HLT</span><br></pre></td></tr></table></figure>

<p><strong>WAIT 等待指令</strong><br>使处理器处于空转等待状态，不做任何操作，也可以用来等待外部中断的发生，但中断结束后仍然返回 WAIT 继续等待；可用于与 ESC 指令配合等待协处理器的执行结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WAIT</span><br></pre></td></tr></table></figure>

<p><strong>ESC 换码指令</strong><br>指定协处理器接受指令和数据，CPU 将控制权交给协处理器，第一个数据 OP 操作码，第二个数据为操作数（寄存器 REG 或存储器 MEM 中的内容）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ESC OP,	REG/MEM</span><br></pre></td></tr></table></figure>

<p><strong>LOCK 封锁指令</strong><br>是指令前缀，与其他指令配合维持总栈的控制权不被其他处理器占有，直到与其配合的指令执行完毕</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOCK 指令</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>指令系统</tag>
        <tag>控制转移</tag>
        <tag>处理器控制</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编课程记录 5</title>
    <url>/2019/11/16/%E6%B1%87%E7%BC%96%E8%AF%BE%E7%A8%8B%E8%AE%B0%E5%BD%95-5/</url>
    <content><![CDATA[<h1 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h1><p>双操作数指令必须有一个操作数在寄存器中（除源操作数是立即数的情况）<br>单操作数指令不允许使用立即数</p><p>条件标志位<br>CF 有进位为 1 无进位为 0<br>ZF 结果为零<br>SF 符号<br>OF 溢出，若两个操作数符号相同而结果的符号与之相反时为 1</p><p><strong>加法指令</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ADD DST,SRC</span><br><span class="line"></span><br><span class="line">ADC DST,SRC</span><br><span class="line">;(DST) ← (SRC)+(DST)+CF</span><br><span class="line">;带进位加法指令</span><br><span class="line"></span><br><span class="line">INC OPR</span><br><span class="line">;(OPR) ← (OPR)+1</span><br><span class="line">;加 1 指令</span><br></pre></td></tr></table></figure><a id="more"></a>




<p>除 INC 指令不影响 CF 外，其余都影响标志位</p>
<p><strong>减法指令</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SUB DST,SRC</span><br><span class="line"></span><br><span class="line">SBB DST,SRC</span><br><span class="line">;(DST) ← (DST)-(SRC)-CF</span><br><span class="line">;带借位减法指令</span><br><span class="line"></span><br><span class="line">DEC OPR</span><br><span class="line">;减 1 指令</span><br><span class="line"></span><br><span class="line">NEG OPR</span><br><span class="line">;类似 (OPR) ← 0FFFFH-(OPR)+1</span><br><span class="line">;求补指令</span><br><span class="line"></span><br><span class="line">CMP OPR1,OPR2</span><br><span class="line">;比较指令，执行 SUB 操作但不保存结果，只根据结果设置条件标志位</span><br><span class="line">;两操作数不能同时为存储器操作数</span><br></pre></td></tr></table></figure>

<p><strong>乘法指令</strong><br>目操作数必须是累加器，字节运算为 AL，字运算为 AX<br>源操作数允许立即数外的寻址方式<br>两个 8 位数相乘得 16 位乘积存放在 AX；两个 16 位数相乘得 32 位乘积，高字位送 DX 低字位送 AX</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MUL SRC</span><br><span class="line">;无符号数乘法指令</span><br><span class="line">;(AX) ← (AL)*(SRC)</span><br><span class="line">;(DX,AX) ← (AX)*(SRC)</span><br><span class="line"></span><br><span class="line">IMUL SRC</span><br><span class="line">;有符号数乘法指令</span><br></pre></td></tr></table></figure>

<p>MUL 指令中，若高一半为 0，即字节操作的 (AH) 或字操作的 (DX) 为 0，则 CF OF 为 0，否则为 1，可以用于检查字节相乘的结果是字节还是字，或检查字相乘的结果是字还是双字<br>IMUL 指令中，若乘积的高一半是低一半的符号扩展，则 CF OF 均为 0，否则均为 1</p>
<p><strong>除法指令</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DIV SRC</span><br><span class="line">;(AL) ← (AX)/(SRC) 的商</span><br><span class="line">;(AH) ← (AX)/(SRC) 的余数</span><br><span class="line">;源操作数为 8 位时，被除数必须 16 位</span><br><span class="line">;被除数必须预先存在 AX 中</span><br><span class="line">;(AX) ← (DX,AX)/(SRC) 的商</span><br><span class="line">;(DX) ← (DX,AX)/(SRC) 的余数</span><br><span class="line">;被除数必须预先存在 DX,AX 中</span><br><span class="line"></span><br><span class="line">IDIV SRC</span><br><span class="line">;有符号数除法指令</span><br></pre></td></tr></table></figure>

<h1 id="逻辑操作指令"><a href="#逻辑操作指令" class="headerlink" title="逻辑操作指令"></a>逻辑操作指令</h1><p><strong>逻辑运算指令</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AND DST,SRC</span><br><span class="line">;(DST) ← (DST)∧(SRC)</span><br><span class="line">;逻辑与指令</span><br><span class="line">;源为立即数，需要清零的位为 0，不变的位设为 1</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OR DST,SRC</span><br><span class="line">;(DST) ← (DST)V(SRC)</span><br><span class="line">;逻辑或指令</span><br><span class="line">;需要置一的位为 1，不变的位设为 0</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NOT OPR</span><br><span class="line">;逻辑非指令，按位取反</span><br><span class="line"></span><br><span class="line">XOR DST,SRC</span><br><span class="line">;异或指令</span><br><span class="line">;需要取反的位设为 1，不变的位设为 0</span><br><span class="line">XOR AX,AX</span><br><span class="line">;给寄存器清零，同时使 CF 清零</span><br><span class="line"></span><br><span class="line">TEST OPR1,OPR2</span><br><span class="line">;用 AND 的结果设置条件标志位 ZF</span><br><span class="line">;可测试目的某些位是否为 0</span><br></pre></td></tr></table></figure>

<p><strong>移位指令</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHL OPR,CNT</span><br><span class="line">SAL OPR,CN</span><br><span class="line">;逻辑左移指令和算术左移指令</span><br></pre></td></tr></table></figure>

<p>将操作数 OPR 向左移动 CNT 指定的次数，低位补入相应个数的 0，CF 的内容为 OPR 最后移出的数位值<br>若需要移位的次数大于 1 则需要把位移次数置于 CL 寄存器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHR OPR,CNT</span><br><span class="line">;逻辑右移指令，参考逻辑左移</span><br><span class="line"></span><br><span class="line">SAR OPR,CNT</span><br><span class="line">;算术右移指令</span><br><span class="line">;最高位保持不变</span><br></pre></td></tr></table></figure>

<p>上面四条移位指令都可作字或字节操作，当 CNT=1 时，且移位后最高有效位发生改变，则 OF 置 1，否则置 0<br>算术位移指令适用于有符号数，逻辑移位指令用于无符号数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ROL OPR,CNT</span><br><span class="line">ROR OPR,CNT</span><br><span class="line">;循环左移指令和循环右移指令</span><br><span class="line">;将操作数 OPR 的最高最低位连接</span><br><span class="line">;将环中所有位一起向左/右循环移动 CNT 次</span><br><span class="line">;CF 的内容为 OPR 中最后移出的数值位</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RCL OPR,CNT</span><br><span class="line">RCR OPR,CNT</span><br><span class="line">;带进位循环左移指令和循环右移指令</span><br><span class="line">;将操作数 OPR 与 CF 标志位一起连接成环</span><br><span class="line">;CF 为 OPR 最后移到 CF 中的数值</span><br></pre></td></tr></table></figure>

<p>这四条指令也只影响 OF(当 CNT=1 时) 和 CF 位，循环移位指令可以改变操作数中所有位的位置</p>
<h1 id="串处理指令"><a href="#串处理指令" class="headerlink" title="串处理指令"></a>串处理指令</h1><p>将一组存放在存储器连续单元的数据称为数据串。而数据传送指令每次只能传送一个数据，故 CPU 为数据串提供了一组完成数据串传送的指令</p>
<p>若加重复前缀则要求将数据串长度/重复次数送 CX<br>源串地址应设置在 (DS:SI) 中，可指定段跨越前缀；目的串地址应设置在 (ES:DI) 中，不能指定段跨越前缀<br>操作数不是串时只能使用累加器 (AL/AX)<br>所有串处理指令前都必先对方向标志 (DF) 置值</p>
<ul>
<li>CLD 使 DF=0，控制地址自动增加 1(字)/2(字节)</li>
<li>STD 使 DF=1，控制地址自动减少 1(字)/2(字节)</li>
</ul>
<p><strong>重复前缀</strong><br>配合串处理指令的重复操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REP 串指令</span><br><span class="line">;重复串操作</span><br><span class="line">;1. 如 (CX)=0，则退出串操作，否则继续执行</span><br><span class="line">;2. (CX) ← (CX)-1</span><br><span class="line">;3. 执行其后的串操作</span><br><span class="line">;4. 从 1 重复</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REPE/REPZ 串指令</span><br><span class="line">;相等则重复串操作</span><br><span class="line">;即 (CX)=0 或 ZF=0 </span><br><span class="line">;增加了两个操作数不等则退出串操作</span><br><span class="line"></span><br><span class="line">REPNE/REPNZ 串指令</span><br><span class="line">;不相等则重复串操作</span><br><span class="line">;即 (CX)=0 或 ZF=1</span><br></pre></td></tr></table></figure>

<p><strong>与 REP 配合的指令</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOVS DST,SRC</span><br><span class="line">MOVSB</span><br><span class="line">MOVSW</span><br><span class="line">;串传送指令</span><br><span class="line">;((ES:DI)) ← ((DS:SI))</span><br><span class="line">;(SI) ← (SI) ±1/±2</span><br><span class="line">;(DI) ← (DI) ±1/±2</span><br></pre></td></tr></table></figure>

<p>不影响标志位<br>执行前的准备工作：</p>
<ul>
<li>将存放于数据段的源串首地址(DF=0)或末地址(DF=1)放入 SI</li>
<li>将存放于附加段的目的串首地址(DF=0)或末地址(DF=1)放入 SI</li>
<li>将数据串长度放入 CX 寄存器</li>
<li>建立方向标志</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">STOS DST</span><br><span class="line">STOSB</span><br><span class="line">STOSW</span><br><span class="line">;将数存入串指令</span><br><span class="line">;((ES:DI)) ← (AL) 或 (AX)</span><br><span class="line">;(DI) ← (DI) ±1/±2</span><br></pre></td></tr></table></figure>

<p>与 REP 配合时可把 AL/AX 的内容存入长度为 (CX) 的缓冲区，常用于对一段数据区进行初始化，不影响标志位</p>
<p><strong>与 REPE/REPZ REPNE/REPNZ 配合的指令</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CMPS SRC,DST</span><br><span class="line">CMPSB</span><br><span class="line">CMPSW</span><br><span class="line">;串比较指令</span><br><span class="line">;以 ((ES:DI)) - ((DS:SI)) 的结果设置标志位</span><br><span class="line">;(SI) ← (SI) ±1/±2</span><br><span class="line">;(DI) ← (DI) ±1/±2</span><br></pre></td></tr></table></figure>

<p>可配合找出两组数据串中不同/相同的字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SCAS DST</span><br><span class="line">SCASB</span><br><span class="line">SCASW</span><br><span class="line">;串查找指令</span><br><span class="line">;以 (AL) 或 (AX) - ((ES:DI)) 的结果设置标志位</span><br><span class="line">;(DI) ← (DI) ±1/±2</span><br></pre></td></tr></table></figure>

<p>可配合找出两组数据串中与指定字符不同/相同的元素</p>
<p><strong>不与重复前缀配合的指令</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LODS SRC</span><br><span class="line">LODSB</span><br><span class="line">LODSW</span><br><span class="line">;从串中取数指令</span><br><span class="line">;(AL) 或 (AX) ← ((DS:SI))</span><br><span class="line">;(SI) ← (SI) ±1/±2</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>汇编</category>
      </categories>
      <tags>
        <tag>指令系统</tag>
        <tag>控制转移</tag>
        <tag>算数运算</tag>
        <tag>逻辑操作</tag>
        <tag>串处理</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/09/04/hello-world/</url>
    <content><![CDATA[<center>九月四日，YUYU向宇宙发出的第一声啼鸣，以太阳为中心，以光速向宇宙深处飞驰......(x<center>
</center></center>]]></content>
  </entry>
  <entry>
    <title>寂静之城</title>
    <url>/2020/03/03/%E5%AF%82%E9%9D%99%E4%B9%8B%E5%9F%8E/</url>
    <content><![CDATA[<blockquote>
<p> 2005年第5期《科幻世界》作者马伯庸</p>
</blockquote><hr><p>And in the naked light I saw ten thousand people, maybe more.<br>People talking without speaking, people hearing without listening.<br>People writing songs that voices never shared, no one dared disturb the sound of silence.</p><a id="more"></a>


<p>— The sound of silence</p>
<p>美利坚合众国，2015 年，纽约。</p>
<p>当电话响起来的时候，阿瓦登正趴在电脑前面睡觉。电话铃声十分急促，尖锐，每一次振动都让他的耳膜难受好久。他揉了揉干涩的眼睛，十分不情愿地爬起来，觉得脑子沉滞无比。</p>
<p>其实他的脑子一直就很沉滞，这种感受既然是生理上的也是心理上的。他身处的房间很狭窄，空气不很好，唯一的两扇窗户紧闭着——即使打开窗户也没用，外面的空气更加浑浊。这是一间大约只有三十平米的小屋子，屋子墙壁上泛黄的墙纸有好几处开始剥落，天花板上的水渍渗成奇怪的形状；一张老式的军绿色行军床摆在墙角，床腿用白漆写着编号；紧挨着行军床的是一张三合板制成的电脑桌，桌上摆着一台浅白色的电脑，机箱后面五颜六色的电线纠缠在一起，把它们自己打成一个古怪的死结，杂乱无章地蔓延到地板与墙角，仿佛常春藤一样。</p>
<p>阿瓦登走到电话前，慢慢坐到地板上，目光呆滞地盯着电话，手却没有动。这部古怪的东西是老式的按键式电话，大概是十几年前的款式，这是阿瓦登有一次去费城出差时偶尔在一家杂货店里买到的；他拿回家以后稍微修理了一下，发现居然还能用，这让他当时小小地兴奋了一阵子。</p>
<p>电话继续在响着，已经是第七声。阿瓦登意识到自己不得不去接听了。于是他弓下腰，用两个指头拈起电话，慢慢把电话放到耳边。</p>
<p>“请说出你的网络编号？”话筒里传来的声音并不急噪，事实上它也不带其他任何的感情色彩，因为这是电脑合成的人工智能语音系统。<br>“19842015”<br>阿瓦登熟练地报出一连串数字，同时开始觉得胸有些更闷了。说实话他并不喜欢这些空洞的电子声音。</p>
<p>他有时候想，假如打过电话来的是一位声音圆润的女性该多好。阿瓦登知道这是一种不切实际的幻想，不过这幻想会让他的身体得到几秒钟的舒缓。<br>话筒里的声音仍旧在继续着。<br>“关于你在十月四日提交的网络论坛用户注册申请已经被受理，经有关部门审查后确认资格无误，请在三日内持本人身份证件、网络使用许可证及相关文件前往办理登记手续，并领取用户名及密码。”<br>“知道了，谢谢。”<br>阿瓦登谨慎地选择词语，同时努力挤出一副满足的微笑，好象话筒的另一侧有人在看着自己一样。放下电话，阿瓦登先是茫然地盯着它看了大约两分钟，然后站起来活动一下手腕，坐回到电脑前面，缓慢地推动了一下鼠标。<br>电脑屏幕“啪”地一声亮了起来，显示出一个登陆的界面，还有一行英文：“请输入你的网络编号和姓名。”阿瓦登将那八位数字敲进去，又输入了自己的名字，点击“登陆”。随即机箱的指示灯开始频繁地闪动起来，整个机器发出细微的噪音。</p>
<p>每一个使用互联网的人都有一个网络编号，没有这个编号，就无法连接进互联网络。每一个编号都是独一无二的，每个人只有一个；这是使用者在网上的唯一代号，既不能修改，也不能取消。这些编号分别对应着使用者身份证上的名字，因此 <code>19842015</code> 就是阿瓦登，阿瓦登就是 <code>19842015</code>。阿瓦登知道有些记忆力不好的人会把自己的编号印在衣服的后面，那看起来颇为滑稽，也容易引发一些不正当的联想。</p>
<p>有关部门说使用网络实名制是为了规范网络秩序方便管理，杜绝因匿名使用网络而产生的一系列重大问题和混乱。阿瓦登不太清楚那一系列重大问题会是什么，他自己没试过用假名上网，他所认识的任何人里也不曾有人尝试过——事实上，从技术角度来说，他根本没办法匿名登陆互联网络，没有编号就没有权限上网，而编号则连接着他的详细档案，换句话说，没人能在网上隐藏自己。有关部门把这一切都考虑的很周详。<br>“有关部门”，这是一个语意模糊、但却有着权威与震慑力的词组。它既是泛指，又是确指，其所涵盖的意义相当广泛。有时候，它指的是为阿瓦登颁发网络编号的美国联邦网络管理委员会；有时候它是将最新通告及法规发到阿瓦登 EMAIL 信箱的服务器；还有时候它是监察网络的 FBI 特属网络调查科；总之一句话，有关部门是无处不在，无职不司的，总会在适当的时候出现，给予指导、监控或者警告，无论你是在网上还是网下。<br>简直就象是老大哥一样无微不至。</p>
<p>电脑仍旧在持续运转着，阿瓦登知道这得花上一阵子。这台电脑是有关部门配发给他的，具体型号和配置阿瓦登并不清楚，机箱是被焊死的，无法打开。于是他拿出一小瓶清凉油，用右手小拇指的指甲挑出一点抹在自己的太阳穴，然后从脚下堆积如山的杂物里翻出一个塑料杯子，从桌子旁的饮水机里接了半杯蒸馏水，就着一片镇痛片一饮而尽。蒸馏水穿过喉咙和狭长的食道滑进胃里，空泛的味道让他有些恶心。</p>
<p>音响里忽然传来一阵美国国歌的旋律，阿瓦登放下杯子，重新把目光投到电脑上去。这是已经连入互联网络的标志。屏幕上首先跳出来的是有关部门的通告，白底黑色四号字，里面陈述了使用互联网的意义以及最新的规章制度。<br>“缔造健康的互联网络，美国万岁！”<br>音响里传来激昂的男性呼声，阿瓦登不大情愿地跟着大声念了一遍。“缔造健康的互联网络，美国万岁！”</p>
<p>这段呼号持续了三十秒钟，然后消失，取而代之的是写着“缔造健康的互联网络”标语的桌面背景。另外一个窗口慢慢浮上开，上面开列出几个选项：工作、娱乐、电子信箱和 BBS 论坛。其中 BBS 选项呈现灰色，说明这项功能还没有开通。<br>整个操作系统简洁明了，这台电脑的浏览器没有地址输入栏，只是在收藏夹里有几个无法修改的的网站地址。理由很简单，这些网站都是健康向上的，假如其他站点和这些网站一样，那么只保留这些网站就够了；假如其他站点与这些网站不一样，那么就是不健康的，是低级趣味，不能保留。这是有关部门精心设计的，是为了公民的精神健康着想，生怕他们受到不良信息的侵染。</p>
<p>阿瓦登首先点开了“工作”，一连串和他工作相关的站点列表与相关软件在电脑上显示出来。阿瓦登是一名程序员，他每天的工作就是根据上级的要求编写程序。这份工作很无聊，不过可以保证他有稳定的收入。他不知道自己的源代码会被用到哪里去，上级也从来没有跟他说过。<br>他打算继续昨天的工作，但是很快发现自己很难继续下去。阿瓦登觉得今天的情绪比以前要烦躁，无法集中精神，大脑还是很呆滞，胸口仍旧发闷。他试图娱乐自己，但是他发现“娱乐”选项里只有纸牌与挖地雷，根据有关部门的说法，这是两个健康的游戏，没有暴力，没有色情，不会让人产生犯罪冲动，也不涉及任何政治色彩。据说美国境外也是有互联网络站点的，不过无法连上去，因为本国的互联网络自成格局，独立自主，普通人无法直接连接到国外——IE 浏览器没有地址栏，就算知道地址也没有用处。</p>
<p>“您有一封新邮件。”<br>系统忽然跳出来提示，阿瓦登终于找到了可以暂停工作的理由，他很快移动鼠标到电子信箱的选项上，点开，很快一个新的界面出现了。<br>“To: 19842015<br>From：10045687<br>Subject: 模块、已经、完成、当前、项目、是否、开始。”</p>
<p>阿瓦登微微地叹了一口气，觉得有些失望。每一次他收到新的电子邮件，都希望能够有一次新鲜的刺激来撞击他日益迟钝的脑神经，每一次他都失望了。其实他早就知道这一点，只不过他觉得保持期待至少能够享受到几秒钟快感。就好象他期待着打电话过来的是一个圆润温柔的女性声音一样。不给自己一些渺茫的希望，阿瓦登觉得自己迟早会疯掉的。</p>
<p>这封信很简短，但是内容很充实。<code>19842015</code> 是阿瓦登的网络编号，而 <code>10045687</code> 则是他的一位同事的编号，这种工作性质的信件通常都以编号相称。信的内容是几个不连续的英文单词，这是有关部门所提倡的一种电子邮件书写方式，因为这样可以方便软件检查信件中是否含有敏感词汇。<br>阿瓦登打开回信的页面，同时另开了一个窗口，打开一份名字叫做“网络健康语言词汇列表”的 TXT 文档。这是有关部门要求每一位网民所必须使用的词汇。当他们书写电子邮件或者使用论坛服务的时候，都得从这个词汇列表中寻找适合的名词、形容词、副词或者动词来表达自己想要说的话。一旦过滤软件发现网民使用了列表以外的词，那么这个词就会被自动屏蔽，取而代之的是“请使用健康语言”。<br>“屏蔽”是个专有名词，被屏蔽的词将不允许再度被使用，无论是在书信里还是口头都不允许。讽刺的是，“屏蔽”一词本身也是被屏蔽的词汇之一。<br>这个列表是经常更新的，每一次更新都会有几个词在列表上消失，于是阿瓦登不得不费劲脑汁寻找其他词语来代替那个被屏蔽掉的词语或者单字。比如在以前，“运动”这个词是可以使用的，但后来有关部门宣布这也是一个敏感词汇，阿瓦登只好使用“质点位移”来表达相同的意思。</p>
<p>他对照着这份列表，很快就完成了一封文字风格与来信差不多的 <code>EMAIL</code>——健康词汇表迫使人们不得不用最短的话来表达最多意思，而且要尽量减少不必要的修辞，所以这些信件就好象是那杯蒸馏水一样，淡而无味，阿瓦登有时候想，他早晚也会和这些水和信一样腐烂，因为这些信是他写的，水是他喝的。<br>接下来阿瓦登启动检查软件先扫了一遍，确保自己没无意中加入什么敏感词汇。等这一切都完成后，他按下了发送键，邮件被送出去了。<br>阿瓦登没有留下备份，因为他的机器里没有硬盘，也没有软驱、光驱或者 USB 接口。这个时代宽带技术已经得到了很大发展，应用软件可以集中在统一的一个服务器中，个人用户调用时的速度丝毫不会觉得迟滞。因此个人不需要硬盘，也不需要本地存储，他们在自己电脑里写的每一份文档、每一段程序、甚至每一个动作都会被自动传送到有关部门的公共服务器中，这样便于管理。换句话说，阿瓦登所使用的电脑，仅仅具备输入和输出两种功能。<br>完成了这封信后，阿瓦登再度陷入了软绵绵的焦躁状态，这是一个连续工作了三天的程序员的正常反应。这种情绪很危险，因为它让人效率低下精神低迷，而且没有渠道发泄。“疲劳”、“烦躁”以及其他负面词汇都属于危险词汇，如果他写信给别人抱怨的话，那么对方收到的将会是一封写满“请使用健康语言”的 <code>EMAIL</code>。</p>
<p>这就是阿瓦登每天的生活，今天比昨天更糟糕，但应该比明天还稍微好一点。事实上这个叙述也很模糊，因为阿瓦登自己并不清楚什么是“好一点”，什么是“更糟糕”。“好”与“坏”是两个变量，而他的生活就是一个定量，只有一个常数叫“压抑”。<br>阿瓦登推开鼠标，把脑袋向后仰去，长长地呼了一口气。（至少“呼”这个字还没有被屏蔽）这是空虚的表现，他想哼些歌，但却又不记得什么，转而吹了几下口哨，但那听起来与一只生了肺结核的狗差不多，只得做罢。有关部门象幽灵一样充斥在整个房间里，让他无法舒展自己的烦闷。就好象一个人在泥沼里挣扎，刚一张口就被灌入泥水，甚至无法大声呼救。<br>他的头不安分地转了几转，眼神偶尔撇到了摆在地板上的老式电话机，他忽然想到还必须要去有关部门申请自己的 BBS 论坛浏览许可证。于是他关掉“工作”和“电子邮件”窗口，退出了网络登陆。阿瓦登在做这些事的时候毫不犹豫，他很高兴能够暂时摆脱互联网络，在那上面他只是一串枯燥的数字和一些“健康词汇”的综合体。<br>阿瓦登找出一件破旧的黑色呢子大衣，那件大衣继承自他的父亲，袖口和领子已经磨损的很严重，个别地方有灰色的棉花露出来，但还是很耐寒。他把大衣套到身上，戴上一副墨绿色的护镜，用过滤口罩捂住嘴。他犹豫了一下，拿起“旁听者”别在耳朵上，然后走出家门去。</p>
<p>纽约的街上人很少，在这个时代，互联网的普及率相当地高，大部分事务在网上就可以解决，有关部门并不提倡太多的户外活动。太多的户外活动会导致和其他人发生物理接触，而两个人发生物理接触后会发生什么事则很难控制。<br>“旁听者”就是为了防止这种事而发生的，这是一种便携式的语言过滤器，当携带者说出敏感词汇的时候，它就会自动发出警报。每一位公民外出前都必须要携带这个装置，以便随时检讨自己的言语。当人们意识到旁听者存在的时候，他们往往会选择沉默，至少阿瓦登是如此。有关部门正逐步试图让网络和现实生活统一起来，一起“健康”。<br>这时候正是 11 月份，寒风凛冽，天空漂浮着令人压抑的铅灰阴云，街道两旁的电线杆仿佛落光了叶子的枯树，行人们都把自己包裹在黑色或灰色的大衣里面，浓缩成空旷街道上的一个个黑点飞快移动着。一层若有若无的烟雾将整个纽约笼罩起来，不用过滤口罩在这样的空气里呼吸将会是一件很有挑战的事情。<br>距离上一次离开家门已经有两个月了吧，阿瓦登站在公共汽车站的站牌下，不无感慨地想，周围的一切看起来很陌生，泛黄，而且干燥。那是上一次沙尘暴的痕迹。不过沙尘暴这个词也已经被屏蔽了，因此阿瓦登的脑海里只是闪过那么一下，思想很快就转移到别的事情上去了。</p>
<p>站在阿瓦登旁边的是一个穿着蓝色制服的高个男人。他先是狐疑地看了阿瓦登一眼，看到后者沉默地沉在黑色大衣里，他的两只脚交替移动，缓慢地凑了过去，装做漫不经心对阿瓦登说：<br>“烟，有吗？”<br>男人说，每一个字都说的很清晰，而且词与词之间间隔也足够长。这“旁听者”还没有精密到能够完全捕捉到每一个人语速和语调的程度，因此有关部门要求每一位公民都要保持这种说话风格，以方面检测发言人是否使用了规定以外的词汇。<br>阿瓦登转过头去，看了他一眼，舔舔自己干裂的嘴唇，回答说：<br>“没有。”<br>男人很失望，又一次不甘心地张开嘴。<br>“酒，有吗？”<br>“没有。”<br>阿瓦登又重复了一次这个词，他也已经很久没有收到烟和酒了，也许是缺货的关系吧，这是常有的事。不过有一点很奇怪，“旁观者”这一次却没有发出警报。以阿瓦登的经验，以往一旦烟、酒或者其他生活必需品发生短缺现象，这个词就会暂时成为被屏蔽掉的敏感词汇，直到恢复供给为止。<br>这个男人看起来很疲惫，红肿的眼睛是这个时代的人们普遍的特征，这是长时间挂在网上的关系。他的头发蓬乱，嘴边还留着青色的胡子碴，制服下的衬衣领口散发着刺鼻的霉味。能看的出，他也很久不曾到街上来了。</p>
<p>阿瓦登这时候才注意到，他的耳朵上空荡荡的，没有挂着那个银灰色的小玩意“旁听者”，这实在是一件严重的事情。不携带“旁听者”外出，就意味着语言不会再被过滤，一些不健康的思想和言论就有可能孳生，因此有关部门相当严厉地规定公民上街必须携带旁听者。而这个男人的耳朵旁却什么也没有。阿瓦登暗暗吃惊，一时间不知道是该去提醒还是装做没看到。他暗自想，也许向有关部门举报会更好。<br>这时候那个男人又朝他靠近了一点，眼神变的饥渴起来。阿瓦登心里一阵紧张，下意识地向后退去。这难道是一次抢劫？还是说他是个压抑太久的同性恋者？那个男人忽然扯住他的袖子，阿瓦登狼狈地挣扎却没有挣开。出乎他的意料，那个男人并没有进一步的动作，而是大吼一声，用一种阿瓦登已经不太习惯了的飞快语速向他倾泻起话语来。阿瓦登被这突如其来的爆发弄的莫名其妙，不知所措。</p>
<p>“我只是想和你多几句话，就几句，我很久没有说过话了。我叫斯多葛，今年三十二岁，记得，是三十二岁。我一直梦想有一套在湖边的房子，有一副钓鱼竿和一条小艇；我讨厌网络，打倒网管；我妻子是个可恶的网络中毒者，她只会用枯燥乏味的话叫我的网络编号；这个城市就是一个大疯人院，里面大疯子管着小疯子，并且把所有没疯的人变的和他们同样疯狂；敏感词汇都去他 X 的，老 * 受够了……”<br>男人的话仿佛一瓶摇晃了很久然后突然打开的罐装碳酸饮料，迅猛，爆裂，而且全无条理。阿瓦登惊愕地望着这个突然狂躁起来的家伙，却不知道如何应对；更可怕的是，他发现自己居然对他产生了一点同情，那种“同病相怜”式的同情。男人的话这时候已经从唠叨变成了纯粹谩骂，全部都是最直抒胸臆的那种。阿瓦登已经有五、六年不曾说过这些脏话，最后一次听到这些也是四年前。有关部门认为这都有碍精神文明，于是全部都屏蔽掉了。<br>而现在这个男人就在公众场合对着他大吵大嚷，似乎要将被屏蔽掉的敏感词汇一口气全倒出来。他的目光和手势并不针对任何人，甚至也不针对阿瓦登，更象是在一个人在自说自话。阿瓦登的耳膜似乎不习惯这种分贝，开始有些隐隐做痛，他捂着耳朵，拿不定主意是干脆逃掉还是……这时候，远处街道出现两辆警车，一路闪着警灯直直冲着这座公共汽车站而来。<br>警车开到站台旁时，男人仍旧在痛骂着。警车门开了，涌出了五、六名全副武装的联邦警察。他们扑过去将那个男子按在地上，用橡皮棍痛打。男人两条腿挣扎着，嘴里的语速更快了，骂出来的话也越来越难听。其中一名警察掏出一卷胶带，“嚓”地一声扯下一条向男人的嘴贴去。男人在嘴被胶带封住之前，突然提高嗓门，冲着警察痛快无比地喊了一句：“FUXKYOU, YOUSONOFBITCH！”阿瓦登看到他的表情由疯狂变成享受，面带着微笑，似乎完全陶醉在那一句话所带来的无上快感和解脱感中。</p>
<p>联邦警察们七手八脚地将男人送进了警车，这时才有一名警察走到了阿瓦登的跟前。<br>“他，是，你朋友？”<br>“我，不，认识。”<br>警察盯了他一阵，取下他耳朵上的“旁观者”查看记录，发现他并没有提及任何敏感词汇，于是重新给他戴回去，警告他说那名男子说的全部都是极度反动的词汇，要求他立刻忘掉，然后转身押着那男子离开了。<br>阿瓦登松了一口气，其实刚才他有一瞬间涌现出一种冲动，也想在这空旷的街道上大喊一声“FUXKYOU, YOUSONOFBITCH”那一定很爽快，他心里想，因为那男子说出这句话的时候表情很享受。不过他也知道，这也是妄想的一种，“旁观者”紧帖在耳朵上的冰凉感觉时刻提醒着他。</p>
<p>街上很快就恢复了冷清，十分钟后，一辆公共汽车慢吞吞地开进站里，锈迹斑斑的车门哗啦一声打开，一个电子女声响彻整个空荡荡的车厢：“请乘客注意文明用语，严格按照健康词汇发言。”<br>阿瓦登把自己缩进大衣，压抑住自己异样的兴奋，决定继续保持沉默下去。<br>大约过了一个小时，公共汽车到了目的地。从破碎的车窗玻璃里吹进来的寒风让阿瓦登脸上挂起一层暗灰色的霜气，面部被风中的沙砾和煤渣刮的生疼。他听到电子女声报出了站名，就站起身来，象一条狗一样抖抖身上的土，走下车去。</p>
<p>车站对面就是阿瓦登要去的地方，那是有关部门负责受理 BBS 论坛申请的网络部。这是一间五层的大楼，正方形，全水泥混凝土结构，外表泛灰。如果没有那几个窗户的话，那么它的外貌将与水泥块没有任何区别：生硬、死气沉沉，让蚊子和蝙蝠都退避三舍。<br>BBS 论坛是一种奇特的东西，从理论上来讲它完全多余，BBS 的功能完全可以由 EMAIL 新闻组来取代，后者更容易管理和审查。而且申请使用 BBS 论坛资格不是件容易的事，申请人必须要通过十几道手续和漫长的审查才能有浏览资格，浏览资格三个月才会被允许在指定论坛发布帖子，至于自己开设 BBS 则几乎是不可能。<br>因此真正对 BBS 有兴趣的人少之有少。阿瓦登当初之所以决定申请 BBS 论坛资格，纯粹是因为他那种模糊但却顽强的怀旧心态，就好象他从杂货店里买的那部老式电话一样。他也不知道自己为什么会自找麻烦，也许是为了给生活带来些刺激，还是说为了强调自己和曾经旧时代的那么一点点联系，也许两者兼有之。<br>阿瓦登恍惚记得在他小的时候，互联网与现在并不太一样。并不是指技术上的不同，而是一种人文的感觉。他希望能通过使用 BBS 论坛回想起一些当年的事情。</p>
<p>阿瓦登走进网络部的大楼，大楼里和外面一样寒冷，而且阴森。走廊里没有路灯，蓝白色调的两侧墙壁贴满了千篇一律的网络规章条文与标语，冰冷的空气呼吸到肺里，让阿瓦登一阵痉挛。只有走廊尽头的小门缝隙里流泻出一丝光亮，小门的上面挂着一块牌子，上面写的是“网络部 BBS 论坛科。”<br>一走进这间屋子，阿瓦登立刻感觉到一阵温洋洋的热气。屋子里的暖气（或者是空调）开的很大，让阿瓦登冻麻了的手脚和脸麻酥酥的，有些发痒，他不禁想伸出手去挠挠。</p>
<p>“公民，请您站在原地不要动。”<br>一个电子女声忽然从天花板上的喇叭里传来，阿瓦登触电似地把手放下，恭敬地站在原地不同。他借这个机会观察了一下这间屋子。这屋子准确来说应该是一个狭长形的大厅，一道拔地而起的大理石柜台象长城一样将房间割裂成两部分，柜台上还装着一排银白色的圆柱形栅栏，直接连到天花板。屋子里没有任何装饰，没有观赏植物，没有塑料鲜花，甚至没有长椅和饮水机。<br>“缔造健康的互联网络，美国万岁。”<br>阿瓦登跟着声音重复了一遍。<br>“请前往八号窗口。”<br>电子女声的语调很流畅，因为这是电脑制作出来的，因此没有敏感词汇的限制。</p>
<p>阿瓦登转头看到在自己右手边的不远处，大理石柜台上的液晶屏幕显示着八号的字样。他走过去，拼命抬起头，因为柜台实在太高了，他只能勉强看到边缘，而无法看到柜台另一侧的情形。不过他能听到，一个人走到柜台对面，坐下去，并有翻动纸张与敲击键盘的声音。<br>“请把文件放入盒子里。”<br>柜台上的喇叭传来命令。出乎意料，这一次在喇叭里的声音却变了。虽然同样冷漠枯燥，但阿瓦登还是能分辨出它与电子女声的不同——这是一个真正的女性的声音。他惊讶地抬头望去，却什么都看不到，柜台太高了。<br>“请把文件放入盒子里。”<br>声音又重复了一次，语气里带着一丝烦躁，似乎对阿瓦登的迟钝很不满。<br>“是的，这是真正的女声……”阿瓦登想，电子女声永远是彬彬有礼不带任何感情色彩的。他把相关的电子身份证、网络许可证、网络编号和敏感词汇犯罪记录等一系列个人资料卡片一起放进柜台外的一个小金属盒子里，然后把盒子插进柜台上一个同样大小的凹槽中，关好门。<br>很快他听到“唰”的一声，他猜测这也许是对面的人——也许是个女人——将盒子抽出去的声音。</p>
<p>“你申请 BBS 服务的目的是什么？”<br>喇叭后的女声浸满了纯粹事务性的腔调。<br>“为了、提高、互联网络、工作效率、为了、缔造、一个、健康、的网络、环境，更好地、为、祖国、做出、贡献。”<br>阿瓦登一字一句地回答，心里知道这只是一道官方程序，只需要按标准回答就可以。<br>对面很快就陷入沉默，大约过了十五分钟，喇叭再度响起。<br>“最后手续确认，你已经获得 BBS 论坛浏览权。”<br>“谢谢。”<br>“砰”的一声，金属盒子从柜子里弹了出来，里面除了阿瓦登的证件以外还多了五张小尺寸光盘。<br>“这是有关部门核发给你的 BBS 论坛统一用户名与密码，BBS 论坛列表、互联网 BBS 论坛使用指南及相应法规、以及最新健康网络词汇列表。”<br>阿瓦登向前踏了一步，从盒子里将这些东西一股脑全拿出来，揣进大衣的大兜里。那些东西其实是可以全部放在同一张光盘里的，不过有关部门认为每一张光盘装一份文件有助于用户理解这些文件的严肃性和重要性，并产生敬畏。<br>他心里盼望着那个喇叭能再说两句。让他失望的是，对面传来的是一个人起身并且离开的声音，从脚步声的韵律判断，阿瓦登愈发相信这是一名女性。<br>“手续办理完毕，请离开网络部回到自己的工作岗位上。”</p>
<p>甜美空洞的电子女声从天花板上传来，阿瓦登厌恶地抽动鼻翼，拿手揉了揉，转身离开这间温暖的大厅，重新进入到寒冷的走廊。<br>在回家的路上，阿瓦登蜷缩在公共汽车上一动不动，顺利申请到 BBS 的使用权让他有些虚无缥缈的兴奋。他闭着眼睛，找了一个合适的角度躲开破窗而入的寒风，右手在兜里不断摩挲那一系列光盘，还在怀念着那一个神秘的女声。<br>如果能再一次听到该多好，他不能抑制自己这样的想法，同时用拇指的指肚在光盘上轻轻地摩擦，幻想这几张光盘也曾经被她的手触摸过。他兴奋的几乎也想破口大骂一句“FUXKYOU, YOUSONOFBITCH”，真奇怪，那名男子的骂声在他的记忆里根深蒂固，并时不时不自觉地滑到唇边。<br>忽然，他的手指在光盘上发觉到一丝异常的感觉。阿瓦登下意识地朝四周望去，确认周围一个乘客也没有后，他小心翼翼地把光盘全拿出来，就着窗外的光亮仔细端详。<br>阿瓦登很快注意到，在装有 BBS 论坛列表的光盘背面，被人用指甲轻轻地划了一道刮痕。这条刮痕很轻，如果不是阿瓦登仔细地抚摩光盘的话，是很难发觉到的。这条刮痕很奇特，是一条直线，而在这条直线末端的不远处，则是另外一条极短的刮痕，似乎刻意想弯成一个圆点。整体看上去就好象是一个叹号，或者倒过来说，象是字母 i。<br>很快他在其他四张光盘上也发现了类似的刮痕，它们造型都不同，但都似乎代表着某种符号。阿瓦登回想起喇叭里那个女声最后一句提到过的文件顺序，于是把这五张光盘按照 BBS 论坛统一用户名与密码、BBS 论坛列表、互联网 BBS 论坛使用指南、相应法规、以及最新健康网络词汇列表的顺序排列好，接着依次把那五道刮痕用手指临摹到汽车窗户上。很快那些刮痕构成了一个英文单词：<code>title</code></p>
<p>题目？这是什么意思？<br>阿瓦登看着这个单词莫名其妙，这究竟是纯属无意的痕迹，还是有人刻意为之？如果是有人刻意为之，他这么做的用意是什么？<br>这时候汽车停住了，又有几名乘客走上车来。阿瓦登挪动一下身体，不让他们看到自己在车窗上写出来的字迹，然后装做打呵欠的样子抬起袖子，轻轻把那五个字母擦掉。<br>阿瓦登暗自庆幸，如果他没有在现在发现这些光盘上的痕迹，那么以后就永远没有机会发觉了。按照规定，个人电脑是不允许使用任何存储存设备的，因此阿瓦登的电脑并没有光驱。他下一步所要做的是将这些光盘送交到管区网络安全部，由他们将光盘内资料登陆到服务器中，再转发给阿瓦登。这是为了防止个人私自在家里制造、阅读或者传播黄色或者反动信息，网络安全部发出的通告是这么解释的。联邦的网络警察经常会突入到个人家中进行临时检查，看用户是否非法拥有信息贮存设备，阿瓦登曾经亲眼见过一个邻居被警察带走，原因仅仅是因为他私自藏了一张光盘在家里——其实他只是打算拿那个当茶杯垫用。那个邻居再没回来过。<br>无论这些符号代表的是什么意思，它都是一种全新的体验，这让阿瓦登感觉到兴奋。怀旧与渴望新奇是阿瓦登生活在这个时代的两根精神支柱，否则他会与这座城市一样变的僵硬，然后窒息而死。<br>他先来到网络安全分部，将光盘交给那里的负责人，负责人反复地检查光盘和阿瓦登的表情，好象所有使用 BBS 论坛的人都不可信赖一样。末了负责人终于找不到什么破绽，只得将光盘收下，然后举起右手，阿瓦登和他一起高呼“缔造健康的互联网络”。这句话是唯一被允许可以连贯着被说出来的句子。</p>
<p>回到家里，阿瓦登脱掉大衣，摘了过滤口罩，将旁观者扔到了行军床上，然后整个人也倒进枕头里。每次出去外面都会让他疲劳，这一半是因为他孱弱的肉体已经不大适合室外活动；另外一半原因是因为他必须花费大量的精力来应付旁观者。<br>过了四十分钟，他才悠悠地醒过来，头还是和平常一样地疼，胸口还是一如既往地闷。胡乱吃了一点东西以后，阿瓦登爬到电脑桌前，打开电脑，按程序登陆上网络，习惯性地先检查了一遍信箱。<br>信箱里有七、八封新的信件，其中两封是同事发来的事务信。另外五封则是网络安全部发给他的，内容就是他送交的那几张光盘。<br>阿瓦登打开了包含有 BBS 论坛的用户名、密码和 BBS 论坛列表的两封信。他看到自己的论坛通用用户名叫做 <code>19842015</code>，和自己的网络编号完全一样，不由得有些失望。他依稀记得在小的时候，BBS 论坛的用户名是可以自己决定的，而且每一个论坛都可以不同，一个人在网上并不单只是一串枯燥数字。<br>小时候的记忆往往是跟童话和幻想混杂在一起，未必与实际相符。现实中你只能使用有关部门指定的用户名和密码，理由很简单，用户名和密码内也可能含有敏感词汇。</p>
<p>阿瓦登又打开了那份 BBS 列表，全部都是有关部门开设的官方论坛，没有私人的——事实上个人能够合法持有的电脑设备从技术上来说也无法架设新 BBS——这些论坛的主题各有侧重点不同，但基本上是围绕着如何更好响应国家号召，缔造健康互联网络来说的。比如其中一个电脑技术论坛，主题就是如何更好地屏蔽掉敏感词汇。<br>居然在这些论坛中还有一个是关于游戏的。里面正在讨论的是一个如何帮助别人使用健康词汇的网络游戏，玩家可以操纵一名小男孩在街上侦察，看是否有人使用了敏感词汇，小男孩可以选择上前指责或者通知警察，抓到的人越多，小男孩得到的褒奖就越高。<br>阿瓦登随便打开了几个论坛，里面的人都彬彬有礼，说话很“健康”，就好象街上的那些行人一样。不，准确地说，比街上的气氛还要压抑。在街上的人也许还有机会保留一下自己的小动作，比如阿瓦登刚才在公共汽车上就偷偷地写了 TITLE 五个字母；而在网上论坛，人的最后的一点隐私也全被暴露出来，有关部门随时可以调看你的一切行动，无从遁形，这就是科学技术发展所带来的进步。</p>
<p>一阵失落和失望袭上阿瓦登的心头，他合上眼睛，把鼠标甩开，重重地向后靠去。原来他天真地以为 BBS 论坛也许会少许宽松一些，现在看来甚至比现实中更叫人窒息，他感觉到自己好象陷入沉滞的电子淤泥之中，艰于呼吸。“FUXKYOU,YOUSONOFBITCH”再一次涌现到他的唇边，强烈无比，要化好大的力气才控制住。<br>忽然，他又想到了那个神秘的 <code>title</code>，那究竟是什么意思？那五张光盘里或许隐藏着什么？也许这跟 <code>title</code> 有关系？<br>阿瓦登想到这里，把目光重新转向电脑屏幕，仔细去看网络安全部发来的五封信的 <code>title</code> 部分。五张光盘各隐藏着一个字母，凑到一起就是 <code>title</code>，那么按照这个方式，那五封 EMAIL 的 <code>title</code> 凑到一起，就变成了一句话：去用户学习论坛。”<br>阿瓦登记得刚才他确实看到其中一个论坛的名字叫做“用户学习”，于是他抱着姑且一试的心态连接到这个论坛去。他希望这并不是一个巧合。</p>
<p>用户论坛是一个事务性论坛，里面是一些关于 BBS 用户资料的投诉帖和管理帖，斑竹的是一个叫 <code>19387465</code> 的人；发帖的人和回帖的人数量都很少，里面冷冷清清的。阿瓦登打开帖子列表，按照刚才的规律去搜寻每一个帖子的标题，并把它们综合到一起，很快他就得到了另外一句话：</p>
<p>“每周日辛普森大楼 5 层 B 户。”</p>
<p>又是一个谜团，阿瓦登想。但这却坚定了他的信心，这其中必定隐藏着玄机。光盘、EMAIL 和 BBS 论坛，连续三次都可以通过首词组组合的方式得到暗示，绝非巧合。<br>究竟是什么人会在有关部门的官方文件中隐藏着这样的信息呢？每周日在效率大楼 5 层 B 户又会发生什么事情呢？<br>阿瓦登终于找到了久违的兴奋感，未知事物的新奇刺激着他麻木很久的神经。更重要的是，这种在有关部门正式文件中玩弄的文字技巧，叫他有一种喘息的快感，仿佛一个密不透风的铁面罩上几个透进空气的小孔。</p>
<p>营造健康的互联网络。<br>FUXKYOU, YOUSONOFBITCH。<br>阿瓦登盯着屏幕上的桌面背景，用嘴唇比出了那句粗话的口型，并且比出了中指。</p>
<p>在接下来的日子里，阿瓦登一直处于一种潜藏的兴奋状态，就象是一个摆出无辜表情嘴里却藏着糖果的小孩子，在大人转身过去之后露出狡黠的笑容，尽情享受心中藏有秘密的乐趣。<br>日子一天一天地过去，健康词汇在列表里又少了几个，窗外的空气又浑浊了几分，这已经是生活的常态。阿瓦登自己已经开始拿网络健康词汇表当日历来用，划掉三个词就证明过了三天，划掉七个就证明过了一周，于是周日终于到来了。<br>阿瓦登抵达辛普森大楼的时间是中午，暗示的句子里并没有指明时间，阿瓦登认为在中午前往应该是比较可以接受的。当穿着深绿军大衣，耳朵上别着旁观者的阿瓦登来到辛普森大楼的入口时，他的心开始忐忑不安地跳跃起来。他在上一星期设想了无数种可能发生的情景，而现在这个谜底就要揭晓了。无论在周日效率大楼会发生什么，也不会比现在的生活更加糟糕，阿瓦登心里想，所以他并不怎么害怕。</p>
<p>他走进大楼内部，发现这里的人也很少，空旷的走廊里只听到他哒哒的脚步声与回音。一部老电梯里贴着“缔造美好网络家园”的广告，以及一个充满了正义感的男性头像海报，背景是星条旗，他在纸里用右手食指指向观看者，头上写着一行字是“公民，请使用健康词汇。”阿瓦登厌恶地转过身去，发现另外一侧也贴着同样的海报，避无可避。<br>值得庆幸的是五楼很快就到了，电梯的门一开，对面的门上就赫然挂着 B 户的牌子。门是掉了漆的绿色，门框上还点了几滴墨水，一部简易的电子门铃挂在右上角。</p>
<p>阿瓦登深深吸了一口气，伸手去按电纽。<br>电铃响起，很快屋子里传来脚步声。阿瓦登觉得这脚步的韵律很熟悉，似乎是在哪里见到过。门“咔拉”一声被打开一半，一名年轻女子一手握着把手，把身体前倾望着阿瓦登，警惕地说：<br>“你，找谁？”<br>女子疑惑地问道。阿瓦登一下子就认出了她的声音，就是那个在网络部 BBS 论坛科柜台后面的女性。她很漂亮，穿着墨绿色绒线衫，头上梳着这时代流行的短发，皮肤特别的白，只有嘴唇能看到一些血色。<br>看着女子的眼神，一瞬间阿瓦登不知道该说什么好，犹豫了一下，他举起右手，轻声回答说：“title。”<br>阿瓦登不知道这句话能否奏效，也不知道自己是否真的找对了地方，但这是他唯一能想到的回答了。他紧张地望着那女子，假如那女子忽然报警，那么自己就会被抓起来仔细审问为什么无缘无故跑到陌生人家里。“肆意游走罪”只比“使用敏感词汇罪”轻那么一点。<br>女子听到他这么说，脸上还是毫无表情，只是把头幅度很轻微地点了一下，右手谨慎地做了一个“进来”的手势。阿瓦登刚要张口，那女子严厉地瞪了他一眼，吓的他把话又吞回去了，乖乖地跟着她进了屋子。</p>
<p>一进屋子，女子首先做的就是把门关好，然后拉起来一层铅灰色的门帘挡在门口。阿瓦登不安地眨着眼睛，趁她拉门帘的时候环顾四周。这屋子是标准的两室一厅，在厅里摆放的是一套双人沙发与一个茶几，茶几上居然还有几束红紫色的塑料花。靠墙是电脑桌和电脑，墙上挂着普通的白色日历，<br>但被主人用粉红色的纸套了边，看起来颇为温馨。一盏粗笨的日光灯从天花板上垂下来，上面象是恶作剧一样挂了几缕绿色的电线，象是垂下藤蔓的葡萄架。阿瓦登注意到厅口的鞋架上有四双鞋，尺码不同，说明今天的客人并不只他一个。<br>阿瓦登正踌躇不安，忽然女子从背后拍了拍他的肩膀，示意他朝里面走。于是两个人穿过客厅另一侧的短小回廊来到其中一间卧室。卧室上挂着同样质地的铅灰色帘子，女子伸手举起帘布，推开了门。阿瓦登迈了进去，首先映入眼帘的是三名面带微笑的人类，以及一间用真正的鲜花装点的房间。屋子里有很多旧日记忆里的古老物品，比如一幅印象派的油画、一尊乌干达木雕，甚至还有一个银烛台，唯独没有电脑。<br>他正在迟疑，女子也进了屋子。她谨慎地拉好门帘关上门，将耳边的旁观者取下，回过身来对阿瓦登用曼妙的声音说道：<br>“欢迎加入说话会！”<br>“说话会？”<br>出于习惯，阿瓦登并没有把这三个字说出口，因为他不确定是否“健康”，只是用眼神表示自己的疑惑。<br>“在这里你可以随便说话，这个该死的东西不会起作用的。”女子把自己的旁观者晃了晃，那个小东西象死掉了一样，对女子句子里两个敏感词汇“随便”和“该死”充耳不闻。</p>
<p>阿瓦登一下子想到上星期在公共汽车站前碰到的男子，如果他摘下旁观者，会不会也会落到同一境地呢？那女子见他犹豫不决，指了指门口的铅灰色门帘说：“放心好了，这里是可以屏蔽掉旁观者信号的，不会有人觉察到。”<br>“你们，是什么，人，这，是，哪里？”<br>阿瓦登一边摘下耳朵上的旁观者，一边小声说道，语调还是改不了那种有关部门规定的说话方式。<br>“这里是说话会，是一个完全自由场所，在这里你可以畅所欲言，请不要拘束。”<br>另外一个人起身对他说道，这是一名瘦高的中年男子，鼻梁上的眼镜非常地厚。<br>阿瓦登嗫嚅着，却找不到发音的焦点，在四个人的注视下显得窘迫不堪，脸都要红起来。女子同情地看了他一眼：“可怜的家伙，不用太紧张，每一个刚到这里的人都是这样。慢慢就习惯了。”<br>她把手搭到阿瓦登的肩上：“我们其实见过的，当然，我见过你，而你没见过我。”她一边说，一边将自己的头发解下来，原来她留的是一头齐肩的乌黑长发，头发披下来的一瞬间阿瓦登觉得她真的很美。<br>“我……我记得你，记得你的声音。”阿瓦登终于说出了一句完整的话，虽然不够流畅。<br>“是吗，那可太好了。”女子笑起来，拉着他的手，让他坐到沙发上，递给他一杯水。阿瓦登注意到这是一个款式古老的茶杯，上面还刻着花纹，杯子里的水带着浓郁的香气，阿瓦登尝了一点，那种甜丝丝的味道对喝惯纯净水的舌头来说刺激格外地大。让他觉得浑身一下子被注进了许多活力。<br>“弄到这个可不容易，我们也不是每周都能喝到。”女子坐到他身边，两只乌黑的眼睛注视着他，“你是怎么知道这个集会的？”<br>阿瓦登把发现光盘暗示的过程说了一遍，其他四个人都赞许地点了点头。“果然是个聪明人，脑筋还没被陈腐的空气腐蚀掉。”一个三十多岁的胖子称赞道，他的嗓门大的要命。那个戴眼镜的中年人把两只手交叉在一起，表示赞同。<br>“这正是天生的说话会成员，聪明、敏锐，而且不甘屈从于沉默。”<br>“那么。”胖子提议，“先让我们鼓掌欢迎说话会的新成员吧。”<br>于是四个人鼓起掌来，小小的屋子里响起一片掌声。阿瓦登羞涩地举起杯子做回应，他还不太习惯这样的场面。等到掌声稍息，他抬起头怯生生地问道：<br>“可以问个问题吗？说话会到底是什么？”</p>
<p>带他进屋的女子伸出食指，在他鼻子前两公分的地方比了一比，解释道：<br>“说话会，就是可以畅所欲言的集会。在这里你不必顾忌什么，说出任何你想说的东西。这里没有敏感词汇，也没有健康互联网络。这里是绝对自由的空间，你可以尽情释放你的灵魂，舒展你的身体，没有任何禁锢与束缚。”说着说着，她的声音变的高亢、奔放，里面饱含了许多早已经被屏蔽掉的词汇，阿瓦登不曾听到这样流畅连贯的话语很久了。<br>“我们的宗旨就是，说话，就这么简单。”中年人扶扶眼镜，补充道。<br>“可是，要说些什么呢？”阿瓦登又问道。<br>“任何事情，你心里想的任何事情都可以说出来。”中年人露出宽和的笑容，“尤其是那些被美国政府限制的思想。”<br>这可真是一个大胆的集会啊，这分明就是犯罪，阿瓦登心想，但他发觉自己却被这种犯罪慢慢地吸引住了。<br>“当然，有件事我们会事先说明。说话会是危险的，每一个成员都冒着被有关部门拘捕的风险。联邦执法人员也随时可能破门而入，以非法集会以及非法使用不合法词语的名义把我们抓起来。你现在有权拒绝加入，并且离开。”<br>阿瓦登听到女子的警告，心里一度犹豫起来。但一想到此刻离去的话，那么又要开始持续那种窒息的泥沼生活，他就难以压抑自己的烦闷。阿瓦登第一次发现，原来“说话”对他来说是一个致命的诱惑，他先前并不知道自己原来是如此地渴望着说话。<br>“我不会离开的，我要加入你们，说话。”<br>“那太好了。唔，那么不妨就从自我介绍开始吧。”女子高兴地说，同时站起身来，把右手搭到胸前，“从我开始。我的名字叫阿尔特弥斯，至于网络编号和身份证号码，让他们见鬼去吧！谁会去管那个！我有我自己的名字，我不是数字。”</p>
<p>她的话让所有人包括阿瓦登都笑了起来。接着她继续说道：“不过，这其实只是一个假名，这是希腊神话里的女神。”<br>“假名？”<br>“是的，和我户籍本上的名字是不同的。”<br>“可是，为什么？”<br>“你不会对自己在档案里的名字厌倦吗？我想起一个自己喜欢的名字，哪怕只有一次机会也好，自己想叫什么就叫什么。在这个说话会里的每一个人都有一个自己喜欢的名字，我们彼此拿这个称呼。”<br>阿瓦登若有所思地点点头，他很理解阿尔特弥斯的想法。事实上当他在使用网络论坛的时候，也希望能够自己取一个称心如意的名字，而不是被分配一个用户名。<br>通过介绍，阿瓦登了解到阿尔特弥斯是网络部 BBS 论坛管理科的职员，今年 23 岁，未婚，最讨厌蟑螂和蜘蛛，喜欢缝纫与园艺，屋子里的花就是她偷偷从城市边缘摘回来的。</p>
<p>接下来是那名中年人，他自我介绍说名字叫兰斯洛特，41 岁，是城市电厂的一名工程师；兰斯洛特这名字出自英国的亚瑟王传说，是一名忠贞的骑士。他有自己的老婆和两个孩子，一男一女；男孩三岁，女孩四岁，他们最喜欢吃的就是柠檬味道的水果糖。说到这里，兰斯洛特说希望下次聚会能把他们也带了，孩子们正是学说话的时候，他想教给他们真正的说话。<br>那个三十多岁的胖子是网络部的一名网管，叫瓦格纳。这个身份让阿瓦登吃惊不已，他的印象里网管都是些绷着脸全无表情的冷漠生物，但眼前的瓦格纳脸圆滚滚的，油光锃亮，嘴边两条翘起的小胡子神气十足。他喜欢的是雪茄和歌剧，利用网管的特权这两样东西都不难弄到。<br>“这个能屏蔽掉信号的门帘就是他弄的。”阿尔特弥斯补充说，瓦格纳冲她做了个“乐意为您效劳”的手势，然后点燃了雪茄，把它放到嘴里，很快屋子里就笼罩起一片稀薄的烟雾。<br>说话会的第四名成员是一位穿着黑色制服的女性，今年刚满三十。她的名字是杜拉丝，城市日报（那个时代的报纸已经全部都数字化了）的编辑，她比阿尔特弥斯还瘦，颧骨高高耸起，眼窝身陷，两片薄薄的嘴唇即使在最说话的时候也很少分开，看不到牙齿。爱好是饲养狗和猫，尽管她并没有养。<br>“那么，到你了。”阿尔特弥斯对阿瓦登说。阿瓦登想了想，结结巴巴地把自己的情况说了一遍，当谈到自己的爱好时候，他一时间居然想不到自己喜好什么，似乎什么都没有，在那之前他甚至从来没想过。<br>“那，你最想做的是什么事呢？”阿尔特弥斯把手再一次放在他肩上，诱导着问道。<br>“真的什么都可以？”<br>“什么都可以，在这里没有任何限制。”</p>
<p>阿瓦登觉得自己终于找到机会了，他咳了一声，抓抓头，脱口而出一句响亮的叫喊：“FUXKYOU, YOUSONOFBITCH！”</p>
<p>在一瞬间，在座的四个人都被他这句话震惊了。瓦格纳率先反应了过来，他先叼住雪茄，用力鼓掌，然后用右手把雪茄取下来，张嘴大声地赞叹道：“真棒，痛快，这简直是最完美的入会誓词。”<br>“我宁可听十遍这样的脏话，也不想再去碰那个乏味的电子女声。”兰斯洛特也是一脸陶醉，毫不掩饰自己对电子女声的厌恶。而阿尔特弥斯和杜拉丝全都咯咯地笑起来，杜拉丝发现自己的笑容幅度大了一点，不好意思地把嘴掩住。阿瓦登觉得他们与其说是觉得新奇，不如说是在享受这句脏话所带来的对体制的蔑视与挑战。<br>“那你叫希望自己叫什么名字呢？” 阿尔特弥斯歪着头问。<br>“唔……王二。“ 阿瓦登沉吟了一下，回答说。这是一个中式的名字，他以前有一个中国人朋友，喜欢讲故事，故事里的主角名字总是叫王二。<br>屋子里的气氛现在完全融洽了，大家都开始谈些比较自然的话题，每个人都摆出了最舒服的姿势，阿尔特弥斯不时拿起茶壶来为大家续水。阿瓦登紧张的心情逐渐放松下来，他感觉到自己的脑子前所未有地轻松。</p>
<p>“你知道的。”阿尔特弥斯又给他倒了一杯甜水，“我们一直想把说话会保持在一定规模，平日是没有办法畅所欲言的，我们需要空间。麻烦的是，我们没办法公开征集会员，又不可能直接通过物理接触去寻找，那风险太大。于是兰斯洛特就设计了一套暗示系统，只有发现这些暗示的人才能知道本会的存在。”<br>“这套系统考虑到的还不止是安全问题。”兰斯洛特把自己的眼镜摘下来仔细擦拭了一下，得意地说，“这其实也是一个会员资格验证。说话会所吸纳的成员，必须有智慧，有头脑，内心渴望激情，并且对自由有着渴望。”<br>瓦格纳用两根指头夹着雪茄，在事先准备好的烟灰缸里弹了弹烟灰，大声说道：“据我的经验，申请 BBS 论坛服务的人，大多数都是为了怀旧，或者说渴望一些新鲜的东西，这样的人往往都怀有激情，认为 BBS 论坛也许能给他们一些与现实不一样的东西——当然，事实上并非如此，美国政府对 BBS 论坛的管理甚至严厉过电子邮件——这暗示着他们心里渴望解脱束缚。因此我们将暗示隐藏在申请 BBS 论坛的光盘之中，只有申请人才有机会接触到这些暗示。而只有那些有智慧、观察敏锐的人才会发觉到这些暗示的存在，并顺利解读出来，找到这里。”<br>“归根到底，说话会也不过是一群渴望自由说话的秘密小团体罢了。”兰斯洛特笑道。<br>“你是第二个找到说话会的人，第一个是杜拉丝小姐。”<br>阿尔特弥斯告诉阿瓦登。阿瓦登敬佩地看了杜拉丝一眼，后者淡淡地回答道：“这没什么，这是我的工作，我的工作就是摆弄文字。”</p>
<p>阿瓦登想到上一周在公共汽车站碰到的那个疯狂男子，于是把这件事讲给其他成员听。听完之后，兰斯洛特摇了摇头，从嘴唇里滑出一声叹息：<br>“这样的事情我也是见过的，我的一个同事就是如此。所以说话会的存在是必要的，这是缓解压力的阀门。长时间的敏感词汇限制会让人都疯掉的，因为他们既无法思考又没办法表达。”<br>“这正是美国政府有关部门所希望看到的，这样只有傻瓜能够存活下来，一个全是傻瓜的社会是稳定的。” 瓦格纳费力地把自己肥胖的身躯挪了一下位置，轻蔑地说。<br>“你也是有关部门的一分子，瓦格纳先生。”阿尔特弥斯一边往茶杯里续了些热水，一边抬头轻声说道。<br>“阿尔特弥斯小姐，我只是一个能比普通人多使用几个敏感词汇的普通人而已。”<br>大家都笑了起来。阿瓦登从来没有见过这么多的人说这么多的话，这是前所未有的奇妙经验。他惊讶地发现自己居然很快就融进了这个小圈子里，隔阂与陌生感很快就消失了；同时消失的还有胸闷与头晕等习惯性的毛病。<br>很快话题就从说话会本身扩展到了更加宽泛随意的话题，阿尔特弥斯唱支歌，兰斯洛特说了几个笑话，杜拉丝则给大家讲了美国南部诸州的风土人情；瓦格纳甚至还唱了一段歌剧，虽然阿瓦登一个字也听不懂，但他一点也不吝惜掌声。在这个城市的某一个被屏蔽掉的角落里，五个不甘沉默的人正在享受着在这个时代视为奢侈品的事情——说话。</p>
<p>“王二，你可曾看过《1984》？”<br>阿尔特弥斯忽然问道，她就靠着阿瓦登坐下，阿瓦登摇摇头，反问道：“这是网络编号的一段么？”<br>“这是一本书的名字。”<br>“书？”阿瓦登听到这个名词，头摇的更大了。这是个古老的名词，在这个电脑技术非常发达的时代，网络可以承载一切信息，任何人都可以在网上图书馆查到电子版；因此有关部门认为实体书籍变成了一种没有必要存在的浪费，实体书也就逐渐消亡了。瓦格纳对此的评论是：“有关部门喜欢电子书籍的心情是可以理解的，电子书籍的话，只需要 FIND 和 REPLACE 两个命令就可以消灭掉全部不健康词汇，替一本书消毒；而实体书籍的校对与修订却是件旷日持久的工作。”<br>“这是一本伟大的书，是旧世界哲人们对我们这个时代的预言。”阿尔特弥斯认真地说。“它很早以前就洞察到了肉的束缚与解脱，灵的束缚与解脱，这是说话会的基石。”</p>
<p>阿瓦登不无惊奇地发现他的网络编号开头恰好是这这本书名字：<code>19842015</code>。<br>“那么，该怎么样才能看到呢？”阿瓦登盯着阿尔特弥斯乌黑色的眼睛问。<br>“我们也无法找到纸质版，网络图书馆不可能存在这样的书。”兰斯洛特摇摇头，然后重新露出笑容，左手向着杜拉丝摆了个请的姿势，“但我们的杜拉丝小姐应该为她的记忆力而自豪，她在很早已经有幸阅读过这两本书，并且能够记得里面的大部分文字。”<br>“太好了，然后她写下来了，对吗？”<br>“那太危险，这时代持有实体书是个大罪过，也容易让说话会暴露。我们只是在每次聚会的时候请杜拉丝小姐为我们背诵。既然是说话会，那么把这两个故事讲出来不是更名符其实吗？”<br>大家都安静下来，杜拉丝站起来走到屋子中央，其他四个人坐在旁边看着她。阿瓦登不经意地把手搂在阿尔特弥斯肩上，后者微微朝这边靠过来，女性头发的幽香“咝咝”地划过他的鼻子，让他的心里一阵荡漾。屋子里非常暖和，他分不清这是花香还是阿尔特弥斯的味道。<br>杜拉丝的声音并不高，不过却很清晰有力；她的记忆力确实惊人，不仅记得情节，包括一些细节和句子都可以复述下来。杜拉丝讲到了朱丽亚假装摔倒，然后偷偷递给温斯顿一张写着“我爱你”的纸条，绘声绘色，这让听众们都听的入神了，阿尔特弥斯听的尤其认真，以至于都没有注意到阿瓦登一直注视着她。</p>
<p>“1984 的作者预见到了专制的进步，却没有预见到技术的进步。”瓦格纳在杜拉丝停下来喝水的时候发表自己的评论，阿瓦登觉得他与外貌不太相称，是个很有洞察力的技术官僚。<br>“在大洋国人们还可以靠传递纸条来偷偷表达自己的想法，但是现在不一样了。美国政府有关部门把我们全赶到了网上，而在网络技术发达的今天，我们即使想发一条短信都会被系统或者网管看的一清二楚，无从遁形。现实里呢，还有旁观者在。”瓦格纳在腿上敲了敲雪茄根部，“一句话，技术是中性的，但技术的进步会让自在的世界更自在，集权的世界更加集权。”<br>“这句话说的很有哲学家的味道哟。”阿尔特弥斯冲瓦格纳挤了挤眼睛，从抽屉里取来一把饼干和曲奇散发给大家。<br>“就好象同样是 0 和 1，有的人就能写出工具软件，有人却拿那个编出恶性病毒？”<br>阿瓦登想到一个类似的比喻，瓦格纳听了以后满意地打了个响指。<br>“很不错的比喻，王二，就是如此，真不愧是程序员。”<br>谈话持续了不知道有多久，杜拉斯看了一眼墙壁上的挂钟，连忙提醒谈兴正浓的四个人时间快到了。说话会不能持续很长时间，旁听者被屏蔽的越久，暴露的危险就越大。</p>
<p>“那么好吧，我们就抓紧最后半个小时来完成今天的活动。”<br>阿尔特弥斯一边说着，一边将桌子上的空杯子收走。兰斯洛特和瓦格纳也都站起身来，活动一下已经有些酸疼的肩膀和腰，只有杜拉丝坐在位子上没有动。<br>“活动？还有什么活动？”<br>阿瓦登奇怪地问道，说话会除了说话还有其他活动？<br>“唔，对啊，我们还有其他活动。”阿尔特弥斯撩起额前的长发，对他妩媚一笑：“我们还会和对方完全交流。”<br>“完全交流？”<br>“就是 intercourse”<br>“………………”阿瓦登一下子变的脸色苍白，呼吸急促起来，仿佛胃里被灌进去零下三十度的寒风，他几乎不相信自己的耳朵。<br>“说话会有说话的自由，也有选择与谁上床的自由。”阿尔特弥斯毫不羞涩地说，“我们互相谈话，然后选择合适的人做爱，就象我们选择我们喜欢的词汇说话一样。”<br>兰斯洛特看阿瓦登很窘迫，走过去拍拍他的肩膀，慢慢地说：“当然，我们不会强迫任何人，这完全是在自愿的基础上。今天我还要早点回去照顾小孩，你们人数正好合适。”</p>
<p>阿瓦登的脸色涨红，热的仿佛夏季的电脑 CPU，他甚至不敢多看阿尔特弥斯一眼。他憧憬过女性很长时间，但如此接近还是第一次。<br>还要回家去照顾小孩子的兰斯洛特向大家道别后就先行离去了，阿尔特弥斯将房间留给瓦格纳与杜拉丝，然后带着惶恐不安的阿瓦登来到了另外一间房间。这间显然是阿尔特弥斯的卧室，屋子里很简单，但却收拾的十分干净，在床上枕头旁还摆着一个手制的布娃娃，床单和窗帘都是粉红色的。<br>最初的是由阿尔特弥斯主动开始的，丝毫没心理准备的阿瓦登只是被动地任她摆布。经过了几轮挑逗，阿瓦登才逐渐放开，任由潜藏在自己心内的原始欲望奔流出来，那种期待听到圆润女声的青春憧憬本来只是苦闷生活的意淫，而在今天它加倍实现了。很快这种憧憬与他在现实中被压抑的郁闷合流，转化成了猛烈的冲动，让他一次又一次与阿尔特弥斯融为一体。阿瓦登不知道这种冲动和他想大声说出“FUXKYOU, YOUSONOFBITCH”冲动有什么不同，不过现在不是考虑这个的时候，他现在脑子里想的只有尽情地、全无束缚地让自己释放激情，完全没有任何束缚。<br>强烈的刺激一波波地冲击着兴奋中枢，最终一阵快感浪潮在狂暴洋面扬起头来，达到了一个极高的顶端。阿瓦登在那一瞬间感觉到了前所未有的自由，那种轻盈无比的自由，以及因自由而生的快乐与疲惫。浑身是汗的他喘息着倒在了阿尔特弥斯身上，一阵舒畅的倦意如潮水般淹没了他的身体……</p>
<p>……当他醒来的时候，发现阿尔特弥斯躺在自己身边，赤裸的身体好象一尊白玉雕像，睡姿恬美静谧。他侧过身子去，慵懒地打了个呵欠，然后阿尔特弥斯睁开了眼睛。<br>“很舒服，对不对？”她问道。<br>“是啊……”阿瓦登不知道该说什么好，他顿了顿，犹豫地说道：“你以前和兰斯洛特、瓦格纳他们也……呃，我是说，象刚才那样子过吗？”<br>“是的。”阿尔特弥斯温柔地回答，她半支起胳膊，长发从肩膀披到了胸口。她的大方坦白反而让阿瓦登有些不知所措。屋子里出现了一段时间的沉默，然后阿尔特弥斯忽然开口问道：<br>“还记得今天杜拉丝讲的那段故事吗？女主角偷偷递给男主角写着“我爱你”的纸条。”<br>“唔，还记得。”阿瓦登回答，很高兴终于能从那个拙劣的话题摆脱出来了。<br>“在有关部门的健康互联网络词汇列表里，没有爱这个字呢。在我们这个时代，我爱你也是一个敏感词汇，被屏蔽掉了。”阿尔特弥斯的眼神里似乎是感慨，又象是失落。<br>“我爱你。”阿瓦登不禁脱口而出，他知道在这间屋子里可以说出任何自己想说的话，不必顾忌。<br>“谢谢你。”<br>阿尔特弥斯听到之后只是笑了笑，起身穿上衣服，催促阿瓦登时间差不多了。阿瓦登有些失望，因为她没有预期反应的热烈，仿佛他刚才说的只是有些无关紧要的东西。<br>这时候杜拉丝和瓦格纳已经离开了，屋子里只剩他们两个人。阿尔特弥斯把他送到门口，将旁观者交给他，然后叮嘱他说：“记得在外面绝对不要提及说话会的任何事情或者任何人，我们在说话会以外的地方是完全不认识的。”<br>“我记住了。”阿瓦登回答，然后转身要走。<br>“王二。”<br>阿尔特弥斯忽然叫道，阿瓦登连忙转身，还没等他反应过来，两片柔软温暖的嘴唇忽然贴到了他的双唇，然后是一个细切的声音在耳边响起：“谢谢你，我爱你。”</p>
<p>阿瓦登觉得眼睛有些湿润，他戴上旁观者，推开门，重新步入到那一片令人窒息的世界中去，但他此时已与来时的心境大不相同。<br>此后阿瓦登的精神面貌明显有了改善。他谨慎地享受着这种秘密集会的乐趣，并且乐在其中。每一周或者两周，他们五个人都会在周日秘密地举行说话会的活动，聊天，唱歌或者听杜拉丝讲 1984 的故事。阿瓦登同阿尔特弥斯又“完全交流”了几次，偶尔他也会跟杜拉丝“交流”。他有了两个身份，一个是现实中和网上的阿瓦登，编号 19842015，还有一个是说话会里的王二。他很享受这个名字，觉得这就是自己另外的一个人生。<br>有一次集会，他们谈到了敏感词汇的问题。阿瓦登记得很早的时候——他对这方面的记忆有点模糊——有关部门给出的是一份敏感词汇列表，由网站的内部管理人员秘密参考使用，他对如何演变成现在的局面大惑不解。那一天瓦格纳带了一瓶葡萄酒，兴致很高，于是索性给他们讲了讲“屏蔽”的进化史，身为网管的他经常可以接触到这些资料。</p>
<p>在最开始美国政府只是单纯地屏蔽掉敏感词汇，但很快他们就发现这样的措施根本没有用处。很多人会采取在词组中夹杂符号或者数字的方式来绕开系统检查；于是有关部门不得不将这些近似敏感词汇也一一屏蔽掉。然而众所周知，数字与符号之间的组合方式是近乎无限的，只要你有想象力，就完全可以组合出一个新的词组而且不失掉他的原意。比如说“politic”这个词，就有“politi/c”、“政 polit/ic”、“pol/itic”等近乎无限种表达方式。<br>当有关部门意识到这个问题时，他们采取了新的策略。既然无法辨识词组，那么就用单词屏蔽。这一举措在一开始是奏效的，违规交谈的人显著减少，但很快人们就发现可以用同音字或者谐音的方式来继续表达自己的危险思想。即使有关部门封掉全部敏感词汇的同音字，也无济于事，思想活跃的美国人充分发挥了自己的想象力，使用隐喻，借代、类比、引申及其他修辞方法，或者将一个敏感词用数个不敏感的字来代替。人类的思维方式要比电脑开阔许多。电脑屏蔽掉一条路，他们还会有更多的路可以选择。<br>这一场水面以下的角力看起来似乎是美国大众要取得胜利。这时候，一个具有逆向思维精神的人出现了。他的身份不明。有人说他是有关部门的主管；也有人说他是因过度使用敏感词汇而被捕的危险人士。无论他是谁，总之整个局面被扭转过来。他向有关部门建议，不再告诉大众禁止说什么，而是规定他们只能说什么，用什么方式去说。有关部门很快就心领神会，制订了新的规章制度：取消了敏感词汇列表，取而代之的是互联网络健康语言列表，并把这举措推广到了日常生活中的语言屏蔽系统中去。</p>
<p>这一次，大众终于处于下风。以往他们与有关部门尽情地在网络与现实中捉着迷藏，而现在他们却被有关部门扼住了咽喉。这样一来，有关部门可以有效率地掌握住言论，因为整个语言的框架都被彻底控制了。在有限的空间内，大众几乎是无计可施。<br>尽管如此，大众还是不屈不挠地将这场战争——或者说游戏——继续下去，他们挑选健康词汇列表中的合法字眼来表达不合法的意思：两个连续的“稳定”意思就是“反对”，“稳定”加“繁荣昌盛”则暗示“屏蔽”。美国政府不得不对这一动向保持着警惕，并日复一日地将更多的词汇从健康词汇列表里删掉，禁止大众使用。<br>“当然，这场战争会持续下去的。只要世界上还存在着两个不同的字或者词组，那么就可以继续自由交流——你知道莫尔斯电码吧？”<br>瓦格纳说到这里，拿起茶杯一饮而尽，满意地打了一个嗝。<br>“可是，这场战争的代价就是语言的失落。表达能力会越来越贫乏，越来越淡而无味，人们会越来越倾向于沉默，这对有关部门反而是好事。”兰斯洛特摆出一副忧虑的表情，有节奏地用指关节敲击着桌面，“这样一来，岂不就等于是大众的自由意识将语言推向死亡的边缘？真讽刺啊。按照这个趋势，有关部门是不会败的，他们会笑到最后。”<br>“不，不，笑这种情感他们是不会了解的。”瓦格纳淡淡地回答。<br>“我倒是觉得，美国是一直处于恐惧的情感之中呢，生怕人们掌握了太多的词汇，表达出太多的思想，变的难以掌握。”阿尔特弥斯说完摆出一副她在上班期间冷若冰霜的呆板脸孔，学着僵硬的腔调喊了一句：“营造健康的网络环境，美国万岁！”<br>杜拉丝、兰斯洛特与瓦格纳都哈哈大笑，唯一没笑的是王二（阿瓦登）。他对于兰斯洛特刚才的那句话始终耿耿于怀：大众与有关部门的对抗，其最终结局就是语言的消亡。那么他们现在这个小小的说话会，也只不过是在一列开向悬崖的列车里关上窗帘，享受坠毁前最后的宁静罢了。<br>不过他没有说出口，因为这太煞风景了。阿瓦登不希望破坏说话会的气氛，这对他很重要。</p>
<p>从说话会回到家里，阿瓦登躺在行军床上，双手枕着脑袋，陷入了沉思。自从加入说话会以后，他变的比以前更容易陷入思考。有时候他想的是这个社会、这个互联网络或者这座城市中存在的荒谬性；有时候他想的是自己的生活；还有时候他想的是阿尔特弥斯。他不知道是不是在一个压抑的世界里，人的情感会变的格外强烈，他现在陷入对阿尔特弥斯的迷恋无法自拔。阿瓦登一直很羡慕杜拉丝讲的《1984》里面的温斯顿，他和朱利亚有一间两个人独处的小屋，一个只属于他们两个人的小世界。<br>他在与阿尔特弥斯“完全交流”的时候曾经吐露过自己的心声，阿尔特弥斯没有直接回答，而是表示两个人的关系无法再比说话会更近一步——维持现在的状态就已经是个人行为的极限，有关部门可不会一直打瞌睡。“我们只能把感情生活压缩在每周一次的说话会活动里，这已经很奢侈了。”她对他说，同时温柔地抚摩他的胸膛。“只有在说话会里，我们才是阿尔特弥斯和王二。而在其他时间里，你是 <code>19842015</code>，而我是 <code>19387465</code>。”<br>对此，阿瓦登只能发出一声轻轻的叹息，确实他不该奢求更多。<br>除了感情，发生变化的还有互联网络。自从加入说话会以后，阿瓦登逐渐发现互联网表面下潜藏的一些东西。正如瓦格纳在一次活动的时候指出，普罗大众与有关部门的战争从未结束，总会有思想和言论从严厉管制的缝隙中流泻出来。阿瓦登发现，在完全公式化的 EMAIL 与网络论坛中其实隐藏着不少耐人寻味的细节，就好象那个 title 一样，存在着各式各样的密码与隐藏寓意。这些东西出自不同人的手里，样式和破译方式都不同，阿瓦登不知道那些密码背后隐藏的是怎样的内容。不过有一点可以确知的是，说话会并不是唯一的一个地下集会，瓦格纳说的对，始终还是有人在试图用“健康”词汇表达“不健康”思想。<br>讽刺的是，给阿瓦登感触最深的，是有关部门的管制。以往他只是模糊地感觉到自己被绑缚起来，现在他能清晰地看清这种束缚与压抑的脉络，以及加诸在自己身上的各种手段。在小小说话会中享受到的自在让他更加深刻地感受到在宽阔现实中的不自在。</p>
<p>“FUXKYOU, YOUSONOFBITCH！”</p>
<p>每一次的聚会，三位男士都会轻蔑地一起高喊这一句粗话。他们清楚这不会给有关部门带来什么不良影响，不过这确实很痛快。<br>这一周，阿瓦登特别地忙碌，他的同事因为不明原因而被屏蔽掉了，这样一来整个项目就全压在了他一个人身上。这项目是为有关部分设计一种软件，用来控制大功率主动式“旁观者”的能源分配控制。软件很复杂，他不得不每天在电脑前工作十几个小时，只有在身体实在支撑不住的时候才停下来随便吃一点东西，喝一口纯净水，困了就躺在旁边的行军床上睡上一觉，爬起来继续工作。屋子里满是浑浊的烟味与袜子脏衣服的酸臭味，阿瓦登就在这种环境下蓬头垢面地敲着键盘，并不时揉揉满布血丝的眼睛。<br>偏偏在这个时候屋子里的暖气坏掉了。洋灰色的暖气片从昨天开始就变的冰凉，不再有热水流动。阿瓦登检查了一下，发现并不是管道问题，而且邻居们也碰到同样的事，看来是供热系统出了问题。这一变故的正面影响是稍微淡化了屋子内的酸臭味，负面影响是整个屋子变的有如冰窖一样。紧闭的窗户和门能挡住寒风，却挡不住寒冷，低温让本来就寒酸的房间更笼罩上一层霜气。无论是那把木椅还是行军床都象是冷酷的冰雕，屋子里唯一还有些热气的就只剩下电脑。阿瓦登不得不披上所有的御寒衣物，蜷缩在床上，把电脑的散热口对准自己。</p>
<p>有关部门宣布“供热”和“暖气”暂时也被列入敏感词汇，于是阿瓦登没办法写信向供热部门询问，只好静待，除了用来敲键盘的指头以外，尽量保持全身一动不动，以节约热量。在停止供暖后的第四天，暖气片里终于传来“哗啦哗啦”的声音，带着热气的水开始流动，屋子里恢复了温暖，“供热”和“暖气”又可以恢复使用了。于是 EMAIL 与网络论坛上全都是“庆祝有关部门恢复供应暖气，急人民之所急”的帖子，EMAIL 新闻组里也全是类似主题。<br>不过这对阿瓦登来说太晚了，他生了病，感冒，而且是重感冒。他面色苍白，全身软弱无力，头疼的象是被一枚达姆弹射入头部，只能躺在床上等医生。医生来到他家里，给他做了两三次点滴，喂了一些叫不上名字的药片，叫他静养。这一场病足足持续了数天，他不得不放弃参加这一星期的说话会，身体状况实在太差了，阿瓦登甚至怀疑自己搞不好会因此而死掉。</p>
<p>阿瓦登躺在床上，心里懊悔不已，说话会是他唯一的乐趣，现在他却没办法参加。他把头蒙在被子里胡思乱想，瓦格纳这一次会带什么特别的东西来呢？兰斯洛特有没有把两个孩子也领过来？还有阿尔特弥斯，他没参加的话，她会和谁“完全交流”呢？瓦格纳还是兰斯洛特？他还想到了杜拉丝，上一次的聚会里，杜拉丝讲到了温斯顿在秘密幽会的屋子里对朱丽亚说“我们已经死了”，朱丽亚附和着说“我们已经死了”，这时候第三个声音说道“你们已经死了。”<br>杜拉丝就讲到这里，就停住了。阿瓦登急切地想知道接下来发生了什么，第三个声音是谁，是党吗？温斯顿和朱丽亚是否会被捕，他们会有什么样的下场？不光是他，阿尔特弥斯也很希望知道后续情节的发展，不过她并没有去追问杜拉丝。</p>
<p>“让这成为一个悬疑，这样接下来的一周我们的生活都会在期待的乐趣中度过。”她对阿瓦登说，然后两个人继续沉溺于 intercourse 的快乐。<br>“也许他们都会死。”阿尔特弥斯在交流结束后，看着天花板说。<br>“也许那只是奥布林的声音，他去探望他们。”阿瓦登安慰她道，但是他的心里也不确定。<br>阿瓦登的病持续了十天，然后他终于痊愈了。他痊愈后的第一件事就是从床上爬起来，然后去看墙上的日历：这一天恰好是星期日，说话会活动的日子。阿瓦登已经缺席了一周，这已经令他如饥似渴，甚至做梦都在和他们一起喋喋不休地说着话——所幸他并没有说梦话的习惯，所以 24 小时工作的旁观者并没发出任何警报。</p>
<p>阿瓦登简单地洗了一下脸，用一把有些生锈的剃刀沾着肥皂仔细地刮掉脸上粗硬的胡须，然后咕噜咕噜地刷了刷牙齿，用手和毛巾沾着热水将自己蓬起的乱发压下去。因为生病，有关部门发了一些补贴给他，其中包括两块羊角面包、两瓶姜汁啤酒和一份精制砂糖。他将这些东西都用塑料布仔细包好，揣到宽大的军大衣里，打算带到说话会上去与大家分享。<br>今天的天气和往常一样地冷，阿瓦登把自己裹在大衣里，登上前往效率大楼的公共汽车。一路上车厢里的广播重复着“营造健康的互联网络”以及一些优秀网络用户的先进事迹；车厢前面的电子屏幕不断滚动显示着最新的健康词汇列表，一个旁观者自车顶垂下来睥睨着车内的每一个表情呆滞的人。阿瓦登坐在最后一排，望着窗外不断向后移动的建筑物与枯黄的树木发呆。<br>车子很快就到达了辛普森大楼附近的车站，阿瓦登下了车，把手放到怀里摸了摸塑料布包着的食物，朝着大楼走去。他在半路无意中抬起头，忽然一阵冰冷的寒流刺入他的胸腔，迫使他停住了脚步。</p>
<p>有什么地方不对劲！<br>他看到了效率大楼的第五层阿尔特弥斯家的窗户发生了一些奇怪的变化。以前阿尔特弥斯家面向大街的窗户总是挂着粉红色的窗帘，而现在窗帘则被扯到了两边，窗户大开，用肉眼可以勉强看到窗玻璃和屋子里雪白的墙壁。假如今天有说话会的话，阿尔特弥斯绝对不会把有屏蔽效果的窗帘打开。而且打开窗户这件事也绝不寻常，在这个城市里的室外空气十分浑浊，几乎不会有人会去开窗换气。<br>也就是说，今天并没有说话集会召开，而是发生了另外一些事情。阿瓦登望着那窗户，心情开始变的有些慌乱，他把手从兜里掏出来，叼起一支香烟，把身体靠在一根电线杆旁故做镇静，以免被行人怀疑。究竟说话会发生了什么，为什么这一周停办了呢？要知道，只要还有复数的成员能够出席，说话会就会一直办下去，难道说瓦格纳、兰斯洛特、杜拉丝和阿尔特弥斯同时无法出席？这种概率实在太小了。阿瓦登一边这样想着，一边向四周不安地张望。忽然他看到了一样东西，一个念头霎时占据了他的全部心灵，让他几乎眩晕过去。</p>
<p>“说话会本周不会有了，以后也不会有了。”阿瓦登嘴唇默默地蠕动着，面如死灰。<br>他看到在街道内侧一处不起眼的地方隐藏着一个类似雷达天线的东西，其造型很象是两个背部贴在一起的大碗。阿瓦登心里清楚这是什么东西：这正是他负责软件设计的大功率主动式“旁观者”，这造型他很熟悉。这装置可以主动发射电波去探测人们的声音，并检查其中是否存在敏感词汇。<br>这样的装置居然就安放在阿尔特弥斯家附近，那么就等于说话会完全暴露在了有关部门的监控之下。主动式旁观者的强大刺探电波会轻易刺穿她家中的铅质窗帘，把所有成员的话原封不动地传到有关部门耳朵里。</p>
<p>这是一个划时代的发明，这一技术的突破意味着有关部门可以不再被动地等待警报，可以主动出击去刺探人们在任何时间任何地点说的任何话语。阿瓦登可以想象接下来会发生什么，阿尔特弥斯他们的每一句话都被有关部门记录下来，会有机器统计出到底有多少违禁词汇被他们使用过；然后联邦警察会冲进她的屋子，将正在聚会的成员们都带走，只留下搜查过后空荡荡的房间和窗户。<br>阿瓦登想到这里，心如刀绞，他一点也不为自己的侥幸逃脱而感到幸运。他的胃袋翻腾起来，一种恶心的感觉从胃里直接升到嘴边，让他想吐，却又不能吐——因为“呕”也是个敏感词汇；大病初愈的孱弱身躯无法承受这种打击，象害了风寒一样颤抖起来，几乎站立不住。<br>他不敢继续朝前走去，仓皇地转过身去，登上另外一辆公共汽车，把嘴闭的更紧了。等阿瓦登回到自己家楼下，看到楼房附近另外一架新的主动式旁观者正在兴建中，漆黑的天线在半空舒展开来，仿佛一面巨大的蜘蛛网。看来有关部门已经着手在整个纽约市部署这种新兴高科技产品。</p>
<p>他不敢驻足观看，低着头从那巨大装置旁边走过，一路不停地走回家，然后把自己的脸紧紧地压在枕头里，却不敢哭出声音来，连一句“FUXKYOU,<br>YOUSONOFBITCH”都不能说。<br>从那以后，阿瓦登的生活回到了普通状态——就是说和原来一样沉滞、压抑、欠缺激情，健康向上，缺乏低级趣味。兰斯洛特说过：“战争的结果就是，大众的自由意识会将语言推向死亡的边缘”，现在看来，他的预言是很准确的：说话会的覆灭，导致“说话”、“歌剧”、“完全”、“交流”几个词先后被剔除出了健康词汇列表，成为敏感词汇。<br>另外，虽然阿拉伯数字还能用，但“1984”这一个数字组合也被屏蔽掉了，这让包括阿瓦登在内的程序员在编写程序时不得不谨慎地检查数字是否违规，这额外增加了很多工作量，让他更加疲惫。<br>阿瓦登不是没有担心过，也许在某一天的深夜，他就会忽然接到一封 EMAIL，让他留在家里不要动，不要试图在网络做任何动作；接着电话会响起，电子女声会把这一要求重复再重复，直到警察打开他家的大门，把他带去未知的地方，那里有未知的命运等待着他。《1984》后面的情节发展阿瓦登始终不知道，唯一知道的杜拉丝已经彻底失踪了，所以温斯顿和朱丽亚的结局始终是个谜；就好象兰斯洛特、瓦格纳、杜拉丝和阿尔特弥斯的结局一样，也不从得知。其实这两件事对于阿瓦登来说没什么本质性的区别，所以它们也可以看做是同一个谜。</p>
<p>其实他最担心的，是阿尔特弥斯。每次想到这个名字，阿瓦登就难以抑制心中的郁闷。她究竟会怎么样，彻底被屏蔽掉吗？如果是那样，那么她在这世界上遗留下来的唯一痕迹，就是一个程序员记忆里的假名而已了。<br>说话会消失后三个星期，仍旧风平浪静，没有任何人来找过阿瓦登，他也没收到过任何类似内容的 EMAIL，阿瓦登一直在想，也许是他们没有吐露出自己的下落，也可能是因为他们根本不知道——他们认识的只是一个叫王二的程序员。这个城市里有数以千计的程序员，而王二是个假名。<br>因此，生活一如既往地平静。不，确切地说，还是有一点不同的，那就是互联网络健康词汇列表：那上面的词组消失的速度比以前要快的快，每小时每分钟都有词与单字飞快地在名单上消失，阿瓦登不得不花上大量时间去更新列表，以跟紧当前形势。<br>与词汇列表更新速度相对的，EMAIL 和网络论坛上的东西越来越乏味。因为人们不得不用极有限的词去表达广泛的意思，大家都变得寡言少语。就连那些秘密的暗语和联系方式也少了许多；整个网络就象是前些天阿瓦登家里出了问题的暖气片一样：虽然名义上是给人带来温暖的东西，但却变的冰冷、僵硬，让人如坠冰窟。</p>
<p>这一天，阿瓦登从电脑前抬起头来，他看了看窗外迷茫的灰色天空，胸口一阵抽搐，不由得痛苦地咳了一声。他拿起塑料杯，将杯子里的纯净水一饮而尽，杯子丢进同样是塑料质地的垃圾桶里，发出钝钝的撞击声，他觉得自己的脑子也是一团垃圾，举起手敲了敲，果然发出同样钝钝的撞击声。<br>然后他拿起大衣，戴上墨绿色的护目镜，走出门去。阿瓦登没带便携式的旁观者，那东西已经不需要了，城市里到处都是主动式的旁观者，随时监听是否有违禁词汇的存在。整个纽约现在就象是互联网络一样，被有关部门营造成十分健康。<br>阿瓦登这一次外出是有正当理由的，他决定去取消网络论坛服务，这服务已经用不着了，因为无论 EMAIL，新闻组，BBS 论坛还是其他什么现在全部都变成了一样的东西。</p>
<p>从日历来说现在应该是春季，但外面还是很冷，高大的灰色建筑矗立在平地上，仿佛绝对零度下的石林。大团大团的风裹着黄沙与废气穿行其间，风沙无处不在，让人置身其中而难以摆脱。阿瓦登把手揣进兜里，脖子缩进领口，畏缩着向网络部的大楼走去。<br>忽然，他停下了脚步，惊讶地站在原地无法动弹。他看到阿尔特弥斯正站在前面的路灯下，穿着黑色的制服。可是她的变化有多么大啊，面容象是老了十岁，满脸都是衰老的皱纹，年轻的活力荡然无存；她听到脚步声，转过头来，两个乌黑的大眼睛显得异常空洞，目光越过阿瓦登延伸到远方，没有一个明晰的焦点。<br>阿瓦登万万没有想到会在这个时间这个地点碰到她，这让他已经沉寂已久的心灵泛起了几点火花，可惜他迟钝的神经已经无法表达出“激动”这一个简单的情感了。两个人互相对视了一阵，他终于木然走到她身边，张了张嘴唇，想对她说些什么。但是他掏出今天新发布的健康词汇列表，发现上面是一片空白——终于连最后一个词组也被有关部门屏蔽了。</p>
<p>于是阿瓦登只好保持着沉默，默默地与面无表情的她擦肩而过，继续向前走去。他的身影逐渐融入同样安静的灰色人群之中，整个城市都显得寂静极了。</p>
]]></content>
      <categories>
        <category>收集</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
</search>
